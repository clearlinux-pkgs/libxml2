diff --git a/.gitattributes b/.gitattributes
new file mode 100644
index 00000000..a688634f
--- /dev/null
+++ b/.gitattributes
@@ -0,0 +1,2 @@
+/result/** -text
+/test/** -text
diff --git a/.gitlab-ci.yml b/.gitlab-ci.yml
index 78784fba..5622b368 100644
--- a/.gitlab-ci.yml
+++ b/.gitlab-ci.yml
@@ -1,20 +1,21 @@
-default:
+.test:
   # The image was generated with the following Dockerfile. It is also used
   # for libxslt, that's why we need git and libgcrypt-dev.
   #
-  # FROM ubuntu:19.04
+  # FROM ubuntu:20.04
+  # ENV DEBIAN_FRONTEND=noninteractive
   # RUN apt-get update && \
   #     apt-get upgrade -y && \
   #     apt-get install -y --no-install-recommends \
   #         curl git ca-certificates \
   #         autoconf automake libtool pkg-config \
   #         make gcc clang llvm \
-  #         python-dev zlib1g-dev liblzma-dev libgcrypt-dev
+  #         zlib1g-dev liblzma-dev libgcrypt-dev \
+  #         python-dev python3-dev \
+  #         cmake
   # WORKDIR /tests
   # RUN curl https://www.w3.org/XML/Test/xmlts20080827.tar.gz |tar xz
   image: registry.gitlab.gnome.org/gnome/libxml2
-
-.test:
   script:
     - |
       ln -s /tests/xmlconf
@@ -27,12 +28,20 @@ gcc:
   variables:
     CFLAGS: "-O2 -std=c89 -D_XOPEN_SOURCE=700"
 
+gcc:python3:
+  extends: .test
+  variables:
+    CONFIG: "--with-python=/usr/bin/python3"
+    CFLAGS: "-O2"
+
 clang:asan:
   extends: .test
   variables:
     CONFIG: "--without-python"
     CC: clang
-    CFLAGS: "-O2 -g -fno-omit-frame-pointer -fsanitize=address,undefined -fno-sanitize=pointer-overflow -fno-sanitize-recover=all -Wno-error=cast-align"
+    CFLAGS: "-O2 -g -fno-omit-frame-pointer -fsanitize=address,undefined,unsigned-integer-overflow -fno-sanitize-recover=all -Wno-error=cast-align"
+    # LeakSanitizer requires SYS_CAP_PTRACE
+    ASAN_OPTIONS: "detect_leaks=0"
     UBSAN_OPTIONS: "print_stacktrace=1"
 
 clang:msan:
@@ -42,3 +51,121 @@ clang:msan:
     CC: clang
     CFLAGS: "-O2 -g -fno-omit-frame-pointer -fsanitize=memory -Wno-error=cast-align"
 
+.cmake:linux:
+  image: registry.gitlab.gnome.org/gnome/libxml2
+  script:
+    - cmake -DBUILD_SHARED_LIBS=$BUILD_SHARED_LIBS -DCMAKE_INSTALL_PREFIX=libxml2-install -DCMAKE_BUILD_TYPE=RelWithDebInfo -DLIBXML2_XMLCONF_WORKING_DIR=/tests -S . -B libxml2-build
+    - cmake --build libxml2-build --target install
+    - mkdir -p libxml2-install/share/libxml2
+    - cp Copyright libxml2-install/share/libxml2
+    - cd libxml2-build
+    - ctest -VV
+  after_script:
+    - cd libxml2-install
+    - tar -czf ../libxml2-$CI_COMMIT_SHORT_SHA-$CC-$SUFFIX.tar.gz *
+  artifacts:
+    paths:
+      - libxml2-$CI_COMMIT_SHORT_SHA-$CC-$SUFFIX.tar.gz
+    expire_in: 1 day
+
+cmake:linux:gcc:shared:
+  extends: .cmake:linux
+  variables:
+    BUILD_SHARED_LIBS: "ON"
+    CC: gcc
+    SUFFIX: shared
+
+cmake:linux:gcc:static:
+  extends: .cmake:linux
+  variables:
+    BUILD_SHARED_LIBS: "OFF"
+    CC: gcc
+    SUFFIX: static
+
+cmake:linux:clang:shared:
+  extends: .cmake:linux
+  variables:
+    BUILD_SHARED_LIBS: "ON"
+    CC: clang
+    SUFFIX: shared
+
+cmake:linux:clang:static:
+  extends: .cmake:linux
+  variables:
+    BUILD_SHARED_LIBS: "OFF"
+    CC: clang
+    SUFFIX: static
+
+.cmake:mingw:
+  tags:
+    - win32-ps
+  before_script:
+    - "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12"
+    - $Env:Path="C:\msys64\$Env:MINGW_PATH\bin;C:\msys64\usr\bin;$Env:Path"
+    - pacman --noconfirm -Syu
+    - pacman --noconfirm -S
+        $Env:MINGW_PACKAGE_PREFIX-cmake
+        $Env:MINGW_PACKAGE_PREFIX-libiconv
+        $Env:MINGW_PACKAGE_PREFIX-ninja
+        $Env:MINGW_PACKAGE_PREFIX-python
+        $Env:MINGW_PACKAGE_PREFIX-python2
+        $Env:MINGW_PACKAGE_PREFIX-xz
+        $Env:MINGW_PACKAGE_PREFIX-zlib
+    - if (-not (Test-Path 7za.exe)) {
+        Invoke-WebRequest -Uri https://www.7-zip.org/a/7z1900-extra.7z -OutFile 7z1900-extra.7z ;
+        cmake -E tar xf 7z1900-extra.7z 7za.exe
+      }
+    - if (-not (Test-Path libxml2-build/xmlconf)) {
+        Invoke-WebRequest -Uri https://www.w3.org/XML/Test/xmlts20080827.tar.gz -OutFile xmlts20080827.tar.gz ;
+        .\7za.exe x xmlts20080827.tar.gz -olibxml2-build
+      }
+  script:
+    - cmake -G Ninja -DBUILD_SHARED_LIBS=$Env:BUILD_SHARED_LIBS -DCMAKE_INSTALL_PREFIX=libxml2-install -DCMAKE_BUILD_TYPE=RelWithDebInfo -S . -B libxml2-build
+    - cmake --build libxml2-build --target install
+    - New-Item -ItemType Directory libxml2-install\share\libxml2
+    - Copy-Item Copyright libxml2-install\share\libxml2
+    - cd libxml2-build
+    - ctest -VV
+  after_script:
+    - .\7za.exe a libxml2-$Env:CI_COMMIT_SHORT_SHA-$Env:MINGW_PACKAGE_PREFIX-$Env:SUFFIX.7z .\libxml2-install\*
+  cache:
+    key: "$MINGW_PACKAGE_PREFIX"
+    paths:
+      - libxml2-build/xmlconf/
+      - 7za.exe
+  artifacts:
+    paths:
+      - libxml2-$Env:CI_COMMIT_SHORT_SHA-$Env:MINGW_PACKAGE_PREFIX-$Env:SUFFIX.7z
+    expire_in: 1 day
+
+cmake:mingw:w64-i686:shared:
+  extends: .cmake:mingw
+  variables:
+    BUILD_SHARED_LIBS: "ON"
+    MINGW_PACKAGE_PREFIX: mingw-w64-i686
+    MINGW_PATH: mingw32
+    SUFFIX: shared
+
+cmake:mingw:w64-i686:static:
+  extends: .cmake:mingw
+  variables:
+    BUILD_SHARED_LIBS: "OFF"
+    MINGW_PACKAGE_PREFIX: mingw-w64-i686
+    MINGW_PATH: mingw32
+    SUFFIX: static
+
+cmake:mingw:w64-x86_64:shared:
+  extends: .cmake:mingw
+  variables:
+    BUILD_SHARED_LIBS: "ON"
+    MINGW_PACKAGE_PREFIX: mingw-w64-x86_64
+    MINGW_PATH: mingw64
+    SUFFIX: shared
+
+cmake:mingw:w64-x86_64:static:
+  extends: .cmake:mingw
+  variables:
+    BUILD_SHARED_LIBS: "OFF"
+    MINGW_PACKAGE_PREFIX: mingw-w64-x86_64
+    MINGW_PATH: mingw64
+    SUFFIX: static
diff --git a/.travis.yml b/.travis.yml
index 68fe5abd..358e8cbf 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -16,7 +16,7 @@ matrix:
       sudo: required
       dist: trusty
       env: CONFIG="--without-python"
-           CFLAGS="-O2 -g -fno-omit-frame-pointer -fsanitize=address,undefined -fno-sanitize=float-divide-by-zero,pointer-overflow -fno-sanitize-recover=all -Werror -Wno-error=cast-align"
+           CFLAGS="-O2 -g -fno-omit-frame-pointer -fsanitize=address,undefined,unsigned-integer-overflow -fno-sanitize-recover=all -Werror -Wno-error=cast-align"
            UBSAN_OPTIONS=print_stacktrace=1
 script: sh autogen.sh $CONFIG && make -j2 V=1 && make check
 git:
diff --git a/CMakeLists.txt b/CMakeLists.txt
new file mode 100644
index 00000000..21a7871b
--- /dev/null
+++ b/CMakeLists.txt
@@ -0,0 +1,725 @@
+cmake_minimum_required(VERSION 3.14)
+
+project(libxml2 C)
+
+include(CheckCSourceCompiles)
+include(CheckFunctionExists)
+include(CheckIncludeFiles)
+include(CheckLibraryExists)
+include(CheckStructHasMember)
+include(CheckSymbolExists)
+include(CMakePackageConfigHelpers)
+include(GNUInstallDirs)
+
+set(LIBXML_MAJOR_VERSION 2)
+set(LIBXML_MINOR_VERSION 9)
+set(LIBXML_MICRO_VERSION 10)
+
+set(VERSION "${LIBXML_MAJOR_VERSION}.${LIBXML_MINOR_VERSION}.${LIBXML_MICRO_VERSION}")
+set(LIBXML_VERSION ${LIBXML_MAJOR_VERSION}0${LIBXML_MINOR_VERSION}0${LIBXML_MICRO_VERSION})
+set(LIBXML_VERSION_STRING "${LIBXML_VERSION}")
+set(LIBXML_VERSION_EXTRA "")
+set(LIBXML_VERSION_NUMBER ${LIBXML_VERSION})
+
+option(BUILD_SHARED_LIBS "Build shared libraries" ON)
+set(LIBXML2_WITH_AUTOMATA ON)
+option(LIBXML2_WITH_C14N "Add the Canonicalization support" ON)
+option(LIBXML2_WITH_CATALOG "Add the Catalog support" ON)
+option(LIBXML2_WITH_DEBUG "Add the debugging module" ON)
+option(LIBXML2_WITH_DOCB "Add Docbook SGML support" ON)
+set(LIBXML2_WITH_EXPR ON)
+option(LIBXML2_WITH_FTP "Add the FTP support" ON)
+option(LIBXML2_WITH_HTML "Add the HTML support" ON)
+option(LIBXML2_WITH_HTTP "Add the HTTP support" ON)
+option(LIBXML2_WITH_ICONV "Add ICONV support" ON)
+option(LIBXML2_WITH_ICU "Add ICU support" OFF)
+option(LIBXML2_WITH_ISO8859X "Add ISO8859X support if no iconv" ON)
+option(LIBXML2_WITH_LEGACY "Add deprecated APIs for compatibility" ON)
+option(LIBXML2_WITH_LZMA "Use liblzma" ON)
+option(LIBXML2_WITH_MEM_DEBUG "Add the memory debugging module" OFF)
+option(LIBXML2_WITH_MODULES "Add the dynamic modules support" ON)
+option(LIBXML2_WITH_OUTPUT "Add the serialization support" ON)
+option(LIBXML2_WITH_PATTERN "Add the xmlPattern selection interface" ON)
+option(LIBXML2_WITH_PROGRAMS "Build programs" ON)
+option(LIBXML2_WITH_PUSH "Add the PUSH parser interfaces" ON)
+option(LIBXML2_WITH_PYTHON "Build Python bindings" ON)
+option(LIBXML2_WITH_READER "Add the xmlReader parsing interface" ON)
+option(LIBXML2_WITH_REGEXPS "Add Regular Expressions support" ON)
+option(LIBXML2_WITH_RUN_DEBUG "Add the runtime debugging module" OFF)
+option(LIBXML2_WITH_SAX1 "Add the older SAX1 interface" ON)
+option(LIBXML2_WITH_SCHEMAS "Add Relax-NG and Schemas support" ON)
+option(LIBXML2_WITH_SCHEMATRON "Add Schematron support" ON)
+option(LIBXML2_WITH_TESTS "Build tests" ON)
+option(LIBXML2_WITH_THREADS "Add multithread support" ON)
+option(LIBXML2_WITH_THREAD_ALLOC "Add per-thread memory" OFF)
+option(LIBXML2_WITH_TREE "Add the DOM like tree manipulation APIs" ON)
+set(LIBXML2_WITH_TRIO OFF)
+set(LIBXML2_WITH_UNICODE ON)
+option(LIBXML2_WITH_VALID "Add the DTD validation support" ON)
+option(LIBXML2_WITH_WRITER "Add the xmlWriter saving interface" ON)
+option(LIBXML2_WITH_XINCLUDE "Add the XInclude support" ON)
+option(LIBXML2_WITH_XPATH "Add the XPATH support" ON)
+option(LIBXML2_WITH_XPTR "Add the XPointer support" ON)
+option(LIBXML2_WITH_ZLIB "Use libz" ON)
+set(LIBXML2_XMLCONF_WORKING_DIR ${CMAKE_CURRENT_BINARY_DIR} CACHE PATH "Working directory for XML Conformance Test Suite")
+
+if(LIBXML2_WITH_ICONV)
+	find_package(Iconv REQUIRED)
+endif()
+
+if(LIBXML2_WITH_ICU)
+	find_package(ICU REQUIRED)
+endif()
+
+if(LIBXML2_WITH_LZMA)
+	find_package(LibLZMA REQUIRED)
+endif()
+
+if(LIBXML2_WITH_PYTHON)
+	check_include_files(unistd.h HAVE_UNISTD_H)
+	check_symbol_exists(F_GETFL fcntl.h HAVE_F_GETFL)
+	if(HAVE_UNISTD_H AND HAVE_F_GETFL)
+		find_package(Python COMPONENTS Interpreter Development REQUIRED)
+	else()
+		find_package(Python2 COMPONENTS Interpreter Development REQUIRED)
+		add_library(Python::Python ALIAS Python2::Python)
+		set(Python_EXECUTABLE ${Python2_EXECUTABLE})
+		set(Python_SITEARCH ${Python2_SITEARCH})
+	endif()
+	set(LIBXML2_PYTHON_INSTALL_DIR ${Python_SITEARCH} CACHE PATH "Python bindings install directory")
+endif()
+
+if(LIBXML2_WITH_THREADS)
+	find_package(Threads REQUIRED)
+endif()
+
+if(LIBXML2_WITH_ZLIB)
+	find_package(ZLIB REQUIRED)
+endif()
+
+foreach(VARIABLE IN ITEMS WITH_AUTOMATA WITH_C14N WITH_CATALOG WITH_DEBUG WITH_DOCB WITH_EXPR WITH_FTP WITH_HTML WITH_HTTP WITH_ICONV WITH_ICU WITH_ISO8859X WITH_LEGACY WITH_LZMA WITH_MEM_DEBUG WITH_MODULES WITH_OUTPUT WITH_PATTERN WITH_PUSH WITH_READER WITH_REGEXPS WITH_RUN_DEBUG WITH_SAX1 WITH_SCHEMAS WITH_SCHEMATRON WITH_THREADS WITH_THREAD_ALLOC WITH_TREE WITH_TRIO WITH_UNICODE WITH_VALID WITH_WRITER WITH_XINCLUDE WITH_XPATH WITH_XPTR WITH_ZLIB)
+	if(LIBXML2_${VARIABLE})
+		set(${VARIABLE} 1)
+	else()
+		set(${VARIABLE} 0)
+	endif()
+endforeach()
+
+set(MODULE_EXTENSION "${CMAKE_SHARED_LIBRARY_SUFFIX}")
+
+set(PACKAGE "libxml2")
+set(PACKAGE_BUGREPORT "xml@gnome.org")
+set(PACKAGE_NAME "libxml2")
+set(PACKAGE_STRING "libxml2 ${VERSION}")
+set(PACKAGE_TARNAME "libxml2")
+set(PACKAGE_URL "http://www.xmlsoft.org/")
+set(PACKAGE_VERSION ${VERSION})
+
+if(LIBLZMA_FOUND)
+	list(APPEND CMAKE_REQUIRED_LIBRARIES LibLZMA::LibLZMA)
+endif()
+
+if(Threads_FOUND)
+	list(APPEND CMAKE_REQUIRED_LIBRARIES Threads::Threads)
+endif()
+
+if(ZLIB_FOUND)
+	list(APPEND CMAKE_REQUIRED_LIBRARIES ZLIB::ZLIB)
+endif()
+
+if(MSVC)
+	configure_file(include/win32config.h config.h COPYONLY)
+else()
+	check_c_source_compiles("
+		void __attribute__((destructor))
+		f(void) {}
+		int main(void) { return 0; }
+	" ATTRIBUTE_DESTRUCTOR)
+	check_c_source_compiles("
+		#include <netdb.h>
+		int main() { (void) gethostbyname((const char*) \"\"); return 0; }
+	" GETHOSTBYNAME_ARG_CAST_CONST)
+	if(NOT GETHOSTBYNAME_ARG_CAST_CONST)
+		set(GETHOSTBYNAME_ARG_CAST "(char *)")
+	else()
+		set(GETHOSTBYNAME_ARG_CAST "/**/")
+	endif()
+	check_include_files(arpa/inet.h HAVE_ARPA_INET_H)
+	check_include_files(arpa/nameser.h HAVE_ARPA_NAMESER_H)
+	check_struct_has_member("struct sockaddr_storage" ss_family "sys/socket.h;sys/types.h" HAVE_SS_FAMILY)
+	check_struct_has_member("struct sockaddr_storage" __ss_family "sys/socket.h;sys/types.h" HAVE_BROKEN_SS_FAMILY)
+	if(HAVE_BROKEN_SS_FAMILY)
+		set(ss_family __ss_family)
+	endif()
+	check_function_exists(class HAVE_CLASS)
+	check_include_files(ctype.h HAVE_CTYPE_H)
+	check_include_files(dirent.h HAVE_DIRENT_H)
+	check_include_files(dlfcn.h HAVE_DLFCN_H)
+	check_library_exists(dl dlopen "" HAVE_DLOPEN)
+	check_include_files(dl.h HAVE_DL_H)
+	check_include_files(errno.h HAVE_ERRNO_H)
+	check_include_files(fcntl.h HAVE_FCNTL_H)
+	check_function_exists(finite HAVE_FINITE)
+	check_include_files(float.h HAVE_FLOAT_H)
+	check_function_exists(fpclass HAVE_FPCLASS)
+	check_function_exists(fprintf HAVE_FPRINTF)
+	check_function_exists(fp_class HAVE_FP_CLASS)
+	check_function_exists(ftime HAVE_FTIME)
+	check_function_exists(getaddrinfo HAVE_GETADDRINFO)
+	check_function_exists(gettimeofday HAVE_GETTIMEOFDAY)
+	check_include_files(inttypes.h HAVE_INTTYPES_H)
+	check_function_exists(isascii HAVE_ISASCII)
+	check_function_exists(isinf HAVE_ISINF)
+	check_function_exists(isnan HAVE_ISNAN)
+	check_function_exists(isnand HAVE_ISNAND)
+	check_library_exists(history append_history "" HAVE_LIBHISTORY)
+	check_library_exists(lzma lzma_code "" HAVE_LIBLZMA)
+	check_library_exists(pthread pthread_join "" HAVE_LIBPTHREAD)
+	check_library_exists(readline readline "" HAVE_LIBREADLINE)
+	check_library_exists(z gzread "" HAVE_LIBZ)
+	check_include_files(limits.h HAVE_LIMITS_H)
+	check_function_exists(localtime HAVE_LOCALTIME)
+	check_include_files(lzma.h HAVE_LZMA_H)
+	check_include_files(malloc.h HAVE_MALLOC_H)
+	check_include_files(math.h HAVE_MATH_H)
+	check_include_files(memory.h HAVE_MEMORY_H)
+	check_function_exists(mmap HAVE_MMAP)
+	check_function_exists(munmap HAVE_MUNMAP)
+	check_symbol_exists(DIR ndir.h HAVE_NDIR_H)
+	check_include_files(netdb.h HAVE_NETDB_H)
+	check_include_files(netinet/in.h HAVE_NETINET_IN_H)
+	check_include_files(poll.h HAVE_POLL_H)
+	check_function_exists(printf HAVE_PRINTF)
+	check_include_files(pthread.h HAVE_PTHREAD_H)
+	check_function_exists(putenv HAVE_PUTENV)
+	check_function_exists(rand HAVE_RAND)
+	check_function_exists(rand_r HAVE_RAND_R)
+	check_include_files(resolv.h HAVE_RESOLV_H)
+	check_library_exists(dld shl_load "" HAVE_SHLLOAD)
+	check_function_exists(signal HAVE_SIGNAL)
+	check_include_files(signal.h HAVE_SIGNAL_H)
+	check_function_exists(snprintf HAVE_SNPRINTF)
+	check_function_exists(sprintf HAVE_SPRINTF)
+	check_function_exists(srand HAVE_SRAND)
+	check_function_exists(sscanf HAVE_SSCANF)
+	check_function_exists(stat HAVE_STAT)
+	check_include_files(stdarg.h HAVE_STDARG_H)
+	check_include_files(stdint.h HAVE_STDINT_H)
+	check_include_files(stdlib.h HAVE_STDLIB_H)
+	check_function_exists(strftime HAVE_STRFTIME)
+	check_include_files(strings.h HAVE_STRINGS_H)
+	check_include_files(string.h HAVE_STRING_H)
+	check_symbol_exists(DIR sys/dir.h HAVE_SYS_DIR_H)
+	check_include_files(sys/mman.h HAVE_SYS_MMAN_H)
+	check_symbol_exists(DIR sys/ndir.h HAVE_SYS_NDIR_H)
+	check_include_files(sys/select.h HAVE_SYS_SELECT_H)
+	check_include_files(sys/socket.h HAVE_SYS_SOCKET_H)
+	check_include_files(sys/stat.h HAVE_SYS_STAT_H)
+	check_include_files(sys/timeb.h HAVE_SYS_TIMEB_H)
+	check_include_files(sys/time.h HAVE_SYS_TIME_H)
+	check_include_files(sys/types.h HAVE_SYS_TYPES_H)
+	check_function_exists(time HAVE_TIME)
+	check_include_files(time.h HAVE_TIME_H)
+	check_include_files(unistd.h HAVE_UNISTD_H)
+	check_function_exists(va_copy HAVE_VA_COPY)
+	check_function_exists(vfprintf HAVE_VFPRINTF)
+	check_function_exists(vsnprintf HAVE_VSNPRINTF)
+	check_function_exists(vsprintf HAVE_VSPRINTF)
+	check_function_exists(__va_copy HAVE___VA_COPY)
+	check_c_source_compiles("
+		#include <stdlib.h>
+		#include <iconv.h>
+		extern
+		#ifdef __cplusplus
+		\"C\"
+		#endif
+		#if defined(__STDC__) || defined(__cplusplus)
+		size_t iconv(iconv_t cd, char** inbuf, size_t* inbytesleft, char** outbuf, size_t* outbytesleft);
+		#else
+		size_t iconv();
+		#endif
+		int main() { return 0; }
+	" ICONV_CONST_TEST)
+	if(NOT ICONV_CONST_TEST)
+		set(ICONV_CONST "const")
+	endif()
+	set(LT_OBJDIR ".libs/")
+	check_c_source_compiles("
+		#include <sys/socket.h>
+		#include <sys/types.h>
+		int main() { (void) send(1, (const char*) \"\", 1, 1); return 0; }
+	" SEND_ARG2_CAST_CONST)
+	if(NOT SEND_ARG2_CAST_CONST)
+		set(SEND_ARG2_CAST "(char *)")
+	else()
+		set(SEND_ARG2_CAST "/**/")
+	endif()
+	check_include_files("float.h;stdarg.h;stdlib.h;string.h" STDC_HEADERS)
+	check_c_source_compiles("
+		#include <stdarg.h>
+		void a(va_list* ap) {};
+		int main() { va_list ap1, ap2; a(&ap1); ap2 = (va_list) ap1; return 0; }
+	" VA_LIST_IS_ARRAY_TEST)
+	if(VA_LIST_IS_ARRAY_TEST)
+		set(VA_LIST_IS_ARRAY FALSE)
+	else()
+		set(VA_LIST_IS_ARRAY TRUE)
+	endif()
+	check_c_source_compiles("
+		#include <stddef.h>
+		#include <sys/socket.h>
+		#include <sys/types.h>
+		int main() { (void) getsockopt(1, 1, 1, NULL, (socklen_t*) NULL); return 0; }
+	" XML_SOCKLEN_T_SOCKLEN_T)
+	if(XML_SOCKLEN_T_SOCKLEN_T)
+		set(XML_SOCKLEN_T socklen_t)
+	else()
+		check_c_source_compiles("
+			#include <stddef.h>
+			#include <sys/socket.h>
+			#include <sys/types.h>
+			int main() { (void) getsockopt(1, 1, 1, NULL, (size_t*) NULL); return 0; }
+		" XML_SOCKLEN_T_SIZE_T)
+		if(XML_SOCKLEN_T_SIZE_T)
+			set(XML_SOCKLEN_T size_t)
+		else()
+			check_c_source_compiles("
+				#include <stddef.h>
+				#include <sys/socket.h>
+				#include <sys/types.h>
+				int main() { (void) getsockopt (1, 1, 1, NULL, (int*) NULL); return 0; }
+			" XML_SOCKLEN_T_INT)
+			set(XML_SOCKLEN_T int)
+		endif()
+	endif()
+	configure_file(config.h.cmake.in config.h)
+endif()
+
+set(
+	LIBXML2_HDRS
+	include/libxml/c14n.h
+	include/libxml/catalog.h
+	include/libxml/chvalid.h
+	include/libxml/debugXML.h
+	include/libxml/dict.h
+	include/libxml/DOCBparser.h
+	include/libxml/encoding.h
+	include/libxml/entities.h
+	include/libxml/globals.h
+	include/libxml/hash.h
+	include/libxml/HTMLparser.h
+	include/libxml/HTMLtree.h
+	include/libxml/list.h
+	include/libxml/nanoftp.h
+	include/libxml/nanohttp.h
+	include/libxml/parser.h
+	include/libxml/parserInternals.h
+	include/libxml/pattern.h
+	include/libxml/relaxng.h
+	include/libxml/SAX.h
+	include/libxml/SAX2.h
+	include/libxml/schemasInternals.h
+	include/libxml/schematron.h
+	include/libxml/threads.h
+	include/libxml/tree.h
+	include/libxml/uri.h
+	include/libxml/valid.h
+	include/libxml/xinclude.h
+	include/libxml/xlink.h
+	include/libxml/xmlIO.h
+	include/libxml/xmlautomata.h
+	include/libxml/xmlerror.h
+	include/libxml/xmlexports.h
+	include/libxml/xmlmemory.h
+	include/libxml/xmlmodule.h
+	include/libxml/xmlreader.h
+	include/libxml/xmlregexp.h
+	include/libxml/xmlsave.h
+	include/libxml/xmlschemas.h
+	include/libxml/xmlschemastypes.h
+	include/libxml/xmlstring.h
+	include/libxml/xmlunicode.h
+	include/libxml/xmlwriter.h
+	include/libxml/xpath.h
+	include/libxml/xpathInternals.h
+	include/libxml/xpointer.h
+)
+
+set(
+	LIBXML2_SRCS
+	buf.c
+	c14n.c
+	catalog.c
+	chvalid.c
+	debugXML.c
+	dict.c
+	encoding.c
+	entities.c
+	error.c
+	globals.c
+	hash.c
+	HTMLparser.c
+	HTMLtree.c
+	legacy.c
+	list.c
+	nanoftp.c
+	nanohttp.c
+	parser.c
+	parserInternals.c
+	pattern.c
+	relaxng.c
+	SAX.c
+	SAX2.c
+	schematron.c
+	threads.c
+	tree.c
+	uri.c
+	valid.c
+	xinclude.c
+	xlink.c
+	xmlIO.c
+	xmlmemory.c
+	xmlmodule.c
+	xmlreader.c
+	xmlregexp.c
+	xmlsave.c
+	xmlschemas.c
+	xmlschemastypes.c
+	xmlstring.c
+	xmlunicode.c
+	xmlwriter.c
+	xpath.c
+	xpointer.c
+	xzlib.c
+)
+
+if(WIN32)
+	list(APPEND LIBXML2_SRCS win32/libxml2.rc)
+	file(
+		WRITE
+		${CMAKE_CURRENT_BINARY_DIR}/rcVersion.h
+		"#define LIBXML_MAJOR_VERSION ${LIBXML_MAJOR_VERSION}\n"
+		"#define LIBXML_MINOR_VERSION ${LIBXML_MINOR_VERSION}\n"
+		"#define LIBXML_MICRO_VERSION ${LIBXML_MICRO_VERSION}\n"
+		"#define LIBXML_DOTTED_VERSION \"${VERSION}\"\n"
+	)
+endif()
+
+if(LIBXML2_WITH_SAX1)
+	list(APPEND LIBXML2_SRCS DOCBparser.c)
+endif()
+
+if(LIBXML2_WITH_TRIO)
+	list(APPEND LIBXML2_SRCS trio.c triostr.c)
+endif()
+
+add_library(LibXml2 ${LIBXML2_HDRS} ${LIBXML2_SRCS})
+
+if(NOT BUILD_SHARED_LIBS)
+	target_compile_definitions(LibXml2 INTERFACE LIBXML_STATIC)
+endif()
+
+if(LIBXML2_WITH_THREADS)
+	target_compile_definitions(LibXml2 PRIVATE _REENTRANT)
+	if(WIN32)
+		target_compile_definitions(LibXml2 PRIVATE HAVE_WIN32_THREADS)
+	endif()
+endif()
+
+target_include_directories(
+	LibXml2
+	PUBLIC
+	$<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}>
+	$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
+	$<INSTALL_INTERFACE:$<INSTALL_PREFIX>/${CMAKE_INSTALL_INCLUDEDIR}/libxml2>
+)
+
+if(HAVE_DLOPEN)
+	target_link_libraries(LibXml2 PRIVATE dl)
+endif()
+
+if(HAVE_SHLLOAD)
+	target_link_libraries(LibXml2 PRIVATE dld)
+endif()
+
+if(UNIX)
+	target_link_libraries(LibXml2 PRIVATE m)
+endif()
+
+if(WIN32)
+	target_link_libraries(LibXml2 PRIVATE ws2_32)
+endif()
+
+if(LIBXML2_WITH_ICONV)
+	target_link_libraries(LibXml2 PUBLIC Iconv::Iconv)
+endif()
+
+if(LIBXML2_WITH_ICU)
+	target_link_libraries(LibXml2 PRIVATE ICU::i18n)
+endif()
+
+if(LIBXML2_WITH_LZMA)
+	target_link_libraries(LibXml2 PRIVATE LibLZMA::LibLZMA)
+endif()
+
+if(LIBXML2_WITH_THREADS)
+	target_link_libraries(LibXml2 PRIVATE Threads::Threads)
+endif()
+
+if(LIBXML2_WITH_ZLIB)
+	target_link_libraries(LibXml2 PRIVATE ZLIB::ZLIB)
+endif()
+
+set_target_properties(
+	LibXml2
+	PROPERTIES
+	IMPORT_PREFIX lib
+	OUTPUT_NAME xml2
+	POSITION_INDEPENDENT_CODE ON
+	PREFIX lib
+	VERSION ${VERSION}
+)
+
+if(WIN32)
+	if(BUILD_SHARED_LIBS)
+		set_target_properties(
+			LibXml2
+			PROPERTIES
+			DEBUG_POSTFIX d
+		)
+	else()
+		set_target_properties(
+			LibXml2
+			PROPERTIES
+			DEBUG_POSTFIX sd
+			MINSIZEREL_POSTFIX s
+			RELEASE_POSTFIX s
+			RELWITHDEBINFO_POSTFIX s
+		)
+	endif()
+endif()
+
+install(FILES ${LIBXML2_HDRS} DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/libxml2/libxml COMPONENT development)
+
+install(
+	TARGETS	LibXml2
+	EXPORT LibXml2
+	ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR} COMPONENT development
+	LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR} COMPONENT runtime NAMELINK_COMPONENT development
+	RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR} COMPONENT runtime
+)
+
+if(MSVC AND BUILD_SHARED_LIBS)
+	install(FILES $<TARGET_PDB_FILE:LibXml2> DESTINATION ${CMAKE_INSTALL_BINDIR} CONFIGURATIONS Debug RelWithDebInfo COMPONENT debug)
+endif()
+
+if(LIBXML2_WITH_PROGRAMS)
+	set(
+		PROGRAMS
+		xmlcatalog
+		xmllint
+	)
+	foreach(PROGRAM ${PROGRAMS})
+		add_executable(${PROGRAM} ${PROGRAM}.c)
+		target_link_libraries(${PROGRAM} LibXml2)
+		if(HAVE_LIBHISTORY)
+			target_link_libraries(${PROGRAM} history)
+		endif()
+		if(HAVE_LIBREADLINE)
+			target_link_libraries(${PROGRAM} readline)
+		endif()
+		install(TARGETS	${PROGRAM} EXPORT LibXml2 RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR} COMPONENT programs)
+	endforeach()
+endif()
+
+if(LIBXML2_WITH_TESTS)
+	enable_testing()
+	set(
+		TESTS
+		runxmlconf
+		runsuite
+		testapi
+		testAutomata
+		testC14N
+		testchar
+		testdict
+		testHTML
+		testModule
+		testlimits
+		testReader
+		testrecurse
+		testRegexp
+		testRelax
+		testSAX
+		testSchemas
+		testURI
+		testXPath
+	)
+	foreach(TEST ${TESTS})
+		add_executable(${TEST} ${TEST}.c)
+		target_link_libraries(${TEST} LibXml2)
+	endforeach()
+	if(EXISTS ${LIBXML2_XMLCONF_WORKING_DIR}/xmlconf/xmlconf.xml)
+		add_test(NAME runxmlconf COMMAND runxmlconf WORKING_DIRECTORY ${LIBXML2_XMLCONF_WORKING_DIR})
+	endif()
+	if(NOT WIN32)
+		add_test(NAME testapi COMMAND testapi)
+	endif()
+	add_test(NAME testchar COMMAND testchar)
+	add_test(NAME testdict COMMAND testdict)
+	add_test(NAME testrecurse COMMAND testrecurse WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})
+	if(Threads_FOUND)
+		set(
+			TESTS_THREADS
+			runtest
+			testThreads
+		)
+		foreach(TEST ${TESTS_THREADS})
+			add_executable(${TEST} ${TEST}.c)
+			if(WIN32)
+				target_compile_definitions(${TEST} PRIVATE HAVE_WIN32_THREADS)
+			endif()
+			target_link_libraries(${TEST} LibXml2 Threads::Threads)
+		endforeach()
+		add_test(NAME runtest COMMAND runtest --out ${CMAKE_CURRENT_BINARY_DIR} WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})
+		add_test(NAME testThreads COMMAND testThreads WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})
+	endif()
+endif()
+
+if(LIBXML2_WITH_PYTHON)
+	execute_process(
+		COMMAND
+		${Python_EXECUTABLE}
+		${CMAKE_CURRENT_SOURCE_DIR}/python/generator.py
+		${CMAKE_CURRENT_SOURCE_DIR}/doc/libxml2-api.xml
+		${CMAKE_CURRENT_SOURCE_DIR}/python/libxml2-python-api.xml
+		WORKING_DIRECTORY
+		${CMAKE_CURRENT_BINARY_DIR}
+	)
+	file(READ python/libxml.py LIBXML_PY)
+	file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/libxml2.py.in "${LIBXML_PY}")
+	file(READ ${CMAKE_CURRENT_BINARY_DIR}/libxml2class.py LIBXML2CLASS_PY)
+	file(APPEND ${CMAKE_CURRENT_BINARY_DIR}/libxml2.py.in "${LIBXML2CLASS_PY}")
+	configure_file(${CMAKE_CURRENT_BINARY_DIR}/libxml2.py.in libxml2.py COPYONLY)
+	add_library(
+		LibXml2Mod
+		libxml2-py.c
+		libxml2-py.h
+		python/libxml.c
+		python/libxml_wrap.h
+		python/types.c
+	)
+	target_include_directories(
+		LibXml2Mod
+		PUBLIC
+		$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/python>
+	)
+	target_link_libraries(LibXml2Mod LibXml2 Python::Python)
+	set_target_properties(
+		LibXml2Mod
+		PROPERTIES
+		IMPORT_PREFIX lib
+		OUTPUT_NAME xml2mod
+		PREFIX lib
+		VERSION ${VERSION}
+	)
+	install(
+		TARGETS	LibXml2Mod
+		ARCHIVE DESTINATION ${LIBXML2_PYTHON_INSTALL_DIR} COMPONENT development
+		LIBRARY DESTINATION ${LIBXML2_PYTHON_INSTALL_DIR} COMPONENT runtime NAMELINK_COMPONENT development
+		RUNTIME DESTINATION ${LIBXML2_PYTHON_INSTALL_DIR} COMPONENT runtime
+	)
+	if(MSVC AND BUILD_SHARED_LIBS)
+		install(FILES $<TARGET_PDB_FILE:LibXml2Mod> DESTINATION ${LIBXML2_PYTHON_INSTALL_DIR} CONFIGURATIONS Debug RelWithDebInfo COMPONENT debug)
+	endif()
+	install(FILES python/drv_libxml2.py DESTINATION ${LIBXML2_PYTHON_INSTALL_DIR} COMPONENT runtime)
+	install(FILES ${CMAKE_CURRENT_BINARY_DIR}/libxml2.py DESTINATION ${LIBXML2_PYTHON_INSTALL_DIR} COMPONENT runtime)
+endif()
+
+install(FILES libxml.3 DESTINATION ${CMAKE_INSTALL_MANDIR}/man3 COMPONENT documentation)
+install(FILES doc/xmlcatalog.1 DESTINATION ${CMAKE_INSTALL_MANDIR}/man1 COMPONENT documentation)
+install(FILES doc/xmllint.1 DESTINATION ${CMAKE_INSTALL_MANDIR}/man1 COMPONENT documentation)
+install(DIRECTORY doc/ DESTINATION ${CMAKE_INSTALL_DATADIR}/doc/libxml2 COMPONENT documentation PATTERN Makefile.* EXCLUDE)
+
+configure_package_config_file(
+	libxml2-config.cmake.cmake.in libxml2-config.cmake
+	INSTALL_DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/libxml2-${VERSION}
+)
+
+install(
+	FILES ${CMAKE_CURRENT_BINARY_DIR}/libxml2-config.cmake
+	DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/libxml2-${VERSION}
+	COMPONENT development
+)
+
+write_basic_package_version_file(
+	${CMAKE_CURRENT_BINARY_DIR}/libxml2-config-version.cmake
+	VERSION ${VERSION}
+	COMPATIBILITY ExactVersion
+)
+
+install(
+	FILES ${CMAKE_CURRENT_BINARY_DIR}/libxml2-config-version.cmake
+	DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/libxml2-${VERSION}
+	COMPONENT development
+)
+
+install(
+	EXPORT LibXml2
+	DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/libxml2-${VERSION}
+	NAMESPACE LibXml2::
+	FILE libxml2-export.cmake
+	COMPONENT development
+)
+
+configure_file(include/libxml/xmlversion.h.in libxml/xmlversion.h)
+install(FILES ${CMAKE_CURRENT_BINARY_DIR}/libxml/xmlversion.h DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/libxml2/libxml COMPONENT development)
+
+if(MSVC)
+	configure_file(include/libxml/xmlwin32version.h.in libxml/xmlwin32version.h)
+	install(FILES ${CMAKE_CURRENT_BINARY_DIR}/libxml/xmlwin32version.h DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/libxml2/libxml COMPONENT development)
+endif()
+
+if(LIBXML2_WITH_PYTHON)
+	set(prefix "${CMAKE_INSTALL_PREFIX}")
+	configure_file(python/setup.py.in setup.py @ONLY)
+endif()
+
+set(CPACK_COMPONENT_DEVELOPMENT_DEPENDS runtime)
+set(CPACK_COMPONENT_PROGRAMS_DEPENDS runtime)
+set(CPACK_DEB_COMPONENT_INSTALL ON)
+set(CPACK_DEBIAN_DEVELOPMENT_PACKAGE_DEPENDS "${PACKAGE_TARNAME}")
+set(CPACK_DEBIAN_DEVELOPMENT_PACKAGE_NAME "${PACKAGE_TARNAME}-dev")
+set(CPACK_DEBIAN_DEVELOPMENT_PACKAGE_SECTION "libdevel")
+set(CPACK_DEBIAN_PACKAGE_HOMEPAGE ${PACKAGE_URL})
+set(CPACK_DEBIAN_PACKAGE_NAME ${PACKAGE_TARNAME})
+set(CPACK_DEBIAN_PACKAGE_SECTION "devel")
+set(CPACK_DEBIAN_PROGRAMS_PACKAGE_DEPENDS "${PACKAGE_TARNAME}")
+set(CPACK_DEBIAN_PROGRAMS_PACKAGE_NAME "${PACKAGE_TARNAME}-utils")
+set(CPACK_DEBIAN_PROGRAMS_PACKAGE_SECTION "utils")
+set(CPACK_DEBIAN_RUNTIME_PACKAGE_NAME ${PACKAGE_TARNAME})
+set(CPACK_DEBIAN_RUNTIME_PACKAGE_RECOMMENDS "${PACKAGE_TARNAME}-utils")
+set(CPACK_DEBIAN_RUNTIME_PACKAGE_SECTION "libs")
+set(CPACK_NSIS_PACKAGE_NAME ${PACKAGE_STRING})
+set(CPACK_NSIS_URL_INFO_ABOUT ${PACKAGE_URL})
+set(CPACK_PACKAGE_CONTACT ${PACKAGE_BUGREPORT})
+set(CPACK_PACKAGE_DISPLAY_NAME ${PACKAGE_STRING})
+set(CPACK_PACKAGE_INSTALL_DIRECTORY "${PACKAGE_TARNAME}-${PACKAGE_VERSION}")
+set(CPACK_PACKAGE_NAME ${PACKAGE_TARNAME})
+set(CPACK_PACKAGE_VERSION ${PACKAGE_VERSION})
+set(CPACK_PACKAGE_VERSION_MAJOR ${LIBXML_MAJOR_VERSION})
+set(CPACK_PACKAGE_VERSION_MINOR ${LIBXML_MINOR_VERSION})
+set(CPACK_PACKAGE_VERSION_PATCH ${LIBXML_MICRO_VERSION})
+set(CPACK_RESOURCE_FILE_LICENSE ${CMAKE_CURRENT_SOURCE_DIR}/Copyright)
+set(CPACK_RPM_COMPONENT_INSTALL ON)
+set(CPACK_RPM_development_PACKAGE_NAME "${PACKAGE_NAME}-devel")
+set(CPACK_RPM_development_PACKAGE_REQUIRES "${PACKAGE_NAME}")
+set(CPACK_RPM_PACKAGE_GROUP "Development/Libraries")
+set(CPACK_RPM_PACKAGE_NAME ${PACKAGE_TARNAME})
+set(CPACK_RPM_PACKAGE_URL ${PACKAGE_URL})
+set(CPACK_RPM_programs_PACKAGE_NAME "${PACKAGE_NAME}-utils")
+set(CPACK_RPM_programs_PACKAGE_REQUIRES "${PACKAGE_NAME}")
+set(CPACK_RPM_runtime_PACKAGE_NAME "${PACKAGE_NAME}")
+set(CPACK_RPM_runtime_PACKAGE_SUGGESTS "${PACKAGE_NAME}-utils")
+
+include(CPack)
diff --git a/ChangeLog b/ChangeLog
index b3f3fc1f..26406706 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -379,7 +379,7 @@ Tue Aug 26 09:42:08 CEST 2008 Daniel Veillard <daniel@veillard.com>
 	* test/schemas/regexp-char-ref_0.xml test/schemas/regexp-char-ref_0.xsd
 	  test/schemas/regexp-char-ref_1.xsd result/schemas/regexp-char-ref_0_0
 	  result/schemas/regexp-char-ref_1_0: Volker Grabsch also provided
-	  regession tests for this
+	  regression tests for this
 
 Tue Aug 26 09:25:39 CEST 2008 Daniel Veillard <daniel@veillard.com>
 
@@ -475,7 +475,7 @@ Thu Jul 31 10:15:53 CEST 2008 Daniel Veillard <daniel@veillard.com>
 	* include/libxml/xmlerror.h parser.c: clean up namespace errors
 	  checking and reporting, errors when a document is labelled
 	  as UTF-16 while it is parsed as UTF-8 and no encoding was given
-	  explicitely.
+	  explicitly.
 	* result/errors/webdav.xml.*: some warnings are no recategorized
 	  as Namespace errors
 
@@ -663,7 +663,7 @@ Thu Apr  3 11:44:57 CEST 2008 Daniel Veillard <daniel@veillard.com>
 
 Thu Apr  3 11:02:02 CEST 2008 Daniel Veillard <daniel@veillard.com>
 
-	* HTMLparser.c: apparently it's okay to forget the semicolumn after
+	* HTMLparser.c: apparently it's okay to forget the semicolon after
 	  entity refs in HTML, fixing char refs parsing accordingly based on
 	  T. Manske patch, this should fix #517653
 
@@ -787,7 +787,7 @@ Wed Mar 12 18:56:22 CET 2008 Daniel Veillard <daniel@veillard.com>
 
 Wed Mar 12 10:22:01 CET 2008 Daniel Veillard <daniel@veillard.com>
 
-	* python/types.c: fix a memory errro when using namespace nodes
+	* python/types.c: fix a memory error when using namespace nodes
 	  returned from XPath queries, should fix #521699
 	* python/tests/Makefile.am python/tests/xpathns.py: add a specific
 	  regression test for it
@@ -917,7 +917,7 @@ Fri Jan 25 20:01:42 CET 2007 Rob Richards <rrichards@ctindustries.net>
 
 Thu Jan 24 15:37:04 CET 2008 Daniel Veillard <daniel@veillard.com>
 
-	* parser.c: fix a memeory leak in internal subset parsing with
+	* parser.c: fix a memory leak in internal subset parsing with
 	  a fix from Ashwin
 	* test/errors/content1.xml result/errors/content1.xml*:
 	  add test to regressions
@@ -1230,7 +1230,7 @@ Thu May 10 01:52:42 CEST 2007 Daniel Veillard <daniel@veillard.com>
 
 	* list.c: applied patch to fix xmlListAppend() from 
 	  Georges-Andr√© SILBER
-	* valid.c: also fix the place wher it was called.
+	* valid.c: also fix the place where it was called.
 
 Wed May  2 18:47:33 CEST 2007 Daniel Veillard <daniel@veillard.com>
 
@@ -1424,7 +1424,7 @@ Thu Jan  4 18:27:49 CET 2007 Daniel Veillard <daniel@veillard.com>
 	  test/relaxng/empty1_0.xml test/relaxng/comps.rng
 	  test/relaxng/empty0.rng test/relaxng/empty0_0.xml
 	  test/relaxng/empty1_1.xml: tests which were apparently 
-	  never commited to CVS
+	  never committed to CVS
 
 Wed Jan  3 16:05:21 PST 2007 Aleksey Sanin <aleksey@aleksey.com>
 
@@ -1531,7 +1531,7 @@ Tue Oct 17 18:12:34 CEST 2006 Daniel Veillard <daniel@veillard.com>
 	* HTMLparser.c: fixing HTML minimized attribute values to be generated
 	  internally if not present, fixes bug #332124
 	* result/HTML/doc2.htm.sax result/HTML/doc3.htm.sax 
-	  result/HTML/wired.html.sax: this affects the SAX event strem for
+	  result/HTML/wired.html.sax: this affects the SAX event stream for
 	  a few test cases
 
 Tue Oct 17 17:56:31 CEST 2006 Daniel Veillard <daniel@veillard.com>
@@ -1627,7 +1627,7 @@ Wed Oct 11 23:11:58 CEST 2006 Daniel Veillard <daniel@veillard.com>
 
 Wed Oct 11 18:40:00 CEST 2006 Daniel Veillard <daniel@veillard.com>
 
-	* valid.c: fixed a weird error where validity context whould not
+	* valid.c: fixed a weird error where validity context would not
 	  show up if warnings were disabled pointed out by Bob Stayton
 	* xmlIO.c doc/generator.py: cleanup and fix to regenerate the docs
 	* doc//* testapi.c: rebuilt the docs
@@ -1740,7 +1740,7 @@ Thu Aug 17 00:48:31 CEST 2006 Rob Richards <rrichards@ctindustries.net>
 Wed Aug 16 01:15:12 CEST 2006 Rob Richards <rrichards@ctindustries.net>
 
 	* HTMLtree.c xmlsave.c: Add linefeeds to error messages allowing 
-	  for consistant handling.
+	  for consistent handling.
 
 Tue Aug 15 15:02:18 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>
 
@@ -1857,7 +1857,7 @@ Mon Jun 26 16:22:50 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>
 	  initialized to zero here; this could lead to the activation
 	  of the axis rewrite code in xmlXPathNodeCollectAndTest() when
 	  @rewriteType is randomly set to the value 1. A test
-	  (hardcoding the intial value to 1) revealed that the
+	  (hardcoding the initial value to 1) revealed that the
 	  resulting incorrect behaviour is similar to the behaviour
 	  as described by Arnold Hendriks on the mailing list; so I
 	  hope that will fix the issue.	  
@@ -1912,7 +1912,7 @@ Fri Jun 16 21:37:44 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>
 	  for my custom handling of ns-references in my DOM wrapper.
 	  Substituted code which created the XML namespace decl on
 	  the doc for a call to xmlTreeEnsureXMLDecl(). Removed
-	  those nastly "warnigns" from the docs of the clone/adopt
+	  those nasty "warnings" from the docs of the clone/adopt
 	  functions; they work fine on my side.
 	  
 Mon Jun 12 13:23:11 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>
@@ -2033,7 +2033,7 @@ Tue May 30 11:21:34 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>
 Mon May 29 18:06:17 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>
 
 	* xpath.c include/libxml/xpath.h: Added an XPath object cache.
-	  It sits on an xmlXPathContext and need to be explicitely
+	  It sits on an xmlXPathContext and need to be explicitly
 	  activated (or deactivated again) with
 	  xmlXPathContextSetObjectCache(). The cache consists of 5
 	  lists for node-set, string, number, boolean and misc XPath
@@ -2052,7 +2052,7 @@ Wed May 24 10:54:25 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>
 
 	* xpath.c: Removed a memcpy if xmlXPathNodeSetMerge(); it
 	  seems we really need to walk the whole list, since those
-	  nastly namespace nodes need to be added with
+	  nasty namespace nodes need to be added with
 	  xmlXPathNodeSetDupNs(); thus a pure memcpy is not possible.
 	  A flag on the node-set indicating if namespace nodes are in
 	  the set would help here; this is the 3rd flag which would
@@ -2063,7 +2063,7 @@ Wed May 24 10:54:25 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>
 	  2) Of what type are the nodes in the set (or of mixed type)?
 	     This would allow for faster merging of node-sets.
 	  3) Are namespace nodes in the set?
-	     This would allow to skipp all the namespace node specific
+	     This would allow to skip all the namespace node specific
 	     special handling. Faster node-set merging if the first
 	     set is empty; just memcpy the set.
 
@@ -2485,7 +2485,7 @@ Mon Jan  9 15:33:16 CET 2006 Daniel Veillard <daniel@veillard.com>
 
 Thu Jan  5 16:25:06 CET 2006 Daniel Veillard <daniel@veillard.com>
 
-	* NEWS configure.in libxml.spec.in testapi.c doc/*: upated the news
+	* NEWS configure.in libxml.spec.in testapi.c doc/*: updated the news
 	  regenerated the docs, preparing for release of 2.6.23
 	* pattern.c xmlschemas.c: fixed some comments
 	
@@ -2520,7 +2520,7 @@ Wed Jan  4 18:07:47 CET 2006 Daniel Veillard <daniel@veillard.com>
 Wed Jan  4 15:00:51 CET 2006 Daniel Veillard <daniel@veillard.com>
 
 	* SAX2.c: fix bug #324432 with <xml:foo/>
-	* test/ns7 resul//ns7*: added to the regression tests
+	* test/ns7 result/ns7*: added to the regression tests
 
 Wed Jan  4 10:53:56 CET 2006 Daniel Veillard <daniel@veillard.com>
 
@@ -2861,7 +2861,7 @@ Fri Oct 21 10:50:14 EDT 2005 Rob Richards <rrichards@ctindustries.net>
 
 Wed Oct 19 16:53:47 BST 2005 Daniel Veillard <daniel@veillard.com>
 
-	* xmlregexp.c: commiting a some fixes and debug done yesterday in
+	* xmlregexp.c: committing a some fixes and debug done yesterday in
 	  the London airport.
 
 Thu Oct 20 12:54:23 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>
@@ -2932,7 +2932,7 @@ Fri Oct 14 16:21:22 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>
 	  Allowed IDCs to resolve also to nodes of complex type with
 	  simple content.
 	  Added check for keyrefs with references to keyrefs.
-	  IDC target-nodes were interferring with IDC node-tables,
+	  IDC target-nodes were interfering with IDC node-tables,
 	  since they used one list of entries only. I separated this
 	  one big list into 3 lists: 1 for IDC node-table entries,
 	  1 for _duplicates_ of IDC node-table entries and 1 for
@@ -3053,7 +3053,7 @@ Mon Sep 12 21:00:53 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>
 	* xmlschemas.c include/libxml/schemasInternals.h
 	  include/libxml/xmlerror.h: Completion of the schema graph.
 	  Centralisation, more robustness of the schema document
-	  aquisition story. Centralised and restructured component fixup.
+	  acquisition story. Centralised and restructured component fixup.
 	  Fixed attribute derivation when 'prohibiting' attribute uses.
 	  Added warnings: when schema documents cannot be localized
 	  during imports; when we get duplicate and pointless attribute
@@ -3385,7 +3385,7 @@ Wed Aug 10 18:21:41 CEST 2005 Daniel Veillard <daniel@veillard.com>
 	  list values.
 	* test/relaxng/307377* result/relaxng/307377* Makefile.am runtest.c:
 	  added examples to the regression tests, problem is that streaming
-	  version gives slightly more informations.
+	  version gives slightly more information.
 
 Wed Aug 10 15:25:53 CEST 2005 Daniel Veillard <daniel@veillard.com>
 
@@ -3398,7 +3398,7 @@ Wed Aug 10 11:59:46 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>
 Tue Aug  9 23:37:22 CEST 2005 Daniel Veillard <daniel@veillard.com>
 
 	* xmlregexp.c: fixed a determinism detection problem exposed by
-	  ##other tests commited by Kasimier, also added a small speedup
+	  ##other tests committed by Kasimier, also added a small speedup
 	  of determinism detection.
 	* test/results/any6_2_0* any8_1_0* any7_1_2* any7_2_2*: added 
 	  the results to the regression tests now
@@ -3424,7 +3424,7 @@ Tue Aug  9 13:07:27 CEST 2005 Daniel Veillard <daniel@veillard.com>
 	* result/schemas/any7* test/schemas/any7: completed the tests
 	  and added the results
 	* result/schemas/any3_0_0.err result/schemas/any5_0_0.err
-	  result/schemas/any5_1_0.err: this slightly chnages the output
+	  result/schemas/any5_1_0.err: this slightly changes the output
 	  from 3 existing tests
 
 Mon Aug  8 22:33:08 CEST 2005 Daniel Veillard <daniel@veillard.com>
@@ -3468,7 +3468,7 @@ Mon Aug  8 01:41:53 CEST 2005 Daniel Veillard <daniel@veillard.com>
 
 Sun Aug  7 12:39:35 CEST 2005 Daniel Veillard <daniel@veillard.com>
 
-	* test/relaxng/docbook_0.xml: get rid of the dependancy on a locally
+	* test/relaxng/docbook_0.xml: get rid of the dependency on a locally
 	  installed DTD
 	* uri.c include/libxml/uri.h xmlIO.c nanoftp.c nanohttp.c: try to
 	  cleanup the Path/URI conversion mess, needed fixing in various 
@@ -3522,7 +3522,7 @@ Sat Jul 30 17:26:58 EDT 2005 Daniel Veillard <daniel@veillard.com>
 
 Sat Jul 30 17:08:07 EDT 2005 Daniel Veillard <daniel@veillard.com>
 
-	* schematron.c xmllint.c include/libxml/schematron.h: commiting
+	* schematron.c xmllint.c include/libxml/schematron.h: committing
 	  work done on the plane last week-end
 
 Sat Jul 30 15:16:29 CEST 2005 Daniel Veillard <daniel@veillard.com>
@@ -4029,7 +4029,7 @@ Mon Jun 27 01:01:32 CEST 2005 Daniel Veillard <daniel@veillard.com>
 
 Sun Jun 26 20:08:24 CEST 2005 Daniel Veillard <daniel@veillard.com>
 
-	* include/libxml/valid.h valid.c: avoid name glob in agruments as
+	* include/libxml/valid.h valid.c: avoid name glob in arguments as
 	  it matches the glob() routine.
 	* runtest.c Makefile.am: first steps toward a C regression test
 	  framework.
@@ -4463,7 +4463,7 @@ Fri Apr  1 16:07:59 CEST 2005 Daniel Veillard <daniel@veillard.com>
 
 	* doc/apibuild.py doc/elfgcchack.xsl: revamped the elfgcchack.h 
 	  format to cope with gcc4 change of aliasing allowed scopes, had
-	  to add extra informations to doc/libxml2-api.xml to separate
+	  to add extra information to doc/libxml2-api.xml to separate
 	  the header from the c module source.
 	* *.c: updated all c library files to add a #define bottom_xxx
 	  and reimport elfgcchack.h thereafter, and a bit of cleanups.
@@ -4955,9 +4955,9 @@ Fri Jan 28 18:37:18 CET 2005 Daniel Veillard <daniel@veillard.com>
 
 Fri Jan 28 16:51:47 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>
 
-	* xmlschemas.c: Corrected an ambigious symbol-space for
+	* xmlschemas.c: Corrected an ambiguous symbol-space for
 	  local attribute declarations. IFDEFed more IDC code to
-	  surpress compiler warnings.
+	  suppress compiler warnings.
 
 Fri Jan 28 00:57:04 CET 2005 Daniel Veillard <daniel@veillard.com>
 
@@ -4978,7 +4978,7 @@ Thu Jan 27 13:39:04 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>
 	  Added an initial skeleton for indentity-constraints. This is all
 	  defined out, since not complete, plus it needs support from other
 	  modules.
-	  Added machanism to store element information for the
+	  Added mechanism to store element information for the
 	  ancestor-or-self axis; this is needed for identity-constraints
 	  and should be helpful for a future streamable validation.
 	* include/libxml/xmlerror.h: Added an error code for
@@ -5028,7 +5028,7 @@ Sun Jan 23 21:14:20 CET 2005 Daniel Veillard <daniel@veillard.com>
 
 Sun Jan 23 18:35:00 CET 2005 Daniel Veillard <daniel@veillard.com>
 
-	* parser.c: boosting common commnent parsing code, it was really
+	* parser.c: boosting common comment parsing code, it was really
 	  slow.
 	* test/comment[3-5].xml result//comment[3-5].xml*: added sprecific
 	  regression tests
@@ -5179,7 +5179,7 @@ Sat Jan  8 23:04:10 CET 2005 Daniel Veillard <daniel@veillard.com>
 Fri Jan  7 14:54:51 CET 2005 Daniel Veillard <daniel@veillard.com>
 
 	* TODO: small update
-	* xmlregexp.c: trying to add an API to get useful error informations
+	* xmlregexp.c: trying to add an API to get useful error information
 	  back from a failing regexp context.
 
 Thu Jan  6 17:35:41 HKT 2005 William Brack <wbrack@mmm.com.hk>
@@ -5280,7 +5280,7 @@ Sat Dec 25 18:10:02 HKT 2004 William Brack <wbrack@mmm.com.hk>
 	
 Fri Dec 24 16:31:22 HKT 2004 William Brack <wbrack@mmm.com.hk>
 
-	* python/generator.py: added most required entires to
+	* python/generator.py: added most required entries to
 	  foreign encoding table, plus some additional logic to
 	  assure only the 1st param uses the 't#' format.  Fixes
 	  bug #152286, but may still have some other UTF-16 problems.
@@ -5360,7 +5360,7 @@ Fri Nov 26 13:09:04 CET 2004 Kasimier Buchcik <libxml2-cvs@cazic.net>
 	  of elements for which a declaration existed were still processed
 	  by the wildcard mechanism (reported by philippe ventrillon to the
 	  mailing list).
-	  Changed the import and include machanism to share dictionaries.
+	  Changed the import and include mechanism to share dictionaries.
 
 Fri Nov 26 11:44:36 CET 2004 Daniel Veillard <daniel@veillard.com>
 
@@ -5640,7 +5640,7 @@ Tue Nov  2 15:49:34 CET 2004 Daniel Veillard <daniel@veillard.com>
 	* SAX2.c nanoftp.c parser.c parserInternals.c tree.c xmlIO.c
 	  xmlstring.c: various API hardeing changes as a result of running
 	  the first set of automatic API regression tests.
-	* test/slashdot16.xml: apparently missing from CVS, commited it
+	* test/slashdot16.xml: apparently missing from CVS, committed it
 
 Mon Nov  1 15:54:18 CET 2004 Daniel Veillard <daniel@veillard.com>
 
@@ -5867,7 +5867,7 @@ Wed Sep 29 15:00:11 CEST 2004 Kasimier Buchcik <libxml2-cvs@cazic.net>
 	  model group "all".
 	* test/schemas/bug152470_1.xsd: Removed an "abstract" attribute,
 	  which broke the test.
-	* xstc/xstc.py:  Workaround to accomodate case insensitive
+	* xstc/xstc.py:  Workaround to accommodate case insensitive
 	  test definitions in ms-test.def.xml (was missing in a previous
 	  commit).
 
@@ -5961,7 +5961,7 @@ Thu Sep 16 13:24:27 CEST 2004 Kasimier Buchcik <libxml2-cvs@cazic.net>
 
 	* xmlschemas.c include/libxml/schemasInternals.h 
 	  test/schemas/bug152470_1.* result/schemas/bug152470_1_1*: 
-	  Simpified attribute wildcard creation and assignment to get rid 
+	  Simplified attribute wildcard creation and assignment to get rid 
 	  of memory leaks.
 	  Restructured the validation process.
 	  Restructured and expanded parsing of <attributeGroup>.
@@ -5978,7 +5978,7 @@ Thu Sep 16 13:24:27 CEST 2004 Kasimier Buchcik <libxml2-cvs@cazic.net>
 	  'anyType' using the short-hand form (see bug # 152470,
 	  submitted by Thilo Jeremias).
 	* include/libxml/xmlschematypes.h: Cleaned up some comments.
-	* xstc/xstc.py: Workaround to accomodate case insensitive
+	* xstc/xstc.py: Workaround to accommodate case insensitive
 	  test definitions in ms-test.def.xml.
 	* result/schemas/deter0_0_0.err result/schemas/ns0_0_2.err
 	  result/schemas/ns0_1_2.err: Adapted.
@@ -6321,7 +6321,7 @@ Sat Aug 14 13:18:57 CEST 2004 Daniel Veillard <daniel@veillard.com>
 	  to document xmlSchemasSetValidErrors() limitations, #141827
 	* error.c: Add information in generic and structured error
 	  setter functions that this need to be done per thread #144308
-	* xmlsave.c: fixed bug whith missing NOTATION(s) serialization
+	* xmlsave.c: fixed bug with missing NOTATION(s) serialization
 	  bug #144162
 	* doc/xmllint.xml: typo fix #144840
 
@@ -6691,7 +6691,7 @@ Tue Jun  8 21:27:03 HKT 2004 William Brack <wbrack@mmm.com.hk>
 Tue Jun  8 14:01:14 CEST 2004 Daniel Veillard <daniel@veillard.com>
 
 	* parser.c xmlreader.c include/libxml/parser.h: fixed a serious
-	  problem when substituing entities using the Reader, the entities
+	  problem when substituting entities using the Reader, the entities
 	  content might be freed and if rereferenced would crash
 	* Makefile.am test/* result/*: added a new test case and a new
 	  test operation for the reader with substitution of entities.
@@ -6847,7 +6847,7 @@ Sun May 16 03:06:31 CEST 2004 Daniel Veillard <daniel@veillard.com>
 Sat May 15 20:14:21 CEST 2004 Daniel Veillard <daniel@veillard.com>
 
 	* doc/ChangeLog.awk doc/ChangeLog.xsl: first steps of a good
-	  ChangeLog page generation. The awk shoudl escape characters
+	  ChangeLog page generation. The awk should escape characters
 	  not okay in XML and the xslt should make links to functions
 	  or variables or bug reported in the entries.
 
@@ -7049,7 +7049,7 @@ Sun Apr 18 23:45:46 CEST 2004 Daniel Veillard <daniel@veillard.com>
 
 Sun Apr 18 22:51:43 CEST 2004 Daniel Veillard <daniel@veillard.com>
 
-	* xpath.c: relaxed id() to not check taht the name(s) passed
+	* xpath.c: relaxed id() to not check that the name(s) passed
 	  are actually NCName, decided this in agreement with Aleksey Sanin
 	  since existing specs like Visa3D broke that conformance checking
 	  and other tools seems to not implement it sigh...
@@ -7062,7 +7062,7 @@ Sun Apr 18 21:46:17 CEST 2004 Daniel Veillard <daniel@veillard.com>
 	* xpath.c: work around Microsoft compiler NaN bug raise reported
 	  by Mark Vakoc
 	* xmlschemas.c include/libxml/schemasInternals.h 
-	  include/libxml/xmlerror.h: fixed a recusive extention schemas
+	  include/libxml/xmlerror.h: fixed a recursive extension schemas
 	  compilation error raised by taihei goi
 
 Sun Apr 18 16:57:02 CEST 2004 Daniel Veillard <daniel@veillard.com>
@@ -7228,7 +7228,7 @@ Tue Mar 23 12:35:08 CET 2004 Daniel Veillard <daniel@veillard.com>
 
 	* configure.in doc/* News: preparing 2.6.8 release, updated and rebuilt
 	  the docs.
-	* Makefile.am: use valgring fro the new Python based regression tests
+	* Makefile.am: use valgring for the new Python based regression tests
 
 Mon Mar 22 20:07:27 CET 2004 Daniel Veillard <daniel@veillard.com>
 
@@ -7292,7 +7292,7 @@ Wed Mar 10 17:22:48 CET 2004 Daniel Veillard <daniel@veillard.com>
 
 Wed Mar 10 19:42:22 HKT 2004 William Brack <wbrack@mmm.com.hk>
 
-	* doc/search.php: Minor change for later verson of php requiring
+	* doc/search.php: Minor change for later version of php requiring
 	  $HTTP_GET_VARS.
 
 Wed Mar 10 00:12:31 HKT 2004 William Brack <wbrack@mmm.com.hk>
@@ -7361,8 +7361,8 @@ Thu Mar  4 15:00:45 CET 2004 Daniel Veillard <daniel@veillard.com>
 
 Thu Mar  4 14:39:38 CET 2004 Daniel Veillard <daniel@veillard.com>
 
-	* Makefile.am tree.c xmlsave.c include/libxml/xmlsave.h: commiting
-	  the new xmlsave module before the actuall big code change.
+	* Makefile.am tree.c xmlsave.c include/libxml/xmlsave.h: committing
+	  the new xmlsave module before the actual big code change.
 
 Thu Mar  4 12:38:53 CET 2004 Daniel Veillard <daniel@veillard.com>
 
@@ -7872,7 +7872,7 @@ Mon Jan  5 20:47:07 MST 2004 John Fleck <jfleck@inkstain.net>
 
 Tue Jan  6 00:10:33 CET 2004 Daniel Veillard <daniel@veillard.com>
 
-	* rngparser.c: commiting the compact relax ng parser. It's not
+	* rngparser.c: committing the compact relax ng parser. It's not
 	  completely finished, it's not integrated but I want to save the
 	  current state
 
@@ -8026,7 +8026,7 @@ Wed Dec 24 00:29:30 CET 2003 Daniel Veillard <daniel@veillard.com>
 Tue Dec 23 15:14:37 HKT 2003 William Brack <wbrack@mmm.com.hk>
 
 	* valid.c: fixed bug concerning validation using external
-	  dtd of element with mutiple namespace declarations
+	  dtd of element with multiple namespace declarations
 	  (Bug 129821)
 
 Tue Dec 23 11:41:42 HKT 2003 William Brack <wbrack@mmm.com.hk>
@@ -8407,7 +8407,7 @@ Thu Nov 20 12:54:30 CET 2003 Daniel Veillard <daniel@veillard.com>
 	* doc/examples/*: added his test as the xmlWriter example
 	* doc/html/ doc/*.html: this resulted in some improvements
 	* include/libxml/hash.h: fixed an inclusion problem when
-	  <libxml/hash.h> wasn't preceeded by <xml/parser.h>
+	  <libxml/hash.h> wasn't preceded by <xml/parser.h>
 
 Wed Nov 19 17:19:35 CET 2003 Daniel Veillard <daniel@veillard.com>
 
@@ -8430,7 +8430,7 @@ Wed Nov 19 00:48:56 CET 2003 Daniel Veillard <daniel@veillard.com>
 Tue Nov 18 21:51:15 CET 2003 Daniel Veillard <daniel@veillard.com>
 
 	* include/libxml/*.h include/libxml/*.h.in: modified the file
-	  header to add more informations, painful...
+	  header to add more information, painful...
 	* genChRanges.py genUnicode.py: updated to generate said changes
 	  in headers
 	* doc/apibuild.py: extract headers, add them to libxml2-api.xml
@@ -8572,7 +8572,7 @@ Wed Nov 12 01:38:16 CET 2003 Daniel Veillard <daniel@veillard.com>
 	  added autogeneration of a web page for the examples
 	* doc/examples/example1.c doc/examples/.cvsignore
 	  doc/examples/examples.xml doc/examples/index.py: updated the
-	  informations extracted, improved the format and indexing.
+	  information extracted, improved the format and indexing.
 
 Tue Nov 11 22:08:59 CET 2003 Daniel Veillard <daniel@veillard.com>
 
@@ -8774,7 +8774,7 @@ Tue Oct 28 16:42:16 CET 2003 Daniel Veillard <daniel@veillard.com>
 	* error.c valid.c include/libxml/xmlerror.h: fixing bug #125653
 	  sometimes the error handlers can get a parser context on DTD
 	  errors, and sometime they don't. So be very careful when trying
-	  to grab those informations.
+	  to grab those information.
 
 Tue Oct 28 15:26:18 CET 2003 Daniel Veillard <daniel@veillard.com>
 
@@ -8884,7 +8884,7 @@ Mon Oct 20 19:02:53 CEST 2003 Daniel Veillard <daniel@veillard.com>
 	* python/tests/Makefile.am python/tests/reader7.py
 	  python/tests/walker.py: adding regression testing for the
 	  new xmlreader APIs, new APIs for reader creation, including
-	  makeing reader "walker" operating on preparsed document trees.
+	  making reader "walker" operating on preparsed document trees.
 
 Sun Oct 20 22:37:03 HKT 2003 William Brack <wbrack@mmm.com.hk>
 
@@ -9084,7 +9084,7 @@ Fri Oct 10 16:45:20 CEST 2003 Daniel Veillard <daniel@veillard.com>
 Fri Oct 10 16:19:17 CEST 2003 Daniel Veillard <daniel@veillard.com>
 
 	* include/libxml/tree.h: make room in Doc, Element, Attributes
-	  for PSVI type informations.
+	  for PSVI type information.
 
 Fri Oct 10 16:08:02 CEST 2003 Daniel Veillard <daniel@veillard.com>
 
@@ -9251,7 +9251,7 @@ Fri Oct  3 00:19:02 CEST 2003 Daniel Veillard <daniel@veillard.com>
 	  scrolling to see where thing broke wasn't pleasant
 	* configure.in: some beta4 preparation, but not ready yet
 	* error.c globals.c include/libxml/globals.h include/libxml/xmlerror.h:
-	  new error handling code, last error informations are stored
+	  new error handling code, last error information are stored
 	  in the parsing context or a global variable, new APIs to
 	  handle the xmlErrorPtr type.
 	* parser.c parserInternals.c valid.c : started migrating to the
@@ -9261,7 +9261,7 @@ Fri Oct  3 00:19:02 CEST 2003 Daniel Veillard <daniel@veillard.com>
 	* parser.c: small potential buffer access problem in push code
 	  provided by Justin Fletcher
 	* result/*.sax result/VC/PENesting* result/namespaces/*
-	  result/valid/*.err: some error messages were sligthly changed.
+	  result/valid/*.err: some error messages were slightly changed.
 
 Thu Oct  2 13:01:13 2003  Aleksey Sanin  <aleksey@aleksey.com>
 
@@ -9369,7 +9369,7 @@ Sun Sep 28 02:15:07 CEST 2003 Daniel Veillard <daniel@veillard.com>
 	* include/libxml/SAX.h include/libxml/parser.h: move the 
 	  SAXv1 block definitions to parser.h fixes bug #123380
 	* xmlreader.c include/libxml/xmlreader.h: reinstanciate
-	  the attribute and element pool borken 2 commits ago.
+	  the attribute and element pool broken 2 commits ago.
 	  Start playing with an entry point to preserve a subtree.
 	* entities.c: remove a warning.
 
@@ -9436,7 +9436,7 @@ Thu Sep 25 16:23:58 CEST 2003 Daniel Veillard <daniel@veillard.com>
 	  include/libxml/globals.h include/libxml/SAX.h: make sure the
 	  global variables for the default SAX handler are V1 ones to
 	  avoid ABI compat problems.
-	* xmlreader.c: cleanup of uneeded code
+	* xmlreader.c: cleanup of unneeded code
 	* hash.c: fix a comment
 
 Thu Sep 25 14:16:51 CEST 2003 Daniel Veillard <daniel@veillard.com>
@@ -9734,7 +9734,7 @@ Sun Sep  7 11:11:45 CEST 2003 Daniel Veillard <daniel@veillard.com>
 	* dict.c: allow to give -1 for undefined length in lookups
 	* include/libxml/parser.h parser.c parserInternals.c testSAX.c:
 	  first round of work on the new SAX2 interfaces, the API
-	  will change but commiting before changing for historical
+	  will change but committing before changing for historical
 	  reference.
 
 Sat Sep  6 10:55:01 PTD 2003 William Brack <wbrack@mmm.com.hk>
@@ -10091,7 +10091,7 @@ Thu Aug  7 21:13:22 HKT 2003 William Brack <wbrack@mmm.com.hk>
 Wed Aug  6 12:32:11 HKT 2003 William Brack <wbrack@mmm.com.hk>
 
 	* error.c trionan.[ch] testThreads.c python/generator.py:
-	  further small changes to elminate most of the remaining
+	  further small changes to eliminate most of the remaining
 	  warnings.
 
 Tue Aug  5 23:51:21 HKT 2003 William Brack <wbrack@mmm.com.hk>
@@ -10130,7 +10130,7 @@ Sun Aug  3 21:02:30 EDT 2003 Daniel Veillard <daniel@veillard.com>
 	* valid.c: fixed another problem with namespaces on element
 	  in mixed content case
 	* python/tests/reader2.py: updated the testcase with 
-	  Bjorn Reese fix to reader for unsignificant white space
+	  Bjorn Reese fix to reader for insignificant white space
 	* parser.c HTMLparser.c: cleanup.
 
 Sun Aug  3 20:55:40 EDT 2003 Daniel Veillard <daniel@veillard.com>
@@ -10151,7 +10151,7 @@ Sun Aug  3 18:56:54 EDT 2003 Daniel Veillard <daniel@veillard.com>
 Fri Aug 1 23:55:23 HKT 2003 William Brack <wbrack@mmm.com.hk>
 
 	Coninuing work on bug 118559
-	* DOCBparser.c: removed 2 unsed vars
+	* DOCBparser.c: removed 2 unused vars
 	* xmlregexp.c: changed some numeric const to their enum symbols
 	* xmlreader.c: changed one var define from int to enum
 	  (a little more to be done, awaiting co-ordination)
@@ -10318,7 +10318,7 @@ Thu Jul 10 16:02:47 CEST 2003 Daniel Veillard <daniel@veillard.com>
 
 Tue Jul  8 16:02:19 CEST 2003 Daniel Veillard <daniel@veillard.com>
 
-	* globals.c threads.c: fixes some problem when freeing unititialized
+	* globals.c threads.c: fixes some problem when freeing uninitialized
 	  mutexes
 
 Tue Jul  8 14:15:07 CEST 2003 Daniel Veillard <daniel@veillard.com>
@@ -10373,7 +10373,7 @@ Sat Jul  5 22:30:25 CEST 2003 Daniel Veillard <daniel@veillard.com>
 Sat Jul 5 00:51:30 HKT 2003 William Brack <wbrack@mmm.com.hk>
 
 	Fixed problem with multi-threading, shown by the test program
-	testThreads.  After fix, ran mutiple tests on various speed
+	testThreads.  After fix, ran multiple tests on various speed
 	machines (single and dual processor X86), which all seem okay.
 
 	* catalog.c: added missing xmlRMutexUnlock in xmlLoadCatalog
@@ -10451,7 +10451,7 @@ Thu Jun  5 11:31:02 CEST 2003 Daniel Veillard <daniel@veillard.com>
 
 Mon Jun  2 21:56:15 MVT 2003 Daniel Veillard <daniel@veillard.com>
 
-	* relaxng.c xmlschemas.c include/libxml/schemasInternals.h: commiting
+	* relaxng.c xmlschemas.c include/libxml/schemasInternals.h: committing
 	  some work done while in the Maldives (hence the timezone on the
 	  laptop !)
 	* result/schemas/length3* test/schemas/deter0_*
@@ -11398,7 +11398,7 @@ Wed Feb 19 14:26:51 CET 2003 Daniel Veillard <daniel@veillard.com>
 
 Wed Feb 19 01:17:48 CET 2003 Daniel Veillard <daniel@veillard.com>
 
-	* relaxng.c: guess what ! Relax-NG bugfixing, what a surprize...
+	* relaxng.c: guess what ! Relax-NG bugfixing, what a surprise...
 
 Tue Feb 18 22:09:50 CET 2003 Daniel Veillard <daniel@veillard.com>
 
@@ -11929,10 +11929,10 @@ Mon Jan  6 14:06:07 CET 2003 Daniel Veillard <daniel@veillard.com>
 
 	* configure.in NEWS: preparing 2.5.0 release
 	* SAX.c: only warn in pedantic mode about namespace name 
-	  brokeness
+	  brokenness
 	* globals.c: fix a doc generation problem
 	* uri.c: fix #101520
-	* doc/*: updated and rebuilt the doc for the release, includuding
+	* doc/*: updated and rebuilt the doc for the release, including
 	  stylesheet update
 	* python/Makefile.am: fix a filename bug
 
@@ -12092,7 +12092,7 @@ Sun Dec 29 12:13:18 CET 2002 Daniel Veillard <daniel@veillard.com>
 Sat Dec 28 23:49:12 CET 2002 Daniel Veillard <daniel@veillard.com>
 
 	* xmlreader.c include/libxml/xmlreader.h doc/libxml2-api.xml:
-	  extended the XmlTextReader API a bit, addding accessors for
+	  extended the XmlTextReader API a bit, adding accessors for
 	  the current doc and node, and an entity substitution mode for
 	  the parser.
 	* python/libxml.py python/libxml2class.txt: related updates
@@ -12479,7 +12479,7 @@ Sun Nov 17 10:25:43 CET 2002 Daniel Veillard <daniel@veillard.com>
 
 Sat Nov 16 16:30:25 CET 2002 Daniel Veillard <daniel@veillard.com>
 
-	* parser.c xpath.c: fixing #96925 wich was also dependent on the
+	* parser.c xpath.c: fixing #96925 which was also dependent on the
 	  processing of parsed entities, and XPath computation on sustitued
 	  entities.
 	* testXPath.c: make sure entities are substituted.
@@ -12715,7 +12715,7 @@ Wed Oct 16 16:05:38 CEST 2002 Daniel Veillard <daniel@veillard.com>
 
 Tue Oct 15 12:41:01 CEST 2002 Daniel Veillard <daniel@veillard.com>
 
-	* README: updated the contact informations
+	* README: updated the contact information
 
 Tue Oct 15 10:35:57 CEST 2002 Daniel Veillard <daniel@veillard.com>
 
@@ -13009,7 +13009,7 @@ Thu Sep  5 13:10:57 CEST 2002 Daniel Veillard <daniel@veillard.com>
 
 Thu Sep  5 12:57:38 CEST 2002 Daniel Veillard <daniel@veillard.com>
 
-	* valid.c: try to provide file and line informations, not all
+	* valid.c: try to provide file and line information, not all
 	  messages are covered, but it's a (good) start
 
 Thu Sep  5 12:49:35 CEST 2002 Daniel Veillard <daniel@veillard.com>
@@ -13060,7 +13060,7 @@ Wed Aug 28 13:44:54 CEST 2002 Daniel Veillard <daniel@veillard.com>
 
 Sun Aug 25 16:38:05 CEST 2002 Daniel Veillard <daniel@veillard.com>
 
-	* xmlIO.c: handle Windows sepecific file://localhost/ semantic ...
+	* xmlIO.c: handle Windows specific file://localhost/ semantic ...
 
 Thu Aug 22 22:03:19 CEST 2002 Daniel Veillard <daniel@veillard.com>
 
@@ -13394,7 +13394,7 @@ Mon Jun 03 00:04:21 2002 Chema Celorio <chema@ximian.com>
 
 	* tree.h: added xmlDocFormatDump which is just as xmlDocDump
 	  but with the format parameter
-	* tree.c: made xmlDocDump a wrapper arround xmlDocFormatDump
+	* tree.c: made xmlDocDump a wrapper around xmlDocFormatDump
 
 Fri May 31 12:16:48 2002  Aleksey Sanin  <aleksey@aleksey.com>
 
@@ -13499,13 +13499,13 @@ Wed May 15 00:25:34 CEST 2002 Igor Zlatkovic <igor@stud.fh-frankfurt.de>
 
 Tue May 14 13:00:48 CEST 2002 Daniel Veillard <daniel@veillard.com>
 
-	* xpath.c: fixing an XPath function evalutation bug pointed out
+	* xpath.c: fixing an XPath function evaluation bug pointed out
 	  by Alexey Efimov where the context was lost when evaluating
 	  the function arguments
 
 Mon 13 May 2002 11:37:39 PM PDT Aleksey Sanin <aleksey@aleksey.com>
 
-	* xpath.c include/libxml/xpathInternals.h: maked xmlXPathNodeSetAddNs() 
+	* xpath.c include/libxml/xpathInternals.h: made xmlXPathNodeSetAddNs() 
 	  function public for XMLSec performance optimizations
 
 Mon May 13 12:32:22 CEST 2002 Daniel Veillard <daniel@veillard.com>
@@ -13542,7 +13542,7 @@ Wed 01 May 2002 11:29:27 AM PDT Aleksey Sanin <aleksey@aleksey.com>
 	* include/libxml/xmlIO.h win32/dsp/libxml2.def.src
 	win32/libxml2.def.src xmlIO.c: exported default
 	'file:', 'http:' and 'ftp:' protocols input handlers 
-	and maked protocols comparisson case insensitive
+	and made protocols comparison case insensitive
 
 Tue Apr 30 16:29:05 CEST 2002 Daniel Veillard <daniel@veillard.com>
 
@@ -13999,7 +13999,7 @@ Mon Mar 11 10:10:30 CET 2002 Daniel Veillard <daniel@veillard.com>
 Sun Mar 10 17:47:58 CET 2002 Daniel Veillard <daniel@veillard.com>
 
 	* valid.c: applied patch from Dodji Seketeli fixing an
-	  uninitailized variable in xmlValidGetValidElements()
+	  uninitialized variable in xmlValidGetValidElements()
 
 Sat Mar  9 15:10:49 CET 2002 Daniel Veillard <daniel@veillard.com>
 
@@ -14139,12 +14139,12 @@ Fri Mar  1 17:12:15 CET 2002 Daniel Veillard <daniel@veillard.com>
 
 Fri Mar  1 13:56:12 CET 2002 Daniel Veillard <daniel@veillard.com>
 
-	* python/*: commiting some Python bindings work done while travelling
+	* python/*: committing some Python bindings work done while travelling
 
 Fri Mar  1 10:11:15 CET 2002 Daniel Veillard <daniel@veillard.com>
 
 	* xmllint.c: close #72663 and #72658, don't memdump unless compiled
-	  explicitely with memory debugging switched on
+	  explicitly with memory debugging switched on
 
 Sat Feb 23 11:08:09 CET 2002 Daniel Veillard <daniel@veillard.com>
 
@@ -14496,7 +14496,7 @@ Sat Feb  2 11:25:51 CET 2002 Daniel Veillard <daniel@veillard.com>
 Sat Feb  2 10:13:52 CET 2002 Daniel Veillard <daniel@veillard.com>
 
 	* configure.in libxml.spec.in python/Makefile.am python/TODO
-	  python/generator.py python/libxml2class.txt: added more informations
+	  python/generator.py python/libxml2class.txt: added more information
 	  in the libxml2-python package including docs. Slightly changed
 	  the class hierarchy
 	* python/tests/*: added basic regression tests infrastructure too
@@ -14543,7 +14543,7 @@ Wed Jan 30 21:51:26 CET 2002 Daniel Veillard <daniel@veillard.com>
 Wed Jan 30 17:35:33 CET 2002 Daniel Veillard <daniel@veillard.com>
 
 	* python/generator.py python/libxml.c python/libxml.py
-	  python/libxml_wrap.h: commited early version of a python binding
+	  python/libxml_wrap.h: committed early version of a python binding
 	  for private use only ATM
 
 Sat Jan 26 22:41:13 CET 2002 Daniel Veillard <daniel@veillard.com>
@@ -15441,7 +15441,7 @@ Thu Sep 20 15:54:29 CEST 2001 Daniel Veillard <daniel@veillard.com>
 Wed Sep 19 10:01:37 CEST 2001 Daniel Veillard <daniel@veillard.com>
 
 	* Makefile.am libxml.spec.in: backing up non-documented changes
-	  commited without review or aproval by Jens Finke <jens@gnome.org>
+	  committed without review or approval by Jens Finke <jens@gnome.org>
 	* HACKING: made 100% clear that no commit should be done directly
 
 Mon Sep 17 18:52:37 CEST 2001 Daniel Veillard <daniel@veillard.com>
@@ -15586,7 +15586,7 @@ Sat Aug 25 15:30:17 CEST 2001 Daniel Veillard <daniel@veillard.com>
 Thu Aug 23 23:16:32 CEST 2001 Daniel Veillard <daniel@veillard.com>
 
 	* catalog.c xmlIO.c: started some serious testing and fixed
-	  a few bug and optmization needs.
+	  a few bug and optimization needs.
 
 Thu Aug 23 17:26:58 CEST 2001 Daniel Veillard <daniel@veillard.com>
 
@@ -15874,7 +15874,7 @@ Tue Jul 24 15:39:11 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>
 	  this slightly
 	* include/libxml/parser.h SAX.c parser.c parserInternals.c
 	  xmllint.c: make element content line number generation
-	  optionnal to avoid breaking old apps added interface to switch
+	  optional to avoid breaking old apps added interface to switch
 
 Tue Jul 24 15:06:58 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>
 
@@ -16543,7 +16543,7 @@ Sun May 20 15:15:46 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>
 
 Sat May 19 17:11:15 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>
 
-	* doc/xml.html: update with 2.3.9 informations
+	* doc/xml.html: update with 2.3.9 information
 
 Sat May 19 16:50:47 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>
 
@@ -16738,7 +16738,7 @@ Sat Apr 28 18:54:28 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>
 Sat Apr 28 16:33:05 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>
 
 	* xpath.c: simple and efficient optimization, XPath functions
-	  aways bind to the same code, cache this
+	  always bind to the same code, cache this
 	* TODO: updated (by saying some is obsolete)
 
 Sat Apr 28 14:23:30 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>
@@ -16977,7 +16977,7 @@ Thu Apr 12 10:50:34 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>
 Wed Apr 11 16:37:50 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>
 
 	* tree.h: include xmlmemory.h this seems to havoid a nasty glibc
-	  bug where the linktime verions of free() won't work ...
+	  bug where the linktime versions of free() won't work ...
 
 Wed Apr 11 14:21:31 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>
 
@@ -17376,7 +17376,7 @@ Thu Feb 15 15:57:14 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>
 Wed Feb 14 11:35:39 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>
 
 	* hash.[ch]: added Paolo Casarini patch to provide Delete from
-	  hash functionnalities.
+	  hash functionalities.
 	* doc/html/* : rebuild the doc
 
 Tue Feb 13 18:01:48 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>
@@ -17514,7 +17514,7 @@ Thu Jan 25 13:34:11 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>
 
 Wed Jan 24 20:27:28 COT 2001 Alejandro Forero <bachue@bachue.com>
 
-	* xmlIO.c (xmlFileOpen, xmlFileOpenW): Removed unnecesary checks.
+	* xmlIO.c (xmlFileOpen, xmlFileOpenW): Removed unnecessary checks.
 
 	* xmlIO.c (xmlCheckFilename): Function added to know whether a given
 	  filename points to a valid file (not a directory).
@@ -17551,7 +17551,7 @@ Mon Jan 22 10:35:40 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>
 	  of the data format with node set, as well as operators.
 	* HTMLtree.c: added a newline at the end of the doctype output
 	  whe this one is not present initially.
-	* tree.c: make sure taht the parent and doc pointers are properly
+	* tree.c: make sure that the parent and doc pointers are properly
 	  set when copying attributes (lists).
 
 Sun Jan 21 10:47:38 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>
@@ -17613,7 +17613,7 @@ Sat Jan  6 22:05:09 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>
 
 Sat Jan  6 19:13:27 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>
 
-	* Makefile.am: applied patch fro make check from Martin Vidner
+	* Makefile.am: applied patch for make check from Martin Vidner
 
 Thu Jan  4 19:07:49 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>
 
@@ -17667,7 +17667,7 @@ Wed Dec 27 12:35:49 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>
 	  of xmllint too when using --memory flag, added a memory test
 	  suite at the Makefile level.
 	* xpathInternals.h xpath.[ch] xpointer.c: fixed problems
-	  with namespace use when encountering QNames in XPath evalation,
+	  with namespace use when encountering QNames in XPath evaluation,
 	  added xmlns() scheme in XPointer.
 	* nanoftp.c : incorporated a fix
 	* parser.c xmlIO.c: fixed problems raised with encoding when using
@@ -17892,7 +17892,7 @@ Sun Oct 22 13:59:50 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>
 	* valid.c: handling of blank nodes in DTd validation (raised
 	  by problems with a posteriori validation).
 	* nanohttp.c: changing behaviour on HTTP write stuff.
-	* HTMLtree.c: forced body and html to be explicitely closed.
+	* HTMLtree.c: forced body and html to be explicitly closed.
 	* xpath.h: exported more XPath functions.
 
 Sun Oct 15 22:28:32 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>
@@ -18037,7 +18037,7 @@ Fri Oct  6 12:58:04 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>
 
 Thu Oct  5 18:13:15 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>
 
-	* debugXML.c testXPath.c xpath.[ch]: got pissed by some nastyness
+	* debugXML.c testXPath.c xpath.[ch]: got pissed by some nastiness
 	  in the XPath engine, rewrote large parts of it, now it's far
 	  cleaner and in sync with the REC not an old WD. Fixed a parsing
 	  problem in the interactive XML shell found when testing XPath.
@@ -18895,7 +18895,7 @@ Tue Dec 21 14:29:34 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>
 	* result/HTML/*.htm*: Updated the HTML examples regression tests output
 	* SAX.c tree.c: fixed bug on defaulting namespaces on attributes
 	* debugXML.c: fixed a bug on printing default namespaces.
-	* HTMLtree.c: fixed a problem when outputing XML parsed docs as HTML
+	* HTMLtree.c: fixed a problem when outputting XML parsed docs as HTML
 
 Mon Dec 20 16:20:55 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>
 
@@ -18922,7 +18922,7 @@ Sat Dec 18 16:07:03 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>
 Thu Dec 16 16:19:29 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>
 
 	* tree.c: fixed a bug introduced in 1.8.0 and breaking default
-	  namespace recognition, and Dia as a resul :-(
+	  namespace recognition, and Dia as a result :-(
 	* encoding.c: closed bug #3950
 
 Wed Dec 15 19:22:23 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>
@@ -18952,7 +18952,7 @@ Sun Dec 12 13:08:15 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>
 	  buffers instead, this was really needed, validation was breaking
 	  in strange ways due to that. Added xmlParseStringPEReference()
 	  and other parsing from strings functions. Entities processing
-	  modified again, but PERef are still not handled correcly but
+	  modified again, but PERef are still not handled correctly but
 	  unless you're Eve Maller you won't notice :-)
 	* HTMLparser.c: large changes toward reliability, and switched to
 	  lowercase internal tags, XHTML is lowercase, so it will help
@@ -19042,8 +19042,8 @@ Mon Oct 25 12:13:25 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>
 	            a new release out
 	* HTMLparser.c: fixed auto-close bugs on list items, zeroing
 	            some structures, comments before and after the
-		    main element, and other nastyness
-	* HTMLtree.c tree.c: accomodate the extended HTML supported	    
+		    main element, and other nastiness
+	* HTMLtree.c tree.c: accommodate the extended HTML supported	    
 	* configure.in: pushing 1.7.4
 	* test/ent8 and related outputs : added a new test for bug #2784
 	* test/HTML/wired.html and related output: a nasty HTML example
@@ -19450,7 +19450,7 @@ Sun Jan 31 22:06:48 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>
 
 	* valid.[ch], tree.c, parser.c : more work toward full parsing
 	  of XML DTDs.
-	* README: added informations about mailing-list and on-line
+	* README: added information about mailing-list and on-line
 	  documentation
 
 1999-01-27  Raja R Harinath  <harinath@cs.umn.edu>
@@ -19535,7 +19535,7 @@ Thu Oct 29 00:48:45 EST 1998 Daniel Veillard <Daniel.Veillard@w3.org>
 
 Wed Oct 28 17:56:35 EST 1998 Daniel Veillard <Daniel.Veillard@w3.org>
 
-	* tree.[ch]: more cleanup on the API, made the tree mor conformant.
+	* tree.[ch]: more cleanup on the API, made the tree more conformant.
 
 Tue Oct 27 17:54:00 EST 1998 Daniel Veillard <Daniel.Veillard@w3.org>
 
@@ -19594,7 +19594,7 @@ Sat Oct 17 02:43:21 EDT 1998 Daniel Veillard <Daniel.Veillard@w3.org>
 Tue Oct 13 21:46:57 EDT 1998 Daniel Veillard <Daniel.Veillard@w3.org>
 
 	* tree.h, tree.c, parser.c: added prev and doc pointers to Node,
-	  and changed NODEs contants for conformity with DOM Level 1
+	  and changed NODEs constants for conformity with DOM Level 1
 
 Wed Oct  7 23:42:46 EDT 1998 Daniel Veillard <Daniel.Veillard@w3.org>
 
@@ -19631,7 +19631,7 @@ Mon Sep 21 20:11:13 EDT 1998 Daniel Veillard <Daniel.Veillard@w3.org>
 
 1998-08-20  Raja R Harinath  <harinath@cs.umn.edu>
 
-	* error.h: New file.  Contains prototyes from `error.c'.
+	* error.h: New file.  Contains prototypes from `error.c'.
 
 Thu Aug 13 19:02:34 1998  Tom Tromey  <tromey@cygnus.com>
 
@@ -19662,13 +19662,13 @@ Sun Jul 26 17:29:52 EDT 1998  Daniel Veillard <Daniel.Veillard@w3.org>
 Sun Jul 26 00:17:51 EDT 1998  Daniel Veillard <Daniel.Veillard@w3.org>
 
 	* configure.in: added test for CPP
-	* AUTHORS, Changelog: the original ones didn't get commited but the
+	* AUTHORS, Changelog: the original ones didn't get committed but the
 	    glib ones instead, fixed.
 	* Makefile.am: corrected an error in library naming
 
 Fri Jul 24 16:47:14 1998  Daniel Veillard <Daniel.Veillard@w3.org>
 
-	* integrated code developped at W3C
+	* integrated code developed at W3C
 	* changed the original Copyright
 	* migrated to automake
 	* prefixed the filenames by xml_ to avoid filename clashes
diff --git a/HTMLparser.c b/HTMLparser.c
index 7b6d6896..26a1cdc2 100644
--- a/HTMLparser.c
+++ b/HTMLparser.c
@@ -69,7 +69,7 @@ static void htmlParseComment(htmlParserCtxtPtr ctxt);
 /**
  * htmlErrMemory:
  * @ctxt:  an HTML parser context
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle a redefinition of attribute error
  */
@@ -296,7 +296,7 @@ htmlNodeInfoPop(htmlParserCtxtPtr ctxt)
 
 #define UPPER (toupper(*ctxt->input->cur))
 
-#define SKIP(val) ctxt->nbChars += (val),ctxt->input->cur += (val),ctxt->input->col+=(val)
+#define SKIP(val) ctxt->input->cur += (val),ctxt->input->col+=(val)
 
 #define NXT(val) ctxt->input->cur[(val)]
 
@@ -330,7 +330,7 @@ htmlNodeInfoPop(htmlParserCtxtPtr ctxt)
     if (*(ctxt->input->cur) == '\n') {					\
 	ctxt->input->line++; ctxt->input->col = 1;			\
     } else ctxt->input->col++;						\
-    ctxt->token = 0; ctxt->input->cur += l; ctxt->nbChars++;		\
+    ctxt->token = 0; ctxt->input->cur += l;				\
   } while (0)
 
 /************
@@ -414,6 +414,10 @@ htmlFindEncoding(xmlParserCtxtPtr ctxt) {
 
 static int
 htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {
+    const unsigned char *cur;
+    unsigned char c;
+    unsigned int val;
+
     if (ctxt->instate == XML_PARSER_EOF)
 	return(0);
 
@@ -421,99 +425,29 @@ htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {
 	*len = 0;
 	return(ctxt->token);
     }
-    if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {
-	/*
-	 * We are supposed to handle UTF8, check it's valid
-	 * From rfc2044: encoding of the Unicode values on UTF-8:
-	 *
-	 * UCS-4 range (hex.)           UTF-8 octet sequence (binary)
-	 * 0000 0000-0000 007F   0xxxxxxx
-	 * 0000 0080-0000 07FF   110xxxxx 10xxxxxx
-	 * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx
-	 *
-	 * Check for the 0x110000 limit too
-	 */
-	const unsigned char *cur = ctxt->input->cur;
-	unsigned char c;
-	unsigned int val;
-
-	c = *cur;
-	if (c & 0x80) {
-	    if (cur[1] == 0) {
-		xmlParserInputGrow(ctxt->input, INPUT_CHUNK);
-                cur = ctxt->input->cur;
-            }
-	    if ((cur[1] & 0xc0) != 0x80)
-		goto encoding_error;
-	    if ((c & 0xe0) == 0xe0) {
+    if (ctxt->charset != XML_CHAR_ENCODING_UTF8) {
+        xmlChar * guess;
+        xmlCharEncodingHandlerPtr handler;
 
-		if (cur[2] == 0) {
-		    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);
-                    cur = ctxt->input->cur;
-                }
-		if ((cur[2] & 0xc0) != 0x80)
-		    goto encoding_error;
-		if ((c & 0xf0) == 0xf0) {
-		    if (cur[3] == 0) {
-			xmlParserInputGrow(ctxt->input, INPUT_CHUNK);
-                        cur = ctxt->input->cur;
-                    }
-		    if (((c & 0xf8) != 0xf0) ||
-			((cur[3] & 0xc0) != 0x80))
-			goto encoding_error;
-		    /* 4-byte code */
-		    *len = 4;
-		    val = (cur[0] & 0x7) << 18;
-		    val |= (cur[1] & 0x3f) << 12;
-		    val |= (cur[2] & 0x3f) << 6;
-		    val |= cur[3] & 0x3f;
-		} else {
-		  /* 3-byte code */
-		    *len = 3;
-		    val = (cur[0] & 0xf) << 12;
-		    val |= (cur[1] & 0x3f) << 6;
-		    val |= cur[2] & 0x3f;
-		}
-	    } else {
-	      /* 2-byte code */
-		*len = 2;
-		val = (cur[0] & 0x1f) << 6;
-		val |= cur[1] & 0x3f;
-	    }
-	    if (!IS_CHAR(val)) {
-	        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
-				"Char 0x%X out of allowed range\n", val);
-	    }
-	    return(val);
-	} else {
+        /*
+         * Assume it's a fixed length encoding (1) with
+         * a compatible encoding for the ASCII set, since
+         * HTML constructs only use < 128 chars
+         */
+        if ((int) *ctxt->input->cur < 0x80) {
+            *len = 1;
             if ((*ctxt->input->cur == 0) &&
                 (ctxt->input->cur < ctxt->input->end)) {
-                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
-				"Char 0x%X out of allowed range\n", 0);
-                *len = 1;
+                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
+                                "Char 0x%X out of allowed range\n", 0);
                 return(' ');
             }
-	    /* 1-byte code */
-	    *len = 1;
-	    return((int) *ctxt->input->cur);
-	}
-    }
-    /*
-     * Assume it's a fixed length encoding (1) with
-     * a compatible encoding for the ASCII set, since
-     * XML constructs only use < 128 chars
-     */
-    *len = 1;
-    if ((int) *ctxt->input->cur < 0x80)
-	return((int) *ctxt->input->cur);
-
-    /*
-     * Humm this is bad, do an automatic flow conversion
-     */
-    {
-        xmlChar * guess;
-        xmlCharEncodingHandlerPtr handler;
+            return((int) *ctxt->input->cur);
+        }
 
+        /*
+         * Humm this is bad, do an automatic flow conversion
+         */
         guess = htmlFindEncoding(ctxt);
         if (guess == NULL) {
             xmlSwitchEncoding(ctxt, XML_CHAR_ENCODING_8859_1);
@@ -532,7 +466,86 @@ htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {
         ctxt->charset = XML_CHAR_ENCODING_UTF8;
     }
 
-    return(xmlCurrentChar(ctxt, len));
+    /*
+     * We are supposed to handle UTF8, check it's valid
+     * From rfc2044: encoding of the Unicode values on UTF-8:
+     *
+     * UCS-4 range (hex.)           UTF-8 octet sequence (binary)
+     * 0000 0000-0000 007F   0xxxxxxx
+     * 0000 0080-0000 07FF   110xxxxx 10xxxxxx
+     * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx
+     *
+     * Check for the 0x110000 limit too
+     */
+    cur = ctxt->input->cur;
+    c = *cur;
+    if (c & 0x80) {
+        if ((c & 0x40) == 0)
+            goto encoding_error;
+        if (cur[1] == 0) {
+            xmlParserInputGrow(ctxt->input, INPUT_CHUNK);
+            cur = ctxt->input->cur;
+        }
+        if ((cur[1] & 0xc0) != 0x80)
+            goto encoding_error;
+        if ((c & 0xe0) == 0xe0) {
+
+            if (cur[2] == 0) {
+                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);
+                cur = ctxt->input->cur;
+            }
+            if ((cur[2] & 0xc0) != 0x80)
+                goto encoding_error;
+            if ((c & 0xf0) == 0xf0) {
+                if (cur[3] == 0) {
+                    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);
+                    cur = ctxt->input->cur;
+                }
+                if (((c & 0xf8) != 0xf0) ||
+                    ((cur[3] & 0xc0) != 0x80))
+                    goto encoding_error;
+                /* 4-byte code */
+                *len = 4;
+                val = (cur[0] & 0x7) << 18;
+                val |= (cur[1] & 0x3f) << 12;
+                val |= (cur[2] & 0x3f) << 6;
+                val |= cur[3] & 0x3f;
+                if (val < 0x10000)
+                    goto encoding_error;
+            } else {
+              /* 3-byte code */
+                *len = 3;
+                val = (cur[0] & 0xf) << 12;
+                val |= (cur[1] & 0x3f) << 6;
+                val |= cur[2] & 0x3f;
+                if (val < 0x800)
+                    goto encoding_error;
+            }
+        } else {
+          /* 2-byte code */
+            *len = 2;
+            val = (cur[0] & 0x1f) << 6;
+            val |= cur[1] & 0x3f;
+            if (val < 0x80)
+                goto encoding_error;
+        }
+        if (!IS_CHAR(val)) {
+            htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
+                            "Char 0x%X out of allowed range\n", val);
+        }
+        return(val);
+    } else {
+        if ((*ctxt->input->cur == 0) &&
+            (ctxt->input->cur < ctxt->input->end)) {
+            htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
+                            "Char 0x%X out of allowed range\n", 0);
+            *len = 1;
+            return(' ');
+        }
+        /* 1-byte code */
+        *len = 1;
+        return((int) *ctxt->input->cur);
+    }
 
 encoding_error:
     /*
@@ -584,7 +597,6 @@ htmlSkipBlankChars(xmlParserCtxtPtr ctxt) {
 		ctxt->input->line++; ctxt->input->col = 1;
 	    } else ctxt->input->col++;
 	    ctxt->input->cur++;
-	    ctxt->nbChars++;
 	    if (*ctxt->input->cur == 0)
 		xmlParserInputGrow(ctxt->input, INPUT_CHUNK);
 	}
@@ -2482,7 +2494,6 @@ htmlParseName(htmlParserCtxtPtr ctxt) {
 	    count = in - ctxt->input->cur;
 	    ret = xmlDictLookup(ctxt->dict, ctxt->input->cur, count);
 	    ctxt->input->cur = in;
-	    ctxt->nbChars += count;
 	    ctxt->input->col += count;
 	    return(ret);
 	}
@@ -2789,47 +2800,39 @@ htmlParseAttValue(htmlParserCtxtPtr ctxt) {
 static xmlChar *
 htmlParseSystemLiteral(htmlParserCtxtPtr ctxt) {
     size_t len = 0, startPosition = 0;
+    int err = 0;
+    int quote;
     xmlChar *ret = NULL;
 
-    if (CUR == '"') {
-        NEXT;
+    if ((CUR != '"') && (CUR != '\'')) {
+	htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_STARTED,
+	             "SystemLiteral \" or ' expected\n", NULL, NULL);
+        return(NULL);
+    }
+    quote = CUR;
+    NEXT;
 
-        if (CUR_PTR < BASE_PTR)
-            return(ret);
-        startPosition = CUR_PTR - BASE_PTR;
+    if (CUR_PTR < BASE_PTR)
+        return(ret);
+    startPosition = CUR_PTR - BASE_PTR;
 
-	while ((IS_CHAR_CH(CUR)) && (CUR != '"')) {
-	    NEXT;
-	    len++;
-	}
-	if (!IS_CHAR_CH(CUR)) {
-	    htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED,
-			 "Unfinished SystemLiteral\n", NULL, NULL);
-	} else {
-	    ret = xmlStrndup((BASE_PTR+startPosition), len);
-	    NEXT;
+    while ((CUR != 0) && (CUR != quote)) {
+        /* TODO: Handle UTF-8 */
+        if (!IS_CHAR_CH(CUR)) {
+            htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
+                            "Invalid char in SystemLiteral 0x%X\n", CUR);
+            err = 1;
         }
-    } else if (CUR == '\'') {
         NEXT;
-
-        if (CUR_PTR < BASE_PTR)
-            return(ret);
-        startPosition = CUR_PTR - BASE_PTR;
-
-	while ((IS_CHAR_CH(CUR)) && (CUR != '\'')) {
-	    NEXT;
-	    len++;
-	}
-	if (!IS_CHAR_CH(CUR)) {
-	    htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED,
-			 "Unfinished SystemLiteral\n", NULL, NULL);
-	} else {
-	    ret = xmlStrndup((BASE_PTR+startPosition), len);
-	    NEXT;
-        }
+        len++;
+    }
+    if (CUR != quote) {
+        htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED,
+                     "Unfinished SystemLiteral\n", NULL, NULL);
     } else {
-	htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_STARTED,
-	             " or ' expected\n", NULL, NULL);
+        NEXT;
+        if (err == 0)
+            ret = xmlStrndup((BASE_PTR+startPosition), len);
     }
 
     return(ret);
@@ -2849,51 +2852,42 @@ htmlParseSystemLiteral(htmlParserCtxtPtr ctxt) {
 static xmlChar *
 htmlParsePubidLiteral(htmlParserCtxtPtr ctxt) {
     size_t len = 0, startPosition = 0;
+    int err = 0;
+    int quote;
     xmlChar *ret = NULL;
+
+    if ((CUR != '"') && (CUR != '\'')) {
+	htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_STARTED,
+	             "PubidLiteral \" or ' expected\n", NULL, NULL);
+        return(NULL);
+    }
+    quote = CUR;
+    NEXT;
+
     /*
      * Name ::= (Letter | '_') (NameChar)*
      */
-    if (CUR == '"') {
-        NEXT;
-
-        if (CUR_PTR < BASE_PTR)
-            return(ret);
-        startPosition = CUR_PTR - BASE_PTR;
-
-        while (IS_PUBIDCHAR_CH(CUR)) {
-            len++;
-            NEXT;
+    if (CUR_PTR < BASE_PTR)
+        return(ret);
+    startPosition = CUR_PTR - BASE_PTR;
+
+    while ((CUR != 0) && (CUR != quote)) {
+        if (!IS_PUBIDCHAR_CH(CUR)) {
+            htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
+                            "Invalid char in PubidLiteral 0x%X\n", CUR);
+            err = 1;
         }
-
-	if (CUR != '"') {
-	    htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED,
-	                 "Unfinished PubidLiteral\n", NULL, NULL);
-	} else {
-	    ret = xmlStrndup((BASE_PTR + startPosition), len);
-	    NEXT;
-	}
-    } else if (CUR == '\'') {
+        len++;
         NEXT;
+    }
 
-        if (CUR_PTR < BASE_PTR)
-            return(ret);
-        startPosition = CUR_PTR - BASE_PTR;
-
-        while ((IS_PUBIDCHAR_CH(CUR)) && (CUR != '\'')){
-            len++;
-            NEXT;
-        }
-
-	if (CUR != '\'') {
-	    htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED,
-	                 "Unfinished PubidLiteral\n", NULL, NULL);
-	} else {
-	    ret = xmlStrndup((BASE_PTR + startPosition), len);
-	    NEXT;
-	}
+    if (CUR != '"') {
+        htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED,
+                     "Unfinished PubidLiteral\n", NULL, NULL);
     } else {
-	htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_STARTED,
-	             "PubidLiteral \" or ' expected\n", NULL, NULL);
+        NEXT;
+        if (err == 0)
+            ret = xmlStrndup((BASE_PTR + startPosition), len);
     }
 
     return(ret);
@@ -2928,7 +2922,7 @@ htmlParseScript(htmlParserCtxtPtr ctxt) {
 
     SHRINK;
     cur = CUR_CHAR(l);
-    while (IS_CHAR_CH(cur)) {
+    while (cur != 0) {
 	if ((cur == '<') && (NXT(1) == '/')) {
             /*
              * One should break here, the specification is clear:
@@ -2959,7 +2953,12 @@ htmlParseScript(htmlParserCtxtPtr ctxt) {
                 }
             }
 	}
-	COPY_BUF(l,buf,nbchar,cur);
+        if (IS_CHAR(cur)) {
+	    COPY_BUF(l,buf,nbchar,cur);
+        } else {
+            htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
+                            "Invalid char in CDATA 0x%X\n", cur);
+        }
 	if (nbchar >= HTML_PARSER_BIG_BUFFER_SIZE) {
             buf[nbchar] = 0;
 	    if (ctxt->sax->cdataBlock!= NULL) {
@@ -2977,14 +2976,6 @@ htmlParseScript(htmlParserCtxtPtr ctxt) {
 	cur = CUR_CHAR(l);
     }
 
-    if ((!(IS_CHAR_CH(cur))) && (!((cur == 0) && (ctxt->progressive)))) {
-        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
-                    "Invalid char in CDATA 0x%X\n", cur);
-        if (ctxt->input->cur < ctxt->input->end) {
-            NEXT;
-        }
-    }
-
     if ((nbchar != 0) && (ctxt->sax != NULL) && (!ctxt->disableSAX)) {
         buf[nbchar] = 0;
 	if (ctxt->sax->cdataBlock!= NULL) {
@@ -3232,7 +3223,7 @@ htmlParsePI(htmlParserCtxtPtr ctxt) {
 	    }
             SKIP_BLANKS;
 	    cur = CUR_CHAR(l);
-	    while (IS_CHAR(cur) && (cur != '>')) {
+	    while ((cur != 0) && (cur != '>')) {
 		if (len + 5 >= size) {
 		    xmlChar *tmp;
 
@@ -3251,7 +3242,13 @@ htmlParsePI(htmlParserCtxtPtr ctxt) {
 		    GROW;
 		    count = 0;
 		}
-		COPY_BUF(l,buf,len,cur);
+                if (IS_CHAR(cur)) {
+		    COPY_BUF(l,buf,len,cur);
+                } else {
+                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
+                                    "Invalid char in processing instruction "
+                                    "0x%X\n", cur);
+                }
 		NEXTL(l);
 		cur = CUR_CHAR(l);
 		if (cur == 0) {
@@ -3321,15 +3318,15 @@ htmlParseComment(htmlParserCtxtPtr ctxt) {
     len = 0;
     buf[len] = 0;
     q = CUR_CHAR(ql);
-    if (!IS_CHAR(q))
+    if (q == 0)
         goto unfinished;
     NEXTL(ql);
     r = CUR_CHAR(rl);
-    if (!IS_CHAR(r))
+    if (r == 0)
         goto unfinished;
     NEXTL(rl);
     cur = CUR_CHAR(l);
-    while (IS_CHAR(cur) &&
+    while ((cur != 0) &&
            ((cur != '>') ||
 	    (r != '-') || (q != '-'))) {
 	if (len + 5 >= size) {
@@ -3345,7 +3342,12 @@ htmlParseComment(htmlParserCtxtPtr ctxt) {
 	    }
 	    buf = tmp;
 	}
-	COPY_BUF(ql,buf,len,q);
+        if (IS_CHAR(q)) {
+	    COPY_BUF(ql,buf,len,q);
+        } else {
+            htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
+                            "Invalid char in comment 0x%X\n", q);
+        }
 	q = r;
 	ql = rl;
 	r = cur;
@@ -3359,7 +3361,7 @@ htmlParseComment(htmlParserCtxtPtr ctxt) {
 	}
     }
     buf[len] = 0;
-    if (IS_CHAR(cur)) {
+    if (cur == '>') {
         NEXT;
 	if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&
 	    (!ctxt->disableSAX))
@@ -3400,13 +3402,16 @@ htmlParseCharRef(htmlParserCtxtPtr ctxt) {
         ((NXT(2) == 'x') || NXT(2) == 'X')) {
 	SKIP(3);
 	while (CUR != ';') {
-	    if ((CUR >= '0') && (CUR <= '9'))
-	        val = val * 16 + (CUR - '0');
-	    else if ((CUR >= 'a') && (CUR <= 'f'))
-	        val = val * 16 + (CUR - 'a') + 10;
-	    else if ((CUR >= 'A') && (CUR <= 'F'))
-	        val = val * 16 + (CUR - 'A') + 10;
-	    else {
+	    if ((CUR >= '0') && (CUR <= '9')) {
+                if (val < 0x110000)
+	            val = val * 16 + (CUR - '0');
+            } else if ((CUR >= 'a') && (CUR <= 'f')) {
+                if (val < 0x110000)
+	            val = val * 16 + (CUR - 'a') + 10;
+            } else if ((CUR >= 'A') && (CUR <= 'F')) {
+                if (val < 0x110000)
+	            val = val * 16 + (CUR - 'A') + 10;
+            } else {
 	        htmlParseErr(ctxt, XML_ERR_INVALID_HEX_CHARREF,
 		             "htmlParseCharRef: missing semicolon\n",
 			     NULL, NULL);
@@ -3419,9 +3424,10 @@ htmlParseCharRef(htmlParserCtxtPtr ctxt) {
     } else if  ((CUR == '&') && (NXT(1) == '#')) {
 	SKIP(2);
 	while (CUR != ';') {
-	    if ((CUR >= '0') && (CUR <= '9'))
-	        val = val * 10 + (CUR - '0');
-	    else {
+	    if ((CUR >= '0') && (CUR <= '9')) {
+                if (val < 0x110000)
+	            val = val * 10 + (CUR - '0');
+            } else {
 	        htmlParseErr(ctxt, XML_ERR_INVALID_DEC_CHARREF,
 		             "htmlParseCharRef: missing semicolon\n",
 			     NULL, NULL);
@@ -3440,6 +3446,9 @@ htmlParseCharRef(htmlParserCtxtPtr ctxt) {
      */
     if (IS_CHAR(val)) {
         return(val);
+    } else if (val >= 0x110000) {
+	htmlParseErr(ctxt, XML_ERR_INVALID_CHAR,
+		     "htmlParseCharRef: value too large\n", NULL, NULL);
     } else {
 	htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
 			"htmlParseCharRef: invalid xmlChar value %d\n",
@@ -3499,9 +3508,12 @@ htmlParseDocTypeDecl(htmlParserCtxtPtr ctxt) {
     if (CUR != '>') {
 	htmlParseErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED,
 	             "DOCTYPE improperly terminated\n", NULL, NULL);
-        /* We shouldn't try to resynchronize ... */
+        /* Ignore bogus content */
+        while ((CUR != 0) && (CUR != '>'))
+            NEXT;
     }
-    NEXT;
+    if (CUR == '>')
+        NEXT;
 
     /*
      * Create or update the document accordingly to the DOCTYPE
@@ -3779,7 +3791,7 @@ htmlParseStartTag(htmlParserCtxtPtr ctxt) {
 
 
 	/* Dump the bogus tag like browsers do */
-	while ((IS_CHAR_CH(CUR)) && (CUR != '>') &&
+	while ((CUR != 0) && (CUR != '>') &&
                (ctxt->instate != XML_PARSER_EOF))
 	    NEXT;
         return -1;
@@ -3835,11 +3847,9 @@ htmlParseStartTag(htmlParserCtxtPtr ctxt) {
      * (S Attribute)* S?
      */
     SKIP_BLANKS;
-    while ((IS_CHAR_CH(CUR)) &&
+    while ((CUR != 0) &&
            (CUR != '>') &&
 	   ((CUR != '/') || (NXT(1) != '>'))) {
-	long cons = ctxt->nbChars;
-
 	GROW;
 	attname = htmlParseAttribute(ctxt, &attvalue);
         if (attname != NULL) {
@@ -3898,7 +3908,7 @@ htmlParseStartTag(htmlParserCtxtPtr ctxt) {
 	        xmlFree(attvalue);
 	    /* Dump the bogus attribute string up to the next blank or
 	     * the end of the tag. */
-	    while ((IS_CHAR_CH(CUR)) &&
+	    while ((CUR != 0) &&
 	           !(IS_BLANK_CH(CUR)) && (CUR != '>') &&
 		   ((CUR != '/') || (NXT(1) != '>')))
 		NEXT;
@@ -3906,12 +3916,6 @@ htmlParseStartTag(htmlParserCtxtPtr ctxt) {
 
 failed:
 	SKIP_BLANKS;
-        if (cons == ctxt->nbChars) {
-	    htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
-	                 "htmlParseStartTag: problem parsing attributes\n",
-			 NULL, NULL);
-	    break;
-	}
     }
 
     /*
@@ -3979,19 +3983,14 @@ htmlParseEndTag(htmlParserCtxtPtr ctxt)
      * We should definitely be at the ending "S? '>'" part
      */
     SKIP_BLANKS;
-    if ((!IS_CHAR_CH(CUR)) || (CUR != '>')) {
+    if (CUR != '>') {
         htmlParseErr(ctxt, XML_ERR_GT_REQUIRED,
 	             "End tag : expected '>'\n", NULL, NULL);
-	if (ctxt->recovery) {
-	    /*
-	     * We're not at the ending > !!
-	     * Error, unless in recover mode where we search forwards
-	     * until we find a >
-	     */
-	    while (CUR != '\0' && CUR != '>') NEXT;
-	    NEXT;
-	}
-    } else
+        /* Skip to next '>' */
+        while ((CUR != 0) && (CUR != '>'))
+            NEXT;
+    }
+    if (CUR == '>')
         NEXT;
 
     /*
@@ -4152,8 +4151,6 @@ htmlParseContent(htmlParserCtxtPtr ctxt) {
     currentNode = xmlStrdup(ctxt->name);
     depth = ctxt->nameNr;
     while (1) {
-	long cons = ctxt->nbChars;
-
         GROW;
 
         if (ctxt->instate == XML_PARSER_EOF)
@@ -4181,7 +4178,7 @@ htmlParseContent(htmlParserCtxtPtr ctxt) {
 			 "htmlParseStartTag: invalid element name\n",
 			 NULL, NULL);
 	        /* Dump the bogus tag like browsers do */
-        while ((IS_CHAR_CH(CUR)) && (CUR != '>'))
+                while ((CUR != 0) && (CUR != '>'))
 	            NEXT;
 
 	        if (currentNode != NULL)
@@ -4273,15 +4270,6 @@ htmlParseContent(htmlParserCtxtPtr ctxt) {
 	    else {
 		htmlParseCharData(ctxt);
 	    }
-
-	    if (cons == ctxt->nbChars) {
-		if (ctxt->node != NULL) {
-		    htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
-		                 "detected an error in element content\n",
-				 NULL, NULL);
-		}
-		break;
-	    }
 	}
         GROW;
     }
@@ -4396,7 +4384,7 @@ htmlParseElement(htmlParserCtxtPtr ctxt) {
      */
     currentNode = xmlStrdup(ctxt->name);
     depth = ctxt->nameNr;
-    while (IS_CHAR_CH(CUR)) {
+    while (CUR != 0) {
 	oldptr = ctxt->input->cur;
 	htmlParseContent(ctxt);
 	if (oldptr==ctxt->input->cur) break;
@@ -4413,7 +4401,7 @@ htmlParseElement(htmlParserCtxtPtr ctxt) {
        node_info.node = ctxt->node;
        xmlParserAddNodeInfo(ctxt, &node_info);
     }
-    if (!IS_CHAR_CH(CUR)) {
+    if (CUR == 0) {
 	htmlAutoCloseOnEnd(ctxt);
     }
 
@@ -4434,7 +4422,7 @@ htmlParserFinishElementParsing(htmlParserCtxtPtr ctxt) {
        xmlParserAddNodeInfo(ctxt, ctxt->nodeInfo);
        htmlNodeInfoPop(ctxt);
     }
-    if (!IS_CHAR_CH(CUR)) {
+    if (CUR == 0) {
        htmlAutoCloseOnEnd(ctxt);
     }
 }
@@ -4552,8 +4540,6 @@ htmlParseContentInternal(htmlParserCtxtPtr ctxt) {
     currentNode = xmlStrdup(ctxt->name);
     depth = ctxt->nameNr;
     while (1) {
-	long cons = ctxt->nbChars;
-
         GROW;
 
         if (ctxt->instate == XML_PARSER_EOF)
@@ -4583,7 +4569,7 @@ htmlParseContentInternal(htmlParserCtxtPtr ctxt) {
 			 "htmlParseStartTag: invalid element name\n",
 			 NULL, NULL);
 	        /* Dump the bogus tag like browsers do */
-	        while ((IS_CHAR_CH(CUR)) && (CUR != '>'))
+	        while ((CUR == 0) && (CUR != '>'))
 	            NEXT;
 
 	        htmlParserFinishElementParsing(ctxt);
@@ -4687,15 +4673,6 @@ htmlParseContentInternal(htmlParserCtxtPtr ctxt) {
 	    else {
 		htmlParseCharData(ctxt);
 	    }
-
-	    if (cons == ctxt->nbChars) {
-		if (ctxt->node != NULL) {
-		    htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
-		                 "detected an error in element content\n",
-				 NULL, NULL);
-		}
-		break;
-	    }
 	}
         GROW;
     }
@@ -4959,7 +4936,6 @@ htmlInitParserCtxt(htmlParserCtxtPtr ctxt)
     ctxt->vctxt.warning = xmlParserValidityWarning;
     ctxt->record_info = 0;
     ctxt->validate = 0;
-    ctxt->nbChars = 0;
     ctxt->checkIndex = 0;
     ctxt->catalogs = NULL;
     xmlInitNodeInfoSeq(&ctxt->node_seq);
@@ -5119,7 +5095,7 @@ htmlCreateDocParserCtxt(const xmlChar *cur, const char *encoding) {
  * @first:  the first char to lookup
  * @next:  the next char to lookup or zero
  * @third:  the next char to lookup or zero
- * @comment: flag to force checking inside comments
+ * @ignoreattrval: skip over attribute values
  *
  * Try to find if a sequence (first, next, third) or  just (first next) or
  * (first) is available in the input stream.
@@ -5133,13 +5109,11 @@ htmlCreateDocParserCtxt(const xmlChar *cur, const char *encoding) {
  */
 static int
 htmlParseLookupSequence(htmlParserCtxtPtr ctxt, xmlChar first,
-                        xmlChar next, xmlChar third, int iscomment,
-                        int ignoreattrval)
+                        xmlChar next, xmlChar third, int ignoreattrval)
 {
     int base, len;
     htmlParserInputPtr in;
     const xmlChar *buf;
-    int incomment = 0;
     int invalue = 0;
     char valdellim = 0x0;
 
@@ -5151,8 +5125,11 @@ htmlParseLookupSequence(htmlParserCtxtPtr ctxt, xmlChar first,
     if (base < 0)
         return (-1);
 
-    if (ctxt->checkIndex > base)
+    if (ctxt->checkIndex > base) {
         base = ctxt->checkIndex;
+        /* Abuse hasPErefs member to restore current state. */
+        invalue = ctxt->hasPErefs & 1 ? 1 : 0;
+    }
 
     if (in->buf == NULL) {
         buf = in->base;
@@ -5168,14 +5145,6 @@ htmlParseLookupSequence(htmlParserCtxtPtr ctxt, xmlChar first,
     else if (next)
         len--;
     for (; base < len; base++) {
-        if ((!incomment) && (base + 4 < len) && (!iscomment)) {
-            if ((buf[base] == '<') && (buf[base + 1] == '!') &&
-                (buf[base + 2] == '-') && (buf[base + 3] == '-')) {
-                incomment = 1;
-                /* do not increment past <! - some people use <!--> */
-                base += 2;
-            }
-        }
         if (ignoreattrval) {
             if (buf[base] == '"' || buf[base] == '\'') {
                 if (invalue) {
@@ -5192,16 +5161,6 @@ htmlParseLookupSequence(htmlParserCtxtPtr ctxt, xmlChar first,
                 continue;
             }
         }
-        if (incomment) {
-            if (base + 3 > len)
-                return (-1);
-            if ((buf[base] == '-') && (buf[base + 1] == '-') &&
-                (buf[base + 2] == '>')) {
-                incomment = 0;
-                base += 2;
-            }
-            continue;
-        }
         if (buf[base] == first) {
             if (third != 0) {
                 if ((buf[base + 1] != next) || (buf[base + 2] != third))
@@ -5228,8 +5187,12 @@ htmlParseLookupSequence(htmlParserCtxtPtr ctxt, xmlChar first,
             return (base - (in->cur - in->base));
         }
     }
-    if ((!incomment) && (!invalue))
-        ctxt->checkIndex = base;
+    ctxt->checkIndex = base;
+    /* Abuse hasPErefs member to track current state. */
+    if (invalue)
+        ctxt->hasPErefs |= 1;
+    else
+        ctxt->hasPErefs &= ~1;
 #ifdef DEBUG_PUSH
     if (next == 0)
         xmlGenericError(xmlGenericErrorContext,
@@ -5245,80 +5208,6 @@ htmlParseLookupSequence(htmlParserCtxtPtr ctxt, xmlChar first,
     return (-1);
 }
 
-/**
- * htmlParseLookupChars:
- * @ctxt: an HTML parser context
- * @stop: Array of chars, which stop the lookup.
- * @stopLen: Length of stop-Array
- *
- * Try to find if any char of the stop-Array is available in the input
- * stream.
- * This function has a side effect of (possibly) incrementing ctxt->checkIndex
- * to avoid rescanning sequences of bytes, it DOES change the state of the
- * parser, do not use liberally.
- *
- * Returns the index to the current parsing point if a stopChar
- *      is available, -1 otherwise.
- */
-static int
-htmlParseLookupChars(htmlParserCtxtPtr ctxt, const xmlChar * stop,
-                     int stopLen)
-{
-    int base, len;
-    htmlParserInputPtr in;
-    const xmlChar *buf;
-    int incomment = 0;
-    int i;
-
-    in = ctxt->input;
-    if (in == NULL)
-        return (-1);
-
-    base = in->cur - in->base;
-    if (base < 0)
-        return (-1);
-
-    if (ctxt->checkIndex > base)
-        base = ctxt->checkIndex;
-
-    if (in->buf == NULL) {
-        buf = in->base;
-        len = in->length;
-    } else {
-        buf = xmlBufContent(in->buf->buffer);
-        len = xmlBufUse(in->buf->buffer);
-    }
-
-    for (; base < len; base++) {
-        if (!incomment && (base + 4 < len)) {
-            if ((buf[base] == '<') && (buf[base + 1] == '!') &&
-                (buf[base + 2] == '-') && (buf[base + 3] == '-')) {
-                incomment = 1;
-                /* do not increment past <! - some people use <!--> */
-                base += 2;
-            }
-        }
-        if (incomment) {
-            if (base + 3 > len)
-                return (-1);
-            if ((buf[base] == '-') && (buf[base + 1] == '-') &&
-                (buf[base + 2] == '>')) {
-                incomment = 0;
-                base += 2;
-            }
-            continue;
-        }
-        for (i = 0; i < stopLen; ++i) {
-            if (buf[base] == stop[i]) {
-                ctxt->checkIndex = 0;
-                return (base - (in->cur - in->base));
-            }
-        }
-    }
-    ctxt->checkIndex = base;
-    return (-1);
-}
-
 /**
  * htmlParseTryOrFinish:
  * @ctxt:  an HTML parser context
@@ -5332,7 +5221,7 @@ static int
 htmlParseTryOrFinish(htmlParserCtxtPtr ctxt, int terminate) {
     int ret = 0;
     htmlParserInputPtr in;
-    int avail = 0;
+    ptrdiff_t avail = 0;
     xmlChar cur, next;
 
     htmlParserNodeInfo node_info;
@@ -5397,7 +5286,8 @@ htmlParseTryOrFinish(htmlParserCtxtPtr ctxt, int terminate) {
 	if (in->buf == NULL)
 	    avail = in->length - (in->cur - in->base);
 	else
-	    avail = xmlBufUse(in->buf->buffer) - (in->cur - in->base);
+	    avail = (ptrdiff_t)xmlBufUse(in->buf->buffer) -
+                    (in->cur - in->base);
 	if ((avail == 0) && (terminate)) {
 	    htmlAutoCloseOnEnd(ctxt);
 	    if ((ctxt->nameNr == 0) && (ctxt->instate != XML_PARSER_EOF)) {
@@ -5411,6 +5301,12 @@ htmlParseTryOrFinish(htmlParserCtxtPtr ctxt, int terminate) {
 	}
         if (avail < 1)
 	    goto done;
+        /*
+         * This is done to make progress and avoid an infinite loop
+         * if a parsing attempt was aborted by hitting a NUL byte. After
+         * changing htmlCurrentChar, this probably isn't necessary anymore.
+         * We should consider removing this check.
+         */
 	cur = in->cur[0];
 	if (cur == 0) {
 	    SKIP(1);
@@ -5433,7 +5329,8 @@ htmlParseTryOrFinish(htmlParserCtxtPtr ctxt, int terminate) {
 		    if (in->buf == NULL)
 			avail = in->length - (in->cur - in->base);
 		    else
-			avail = xmlBufUse(in->buf->buffer) - (in->cur - in->base);
+			avail = (ptrdiff_t)xmlBufUse(in->buf->buffer) -
+                                (in->cur - in->base);
 		}
 		if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))
 		    ctxt->sax->setDocumentLocator(ctxt->userData,
@@ -5450,7 +5347,7 @@ htmlParseTryOrFinish(htmlParserCtxtPtr ctxt, int terminate) {
 		    (UPP(6) == 'Y') && (UPP(7) == 'P') &&
 		    (UPP(8) == 'E')) {
 		    if ((!terminate) &&
-		        (htmlParseLookupSequence(ctxt, '>', 0, 0, 0, 1) < 0))
+		        (htmlParseLookupSequence(ctxt, '>', 0, 0, 1) < 0))
 			goto done;
 #ifdef DEBUG_PUSH
 		    xmlGenericError(xmlGenericErrorContext,
@@ -5475,14 +5372,15 @@ htmlParseTryOrFinish(htmlParserCtxtPtr ctxt, int terminate) {
 		if (in->buf == NULL)
 		    avail = in->length - (in->cur - in->base);
 		else
-		    avail = xmlBufUse(in->buf->buffer) - (in->cur - in->base);
+		    avail = (ptrdiff_t)xmlBufUse(in->buf->buffer) -
+                            (in->cur - in->base);
 		/*
 		 * no chars in buffer
 		 */
 		if (avail < 1)
 		    goto done;
 		/*
-		 * not enouth chars in buffer
+		 * not enough chars in buffer
 		 */
 		if (avail < 2) {
 		    if (!terminate)
@@ -5496,7 +5394,7 @@ htmlParseTryOrFinish(htmlParserCtxtPtr ctxt, int terminate) {
 	        if ((cur == '<') && (next == '!') &&
 		    (in->cur[2] == '-') && (in->cur[3] == '-')) {
 		    if ((!terminate) &&
-		        (htmlParseLookupSequence(ctxt, '-', '-', '>', 1, 1) < 0))
+		        (htmlParseLookupSequence(ctxt, '-', '-', '>', 0) < 0))
 			goto done;
 #ifdef DEBUG_PUSH
 		    xmlGenericError(xmlGenericErrorContext,
@@ -5506,7 +5404,7 @@ htmlParseTryOrFinish(htmlParserCtxtPtr ctxt, int terminate) {
 		    ctxt->instate = XML_PARSER_MISC;
 	        } else if ((cur == '<') && (next == '?')) {
 		    if ((!terminate) &&
-		        (htmlParseLookupSequence(ctxt, '>', 0, 0, 0, 1) < 0))
+		        (htmlParseLookupSequence(ctxt, '>', 0, 0, 0) < 0))
 			goto done;
 #ifdef DEBUG_PUSH
 		    xmlGenericError(xmlGenericErrorContext,
@@ -5520,7 +5418,7 @@ htmlParseTryOrFinish(htmlParserCtxtPtr ctxt, int terminate) {
 		    (UPP(6) == 'Y') && (UPP(7) == 'P') &&
 		    (UPP(8) == 'E')) {
 		    if ((!terminate) &&
-		        (htmlParseLookupSequence(ctxt, '>', 0, 0, 0, 1) < 0))
+		        (htmlParseLookupSequence(ctxt, '>', 0, 0, 1) < 0))
 			goto done;
 #ifdef DEBUG_PUSH
 		    xmlGenericError(xmlGenericErrorContext,
@@ -5536,7 +5434,7 @@ htmlParseTryOrFinish(htmlParserCtxtPtr ctxt, int terminate) {
 		           (avail < 9)) {
 		    goto done;
 		} else {
-		    ctxt->instate = XML_PARSER_START_TAG;
+		    ctxt->instate = XML_PARSER_CONTENT;
 #ifdef DEBUG_PUSH
 		    xmlGenericError(xmlGenericErrorContext,
 			    "HPP: entering START_TAG\n");
@@ -5548,7 +5446,8 @@ htmlParseTryOrFinish(htmlParserCtxtPtr ctxt, int terminate) {
 		if (in->buf == NULL)
 		    avail = in->length - (in->cur - in->base);
 		else
-		    avail = xmlBufUse(in->buf->buffer) - (in->cur - in->base);
+		    avail = (ptrdiff_t)xmlBufUse(in->buf->buffer) -
+                            (in->cur - in->base);
 		if (avail < 2)
 		    goto done;
 		cur = in->cur[0];
@@ -5556,7 +5455,7 @@ htmlParseTryOrFinish(htmlParserCtxtPtr ctxt, int terminate) {
 		if ((cur == '<') && (next == '!') &&
 		    (in->cur[2] == '-') && (in->cur[3] == '-')) {
 		    if ((!terminate) &&
-		        (htmlParseLookupSequence(ctxt, '-', '-', '>', 1, 1) < 0))
+		        (htmlParseLookupSequence(ctxt, '-', '-', '>', 0) < 0))
 			goto done;
 #ifdef DEBUG_PUSH
 		    xmlGenericError(xmlGenericErrorContext,
@@ -5566,7 +5465,7 @@ htmlParseTryOrFinish(htmlParserCtxtPtr ctxt, int terminate) {
 		    ctxt->instate = XML_PARSER_PROLOG;
 	        } else if ((cur == '<') && (next == '?')) {
 		    if ((!terminate) &&
-		        (htmlParseLookupSequence(ctxt, '>', 0, 0, 0, 1) < 0))
+		        (htmlParseLookupSequence(ctxt, '>', 0, 0, 0) < 0))
 			goto done;
 #ifdef DEBUG_PUSH
 		    xmlGenericError(xmlGenericErrorContext,
@@ -5578,7 +5477,7 @@ htmlParseTryOrFinish(htmlParserCtxtPtr ctxt, int terminate) {
 		           (avail < 4)) {
 		    goto done;
 		} else {
-		    ctxt->instate = XML_PARSER_START_TAG;
+		    ctxt->instate = XML_PARSER_CONTENT;
 #ifdef DEBUG_PUSH
 		    xmlGenericError(xmlGenericErrorContext,
 			    "HPP: entering START_TAG\n");
@@ -5589,7 +5488,8 @@ htmlParseTryOrFinish(htmlParserCtxtPtr ctxt, int terminate) {
 		if (in->buf == NULL)
 		    avail = in->length - (in->cur - in->base);
 		else
-		    avail = xmlBufUse(in->buf->buffer) - (in->cur - in->base);
+		    avail = (ptrdiff_t)xmlBufUse(in->buf->buffer) -
+                            (in->cur - in->base);
 		if (avail < 1)
 		    goto done;
 		cur = in->cur[0];
@@ -5603,7 +5503,7 @@ htmlParseTryOrFinish(htmlParserCtxtPtr ctxt, int terminate) {
 	        if ((cur == '<') && (next == '!') &&
 		    (in->cur[2] == '-') && (in->cur[3] == '-')) {
 		    if ((!terminate) &&
-		        (htmlParseLookupSequence(ctxt, '-', '-', '>', 1, 1) < 0))
+		        (htmlParseLookupSequence(ctxt, '-', '-', '>', 0) < 0))
 			goto done;
 #ifdef DEBUG_PUSH
 		    xmlGenericError(xmlGenericErrorContext,
@@ -5613,7 +5513,7 @@ htmlParseTryOrFinish(htmlParserCtxtPtr ctxt, int terminate) {
 		    ctxt->instate = XML_PARSER_EPILOG;
 	        } else if ((cur == '<') && (next == '?')) {
 		    if ((!terminate) &&
-		        (htmlParseLookupSequence(ctxt, '>', 0, 0, 0, 1) < 0))
+		        (htmlParseLookupSequence(ctxt, '>', 0, 0, 0) < 0))
 			goto done;
 #ifdef DEBUG_PUSH
 		    xmlGenericError(xmlGenericErrorContext,
@@ -5648,7 +5548,7 @@ htmlParseTryOrFinish(htmlParserCtxtPtr ctxt, int terminate) {
 		if (avail < 1)
 		    goto done;
 		/*
-		 * not enouth chars in buffer
+		 * not enough chars in buffer
 		 */
 		if (avail < 2) {
 		    if (!terminate)
@@ -5677,7 +5577,7 @@ htmlParseTryOrFinish(htmlParserCtxtPtr ctxt, int terminate) {
 		    break;
 		}
 		if ((!terminate) &&
-		    (htmlParseLookupSequence(ctxt, '>', 0, 0, 0, 1) < 0))
+		    (htmlParseLookupSequence(ctxt, '>', 0, 0, 1) < 0))
 		    goto done;
 
                 /* Capture start position */
@@ -5769,7 +5669,6 @@ htmlParseTryOrFinish(htmlParserCtxtPtr ctxt, int terminate) {
 	    }
             case XML_PARSER_CONTENT: {
 		xmlChar chr[2] = { 0, 0 };
-		long cons;
 
                 /*
 		 * Handle preparsed entities and charRef
@@ -5814,7 +5713,6 @@ htmlParseTryOrFinish(htmlParserCtxtPtr ctxt, int terminate) {
 		    goto done;
 		cur = in->cur[0];
 		next = in->cur[1];
-		cons = ctxt->nbChars;
 		if ((xmlStrEqual(ctxt->name, BAD_CAST"script")) ||
 		    (xmlStrEqual(ctxt->name, BAD_CAST"style"))) {
 		    /*
@@ -5824,7 +5722,7 @@ htmlParseTryOrFinish(htmlParserCtxtPtr ctxt, int terminate) {
 		        int idx;
 			xmlChar val;
 
-			idx = htmlParseLookupSequence(ctxt, '<', '/', 0, 0, 0);
+			idx = htmlParseLookupSequence(ctxt, '<', '/', 0, 0);
 			if (idx < 0)
 			    goto done;
 		        val = in->cur[idx + 2];
@@ -5851,7 +5749,7 @@ htmlParseTryOrFinish(htmlParserCtxtPtr ctxt, int terminate) {
 			(UPP(6) == 'Y') && (UPP(7) == 'P') &&
 			(UPP(8) == 'E')) {
 			if ((!terminate) &&
-			    (htmlParseLookupSequence(ctxt, '>', 0, 0, 0, 1) < 0))
+			    (htmlParseLookupSequence(ctxt, '>', 0, 0, 1) < 0))
 			    goto done;
 			htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,
 			             "Misplaced DOCTYPE declaration\n",
@@ -5861,7 +5759,7 @@ htmlParseTryOrFinish(htmlParserCtxtPtr ctxt, int terminate) {
 			(in->cur[2] == '-') && (in->cur[3] == '-')) {
 			if ((!terminate) &&
 			    (htmlParseLookupSequence(
-				ctxt, '-', '-', '>', 1, 1) < 0))
+				ctxt, '-', '-', '>', 0) < 0))
 			    goto done;
 #ifdef DEBUG_PUSH
 			xmlGenericError(xmlGenericErrorContext,
@@ -5871,7 +5769,7 @@ htmlParseTryOrFinish(htmlParserCtxtPtr ctxt, int terminate) {
 			ctxt->instate = XML_PARSER_CONTENT;
 		    } else if ((cur == '<') && (next == '?')) {
 			if ((!terminate) &&
-			    (htmlParseLookupSequence(ctxt, '>', 0, 0, 0, 1) < 0))
+			    (htmlParseLookupSequence(ctxt, '>', 0, 0, 0) < 0))
 			    goto done;
 #ifdef DEBUG_PUSH
 			xmlGenericError(xmlGenericErrorContext,
@@ -5890,24 +5788,35 @@ htmlParseTryOrFinish(htmlParserCtxtPtr ctxt, int terminate) {
 #endif
 			break;
 		    } else if (cur == '<') {
-			ctxt->instate = XML_PARSER_START_TAG;
-			ctxt->checkIndex = 0;
+                        if ((!terminate) && (next == 0))
+                            goto done;
+                        /*
+                         * Only switch to START_TAG if the next character
+                         * starts a valid name. Otherwise, htmlParseStartTag
+                         * might return without consuming all characters
+                         * up to the final '>'.
+                         */
+                        if ((IS_ASCII_LETTER(next)) ||
+                            (next == '_') || (next == ':') || (next == '.')) {
+                            ctxt->instate = XML_PARSER_START_TAG;
+                            ctxt->checkIndex = 0;
 #ifdef DEBUG_PUSH
-			xmlGenericError(xmlGenericErrorContext,
-				"HPP: entering START_TAG\n");
+                            xmlGenericError(xmlGenericErrorContext,
+                                    "HPP: entering START_TAG\n");
 #endif
+                        } else {
+                            htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,
+                                         "htmlParseTryOrFinish: "
+                                         "invalid element name\n",
+                                         NULL, NULL);
+                            htmlCheckParagraph(ctxt);
+                            if ((ctxt->sax != NULL) &&
+                                (ctxt->sax->characters != NULL))
+                                ctxt->sax->characters(ctxt->userData,
+                                                      in->cur, 1);
+                            NEXT;
+                        }
 			break;
-		    } else if (cur == '&') {
-			if ((!terminate) &&
-			    (htmlParseLookupChars(ctxt,
-                                                  BAD_CAST "; >/", 4) < 0))
-			    goto done;
-#ifdef DEBUG_PUSH
-			xmlGenericError(xmlGenericErrorContext,
-				"HPP: Parsing Reference\n");
-#endif
-			/* TODO: check generation of subtrees if noent !!! */
-			htmlParseReference(ctxt);
 		    } else {
 		        /*
 			 * check that the text sequence is complete
@@ -5916,25 +5825,23 @@ htmlParseTryOrFinish(htmlParserCtxtPtr ctxt, int terminate) {
 			 * data detection.
 			 */
 			if ((!terminate) &&
-                            (htmlParseLookupChars(ctxt, BAD_CAST "<&", 2) < 0))
+                            (htmlParseLookupSequence(ctxt, '<', 0, 0, 0) < 0))
 			    goto done;
 			ctxt->checkIndex = 0;
 #ifdef DEBUG_PUSH
 			xmlGenericError(xmlGenericErrorContext,
 				"HPP: Parsing char data\n");
 #endif
-			htmlParseCharData(ctxt);
+                        while ((cur != '<') && (in->cur < in->end)) {
+                            if (cur == '&') {
+			        htmlParseReference(ctxt);
+                            } else {
+			        htmlParseCharData(ctxt);
+                            }
+                            cur = in->cur[0];
+                        }
 		    }
 		}
-		if (cons == ctxt->nbChars) {
-		    if (ctxt->node != NULL) {
-			htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
-			             "detected an error in element content\n",
-				     NULL, NULL);
-		    }
-		    NEXT;
-		    break;
-		}
 
 		break;
 	    }
@@ -5942,7 +5849,7 @@ htmlParseTryOrFinish(htmlParserCtxtPtr ctxt, int terminate) {
 		if (avail < 2)
 		    goto done;
 		if ((!terminate) &&
-		    (htmlParseLookupSequence(ctxt, '>', 0, 0, 0, 1) < 0))
+		    (htmlParseLookupSequence(ctxt, '>', 0, 0, 0) < 0))
 		    goto done;
 		htmlParseEndTag(ctxt);
 		if (ctxt->nameNr == 0) {
@@ -6124,12 +6031,12 @@ htmlParseChunk(htmlParserCtxtPtr ctxt, const char *chunk, int size,
 	int res;
 
 	res = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);
+        xmlBufSetInputBaseCur(ctxt->input->buf->buffer, ctxt->input, base, cur);
 	if (res < 0) {
 	    ctxt->errNo = XML_PARSER_EOF;
 	    ctxt->disableSAX = 1;
 	    return (XML_PARSER_EOF);
 	}
-        xmlBufSetInputBaseCur(ctxt->input->buf->buffer, ctxt->input, base, cur);
 #ifdef DEBUG_PUSH
 	xmlGenericError(xmlGenericErrorContext, "HPP: pushed %d\n", size);
 #endif
@@ -6148,12 +6055,12 @@ htmlParseChunk(htmlParserCtxtPtr ctxt, const char *chunk, int size,
 		size_t current = ctxt->input->cur - ctxt->input->base;
 
 		nbchars = xmlCharEncInput(in, terminate);
+		xmlBufSetInputBaseCur(in->buffer, ctxt->input, base, current);
 		if (nbchars < 0) {
 		    htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,
 			         "encoder error\n", NULL, NULL);
 		    return(XML_ERR_INVALID_ENCODING);
 		}
-		xmlBufSetInputBaseCur(in->buffer, ctxt->input, base, current);
 	    }
 	}
     }
@@ -6671,7 +6578,6 @@ htmlCtxtReset(htmlParserCtxtPtr ctxt)
     ctxt->vctxt.error = xmlParserValidityError;
     ctxt->vctxt.warning = xmlParserValidityWarning;
     ctxt->record_info = 0;
-    ctxt->nbChars = 0;
     ctxt->checkIndex = 0;
     ctxt->inSubset = 0;
     ctxt->errNo = XML_ERR_OK;
diff --git a/HTMLtree.c b/HTMLtree.c
index db63b371..8d0c7795 100644
--- a/HTMLtree.c
+++ b/HTMLtree.c
@@ -226,7 +226,7 @@ found_head:
 found_meta:
     /*
      * Search and update all the remaining the meta elements carrying
-     * encoding informations
+     * encoding information
      */
     while (cur != NULL) {
 	if ((cur->type == XML_ELEMENT_NODE) && (cur->name != NULL)) {
@@ -345,7 +345,7 @@ xmlAllocOutputBufferInternal(xmlCharEncodingHandlerPtr encoder);
  ************************************************************************/
 /**
  * htmlSaveErrMemory:
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle an out of memory condition
  */
@@ -359,7 +359,7 @@ htmlSaveErrMemory(const char *extra)
  * htmlSaveErr:
  * @code:  the error number
  * @node:  the location of the error.
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle an out of memory condition
  */
@@ -706,49 +706,22 @@ htmlAttrDumpOutput(xmlOutputBufferPtr buf, xmlDocPtr doc, xmlAttrPtr cur,
 		 (!xmlStrcasecmp(cur->name, BAD_CAST "src")) ||
 		 ((!xmlStrcasecmp(cur->name, BAD_CAST "name")) &&
 		  (!xmlStrcasecmp(cur->parent->name, BAD_CAST "a"))))) {
+		xmlChar *escaped;
 		xmlChar *tmp = value;
-		/* xmlURIEscapeStr() escapes '"' so it can be safely used. */
-		xmlBufCCat(buf->buffer, "\"");
 
 		while (IS_BLANK_CH(*tmp)) tmp++;
 
-		/* URI Escape everything, except server side includes. */
-		for ( ; ; ) {
-		    xmlChar *escaped;
-		    xmlChar endChar;
-		    xmlChar *end = NULL;
-		    xmlChar *start = (xmlChar *)xmlStrstr(tmp, BAD_CAST "<!--");
-		    if (start != NULL) {
-			end = (xmlChar *)xmlStrstr(tmp, BAD_CAST "-->");
-			if (end != NULL) {
-			    *start = '\0';
-			}
-		    }
-
-		    /* Escape the whole string, or until start (set to '\0'). */
-		    escaped = xmlURIEscapeStr(tmp, BAD_CAST"@/:=?;#%&,+");
-		    if (escaped != NULL) {
-		        xmlBufCat(buf->buffer, escaped);
-		        xmlFree(escaped);
-		    } else {
-		        xmlBufCat(buf->buffer, tmp);
-		    }
-
-		    if (end == NULL) { /* Everything has been written. */
-			break;
-		    }
-
-		    /* Do not escape anything within server side includes. */
-		    *start = '<'; /* Restore the first character of "<!--". */
-		    end += 3; /* strlen("-->") */
-		    endChar = *end;
-		    *end = '\0';
-		    xmlBufCat(buf->buffer, start);
-		    *end = endChar;
-		    tmp = end;
+		/*
+		 * the < and > have already been escaped at the entity level
+		 * And doing so here breaks server side includes
+		 */
+		escaped = xmlURIEscapeStr(tmp, BAD_CAST"@/:=?;#%&,+<>");
+		if (escaped != NULL) {
+		    xmlBufWriteQuotedString(buf->buffer, escaped);
+		    xmlFree(escaped);
+		} else {
+		    xmlBufWriteQuotedString(buf->buffer, value);
 		}
-
-		xmlBufCCat(buf->buffer, "\"");
 	    } else {
 		xmlBufWriteQuotedString(buf->buffer, value);
 	    }
@@ -759,50 +732,6 @@ htmlAttrDumpOutput(xmlOutputBufferPtr buf, xmlDocPtr doc, xmlAttrPtr cur,
     }
 }
 
-/**
- * htmlAttrListDumpOutput:
- * @buf:  the HTML buffer output
- * @doc:  the document
- * @cur:  the first attribute pointer
- * @encoding:  the encoding string
- *
- * Dump a list of HTML attributes
- */
-static void
-htmlAttrListDumpOutput(xmlOutputBufferPtr buf, xmlDocPtr doc, xmlAttrPtr cur, const char *encoding) {
-    if (cur == NULL) {
-	return;
-    }
-    while (cur != NULL) {
-        htmlAttrDumpOutput(buf, doc, cur, encoding);
-	cur = cur->next;
-    }
-}
-
-
-
-/**
- * htmlNodeListDumpOutput:
- * @buf:  the HTML buffer output
- * @doc:  the document
- * @cur:  the first node
- * @encoding:  the encoding string
- * @format:  should formatting spaces been added
- *
- * Dump an HTML node list, recursive behaviour,children are printed too.
- */
-static void
-htmlNodeListDumpOutput(xmlOutputBufferPtr buf, xmlDocPtr doc,
-	               xmlNodePtr cur, const char *encoding, int format) {
-    if (cur == NULL) {
-	return;
-    }
-    while (cur != NULL) {
-        htmlNodeDumpFormatOutput(buf, doc, cur, encoding, format);
-	cur = cur->next;
-    }
-}
-
 /**
  * htmlNodeDumpFormatOutput:
  * @buf:  the HTML buffer output
@@ -816,6 +745,8 @@ htmlNodeListDumpOutput(xmlOutputBufferPtr buf, xmlDocPtr doc,
 void
 htmlNodeDumpFormatOutput(xmlOutputBufferPtr buf, xmlDocPtr doc,
 	                 xmlNodePtr cur, const char *encoding, int format) {
+    xmlNodePtr root;
+    xmlAttrPtr attr;
     const htmlElemDesc * info;
 
     xmlInitParser();
@@ -823,172 +754,199 @@ htmlNodeDumpFormatOutput(xmlOutputBufferPtr buf, xmlDocPtr doc,
     if ((cur == NULL) || (buf == NULL)) {
 	return;
     }
-    /*
-     * Special cases.
-     */
-    if (cur->type == XML_DTD_NODE)
-	return;
-    if ((cur->type == XML_HTML_DOCUMENT_NODE) ||
-        (cur->type == XML_DOCUMENT_NODE)){
-	htmlDocContentDumpOutput(buf, (xmlDocPtr) cur, encoding);
-	return;
-    }
-    if (cur->type == XML_ATTRIBUTE_NODE) {
-        htmlAttrDumpOutput(buf, doc, (xmlAttrPtr) cur, encoding);
-	return;
-    }
-    if (cur->type == HTML_TEXT_NODE) {
-	if (cur->content != NULL) {
-	    if (((cur->name == (const xmlChar *)xmlStringText) ||
-		 (cur->name != (const xmlChar *)xmlStringTextNoenc)) &&
-		((cur->parent == NULL) ||
-		 ((xmlStrcasecmp(cur->parent->name, BAD_CAST "script")) &&
-		  (xmlStrcasecmp(cur->parent->name, BAD_CAST "style"))))) {
-		xmlChar *buffer;
-
-		buffer = xmlEncodeEntitiesReentrant(doc, cur->content);
-		if (buffer != NULL) {
-		    xmlOutputBufferWriteString(buf, (const char *)buffer);
-		    xmlFree(buffer);
-		}
-	    } else {
-		xmlOutputBufferWriteString(buf, (const char *)cur->content);
-	    }
-	}
-	return;
-    }
-    if (cur->type == HTML_COMMENT_NODE) {
-	if (cur->content != NULL) {
-	    xmlOutputBufferWriteString(buf, "<!--");
-	    xmlOutputBufferWriteString(buf, (const char *)cur->content);
-	    xmlOutputBufferWriteString(buf, "-->");
-	}
-	return;
-    }
-    if (cur->type == HTML_PI_NODE) {
-	if (cur->name == NULL)
-	    return;
-	xmlOutputBufferWriteString(buf, "<?");
-	xmlOutputBufferWriteString(buf, (const char *)cur->name);
-	if (cur->content != NULL) {
-	    xmlOutputBufferWriteString(buf, " ");
-	    xmlOutputBufferWriteString(buf, (const char *)cur->content);
-	}
-	xmlOutputBufferWriteString(buf, ">");
-	return;
-    }
-    if (cur->type == HTML_ENTITY_REF_NODE) {
-        xmlOutputBufferWriteString(buf, "&");
-	xmlOutputBufferWriteString(buf, (const char *)cur->name);
-        xmlOutputBufferWriteString(buf, ";");
-	return;
-    }
-    if (cur->type == HTML_PRESERVE_NODE) {
-	if (cur->content != NULL) {
-	    xmlOutputBufferWriteString(buf, (const char *)cur->content);
-	}
-	return;
-    }
 
-    /*
-     * Get specific HTML info for that node.
-     */
-    if (cur->ns == NULL)
-	info = htmlTagLookup(cur->name);
-    else
-	info = NULL;
+    root = cur;
+    while (1) {
+        switch (cur->type) {
+        case XML_HTML_DOCUMENT_NODE:
+        case XML_DOCUMENT_NODE:
+            if (((xmlDocPtr) cur)->intSubset != NULL) {
+                htmlDtdDumpOutput(buf, (xmlDocPtr) cur, NULL);
+            }
+            if (cur->children != NULL) {
+                cur = cur->children;
+                continue;
+            }
+            break;
 
-    xmlOutputBufferWriteString(buf, "<");
-    if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {
-        xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);
-	xmlOutputBufferWriteString(buf, ":");
-    }
-    xmlOutputBufferWriteString(buf, (const char *)cur->name);
-    if (cur->nsDef)
-	xmlNsListDumpOutput(buf, cur->nsDef);
-    if (cur->properties != NULL)
-        htmlAttrListDumpOutput(buf, doc, cur->properties, encoding);
-
-    if ((info != NULL) && (info->empty)) {
-        xmlOutputBufferWriteString(buf, ">");
-	if ((format) && (!info->isinline) && (cur->next != NULL)) {
-	    if ((cur->next->type != HTML_TEXT_NODE) &&
-		(cur->next->type != HTML_ENTITY_REF_NODE) &&
-		(cur->parent != NULL) &&
-		(cur->parent->name != NULL) &&
-		(cur->parent->name[0] != 'p')) /* p, pre, param */
-		xmlOutputBufferWriteString(buf, "\n");
-	}
-	return;
-    }
-    if (((cur->type == XML_ELEMENT_NODE) || (cur->content == NULL)) &&
-	(cur->children == NULL)) {
-        if ((info != NULL) && (info->saveEndTag != 0) &&
-	    (xmlStrcmp(BAD_CAST info->name, BAD_CAST "html")) &&
-	    (xmlStrcmp(BAD_CAST info->name, BAD_CAST "body"))) {
-	    xmlOutputBufferWriteString(buf, ">");
-	} else {
-	    xmlOutputBufferWriteString(buf, "></");
+        case XML_ELEMENT_NODE:
+            /*
+             * Get specific HTML info for that node.
+             */
+            if (cur->ns == NULL)
+                info = htmlTagLookup(cur->name);
+            else
+                info = NULL;
+
+            xmlOutputBufferWriteString(buf, "<");
             if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {
                 xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);
                 xmlOutputBufferWriteString(buf, ":");
             }
-	    xmlOutputBufferWriteString(buf, (const char *)cur->name);
-	    xmlOutputBufferWriteString(buf, ">");
-	}
-	if ((format) && (cur->next != NULL) &&
-            (info != NULL) && (!info->isinline)) {
-	    if ((cur->next->type != HTML_TEXT_NODE) &&
-		(cur->next->type != HTML_ENTITY_REF_NODE) &&
-		(cur->parent != NULL) &&
-		(cur->parent->name != NULL) &&
-		(cur->parent->name[0] != 'p')) /* p, pre, param */
-		xmlOutputBufferWriteString(buf, "\n");
-	}
-	return;
-    }
-    xmlOutputBufferWriteString(buf, ">");
-    if ((cur->type != XML_ELEMENT_NODE) &&
-	(cur->content != NULL)) {
-	    /*
-	     * Uses the OutputBuffer property to automatically convert
-	     * invalids to charrefs
-	     */
-
-            xmlOutputBufferWriteString(buf, (const char *) cur->content);
-    }
-    if (cur->children != NULL) {
-        if ((format) && (info != NULL) && (!info->isinline) &&
-	    (cur->children->type != HTML_TEXT_NODE) &&
-	    (cur->children->type != HTML_ENTITY_REF_NODE) &&
-	    (cur->children != cur->last) &&
-	    (cur->name != NULL) &&
-	    (cur->name[0] != 'p')) /* p, pre, param */
-	    xmlOutputBufferWriteString(buf, "\n");
-	htmlNodeListDumpOutput(buf, doc, cur->children, encoding, format);
-        if ((format) && (info != NULL) && (!info->isinline) &&
-	    (cur->last->type != HTML_TEXT_NODE) &&
-	    (cur->last->type != HTML_ENTITY_REF_NODE) &&
-	    (cur->children != cur->last) &&
-	    (cur->name != NULL) &&
-	    (cur->name[0] != 'p')) /* p, pre, param */
-	    xmlOutputBufferWriteString(buf, "\n");
-    }
-    xmlOutputBufferWriteString(buf, "</");
-    if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {
-        xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);
-	xmlOutputBufferWriteString(buf, ":");
-    }
-    xmlOutputBufferWriteString(buf, (const char *)cur->name);
-    xmlOutputBufferWriteString(buf, ">");
-    if ((format) && (info != NULL) && (!info->isinline) &&
-	(cur->next != NULL)) {
-        if ((cur->next->type != HTML_TEXT_NODE) &&
-	    (cur->next->type != HTML_ENTITY_REF_NODE) &&
-	    (cur->parent != NULL) &&
-	    (cur->parent->name != NULL) &&
-	    (cur->parent->name[0] != 'p')) /* p, pre, param */
-	    xmlOutputBufferWriteString(buf, "\n");
+            xmlOutputBufferWriteString(buf, (const char *)cur->name);
+            if (cur->nsDef)
+                xmlNsListDumpOutput(buf, cur->nsDef);
+            attr = cur->properties;
+            while (attr != NULL) {
+                htmlAttrDumpOutput(buf, doc, attr, encoding);
+                attr = attr->next;
+            }
+
+            if ((info != NULL) && (info->empty)) {
+                xmlOutputBufferWriteString(buf, ">");
+            } else if (cur->children == NULL) {
+                if ((info != NULL) && (info->saveEndTag != 0) &&
+                    (xmlStrcmp(BAD_CAST info->name, BAD_CAST "html")) &&
+                    (xmlStrcmp(BAD_CAST info->name, BAD_CAST "body"))) {
+                    xmlOutputBufferWriteString(buf, ">");
+                } else {
+                    xmlOutputBufferWriteString(buf, "></");
+                    if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {
+                        xmlOutputBufferWriteString(buf,
+                                (const char *)cur->ns->prefix);
+                        xmlOutputBufferWriteString(buf, ":");
+                    }
+                    xmlOutputBufferWriteString(buf, (const char *)cur->name);
+                    xmlOutputBufferWriteString(buf, ">");
+                }
+            } else {
+                xmlOutputBufferWriteString(buf, ">");
+                if ((format) && (info != NULL) && (!info->isinline) &&
+                    (cur->children->type != HTML_TEXT_NODE) &&
+                    (cur->children->type != HTML_ENTITY_REF_NODE) &&
+                    (cur->children != cur->last) &&
+                    (cur->name != NULL) &&
+                    (cur->name[0] != 'p')) /* p, pre, param */
+                    xmlOutputBufferWriteString(buf, "\n");
+                cur = cur->children;
+                continue;
+            }
+
+            if ((format) && (cur->next != NULL) &&
+                (info != NULL) && (!info->isinline)) {
+                if ((cur->next->type != HTML_TEXT_NODE) &&
+                    (cur->next->type != HTML_ENTITY_REF_NODE) &&
+                    (cur->parent != NULL) &&
+                    (cur->parent->name != NULL) &&
+                    (cur->parent->name[0] != 'p')) /* p, pre, param */
+                    xmlOutputBufferWriteString(buf, "\n");
+            }
+
+            break;
+
+        case XML_ATTRIBUTE_NODE:
+            htmlAttrDumpOutput(buf, doc, (xmlAttrPtr) cur, encoding);
+            break;
+
+        case HTML_TEXT_NODE:
+            if (cur->content == NULL)
+                break;
+            if (((cur->name == (const xmlChar *)xmlStringText) ||
+                 (cur->name != (const xmlChar *)xmlStringTextNoenc)) &&
+                ((cur->parent == NULL) ||
+                 ((xmlStrcasecmp(cur->parent->name, BAD_CAST "script")) &&
+                  (xmlStrcasecmp(cur->parent->name, BAD_CAST "style"))))) {
+                xmlChar *buffer;
+
+                buffer = xmlEncodeEntitiesReentrant(doc, cur->content);
+                if (buffer != NULL) {
+                    xmlOutputBufferWriteString(buf, (const char *)buffer);
+                    xmlFree(buffer);
+                }
+            } else {
+                xmlOutputBufferWriteString(buf, (const char *)cur->content);
+            }
+            break;
+
+        case HTML_COMMENT_NODE:
+            if (cur->content != NULL) {
+                xmlOutputBufferWriteString(buf, "<!--");
+                xmlOutputBufferWriteString(buf, (const char *)cur->content);
+                xmlOutputBufferWriteString(buf, "-->");
+            }
+            break;
+
+        case HTML_PI_NODE:
+            if (cur->name != NULL) {
+                xmlOutputBufferWriteString(buf, "<?");
+                xmlOutputBufferWriteString(buf, (const char *)cur->name);
+                if (cur->content != NULL) {
+                    xmlOutputBufferWriteString(buf, " ");
+                    xmlOutputBufferWriteString(buf,
+                            (const char *)cur->content);
+                }
+                xmlOutputBufferWriteString(buf, ">");
+            }
+            break;
+
+        case HTML_ENTITY_REF_NODE:
+            xmlOutputBufferWriteString(buf, "&");
+            xmlOutputBufferWriteString(buf, (const char *)cur->name);
+            xmlOutputBufferWriteString(buf, ";");
+            break;
+
+        case HTML_PRESERVE_NODE:
+            if (cur->content != NULL) {
+                xmlOutputBufferWriteString(buf, (const char *)cur->content);
+            }
+            break;
+
+        default:
+            break;
+        }
+
+        while (1) {
+            if (cur == root)
+                return;
+            if (cur->next != NULL) {
+                cur = cur->next;
+                break;
+            }
+
+            /*
+             * The parent should never be NULL here but we want to handle
+             * corrupted documents gracefully.
+             */
+            if (cur->parent == NULL)
+                return;
+            cur = cur->parent;
+
+            if ((cur->type == XML_HTML_DOCUMENT_NODE) ||
+                (cur->type == XML_DOCUMENT_NODE)) {
+                xmlOutputBufferWriteString(buf, "\n");
+            } else {
+                if ((format) && (cur->ns == NULL))
+                    info = htmlTagLookup(cur->name);
+                else
+                    info = NULL;
+
+                if ((format) && (info != NULL) && (!info->isinline) &&
+                    (cur->last->type != HTML_TEXT_NODE) &&
+                    (cur->last->type != HTML_ENTITY_REF_NODE) &&
+                    (cur->children != cur->last) &&
+                    (cur->name != NULL) &&
+                    (cur->name[0] != 'p')) /* p, pre, param */
+                    xmlOutputBufferWriteString(buf, "\n");
+
+                xmlOutputBufferWriteString(buf, "</");
+                if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {
+                    xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);
+                    xmlOutputBufferWriteString(buf, ":");
+                }
+                xmlOutputBufferWriteString(buf, (const char *)cur->name);
+                xmlOutputBufferWriteString(buf, ">");
+
+                if ((format) && (info != NULL) && (!info->isinline) &&
+                    (cur->next != NULL)) {
+                    if ((cur->next->type != HTML_TEXT_NODE) &&
+                        (cur->next->type != HTML_ENTITY_REF_NODE) &&
+                        (cur->parent != NULL) &&
+                        (cur->parent->name != NULL) &&
+                        (cur->parent->name[0] != 'p')) /* p, pre, param */
+                        xmlOutputBufferWriteString(buf, "\n");
+                }
+            }
+        }
     }
 }
 
@@ -1020,26 +978,7 @@ htmlNodeDumpOutput(xmlOutputBufferPtr buf, xmlDocPtr doc,
 void
 htmlDocContentDumpFormatOutput(xmlOutputBufferPtr buf, xmlDocPtr cur,
 	                       const char *encoding, int format) {
-    int type;
-
-    xmlInitParser();
-
-    if ((buf == NULL) || (cur == NULL))
-        return;
-
-    /*
-     * force to output the stuff as HTML, especially for entities
-     */
-    type = cur->type;
-    cur->type = XML_HTML_DOCUMENT_NODE;
-    if (cur->intSubset != NULL) {
-        htmlDtdDumpOutput(buf, cur, NULL);
-    }
-    if (cur->children != NULL) {
-        htmlNodeListDumpOutput(buf, cur, cur->children, encoding, format);
-    }
-    xmlOutputBufferWriteString(buf, "\n");
-    cur->type = (xmlElementType) type;
+    htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr) cur, encoding, format);
 }
 
 /**
@@ -1053,7 +992,7 @@ htmlDocContentDumpFormatOutput(xmlOutputBufferPtr buf, xmlDocPtr cur,
 void
 htmlDocContentDumpOutput(xmlOutputBufferPtr buf, xmlDocPtr cur,
 	                 const char *encoding) {
-    htmlDocContentDumpFormatOutput(buf, cur, encoding, 1);
+    htmlNodeDumpFormatOutput(buf, cur, (xmlNodePtr) cur, encoding, 1);
 }
 
 /************************************************************************
diff --git a/INSTALL.libxml2 b/INSTALL.libxml2
index fdf31f3b..383fb935 100644
--- a/INSTALL.libxml2
+++ b/INSTALL.libxml2
@@ -26,7 +26,7 @@ Compilation
      At that point you may have to rerun ldconfig or similar utility to
      update your list of installed shared libs.
 
-     At this point you can check that the library is properly functionning
+     At this point you can check that the library is properly functioning
      by running
 
      make tests
diff --git a/Makefile.am b/Makefile.am
index 05d1671f..a9284b95 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -2,9 +2,9 @@
 
 ACLOCAL_AMFLAGS = -I m4
 
-SUBDIRS = include . doc example xstc $(PYTHON_SUBDIR)
+SUBDIRS = include . doc example fuzz xstc $(PYTHON_SUBDIR)
 
-DIST_SUBDIRS = include . doc example python xstc
+DIST_SUBDIRS = include . doc example fuzz python xstc
 
 AM_CPPFLAGS = -I$(top_builddir)/include -I$(srcdir)/include
 
@@ -210,6 +210,7 @@ runtests: runtest$(EXEEXT) testrecurse$(EXEEXT) testapi$(EXEEXT) \
 	    $(CHECKER) ./runxmlconf$(EXEEXT)
 	@(if [ "$(PYTHON_SUBDIR)" != "" ] ; then cd python ; \
 	    $(MAKE) tests ; fi)
+	@cd fuzz; $(MAKE) tests
 
 check: all runtests
 
@@ -906,19 +907,21 @@ Regexptests: testRegexp$(EXEEXT)
 	  if [ ! -d $$i ] ; then \
 	  if [ ! -f $(srcdir)/result/regexp/$$name ] ; then \
 	      echo New test file $$name ; \
-	      $(CHECKER) $(top_builddir)/testRegexp -i $$i > $(srcdir)/result/regexp/$$name; \
+	      $(CHECKER) $(top_builddir)/testRegexp -i $$i > $(srcdir)/result/regexp/$$name 2> $(srcdir)/result/regexp/$$name.err ; \
+	      if [ ! -s "$(srcdir)/result/regexp/$$name.err" ] ; then rm $(srcdir)/result/regexp/$$name.err; fi ; \
 	      grep "MORY ALLO" .memdump  | grep -v "MEMORY ALLOCATED : 0";\
 	  else \
-	      log=`$(CHECKER) $(top_builddir)/testRegexp -i $$i 2>&1 > result.$$name ; \
+	      log=`$(CHECKER) $(top_builddir)/testRegexp -i $$i > result.$$name 2> error.$$name ; \
 	      grep "MORY ALLO" .memdump  | grep -v "MEMORY ALLOCATED : 0";\
-	      diff $(srcdir)/result/regexp/$$name result.$$name` ; \
-	      if [ -n "$$log" ] ; then echo $$name result ; echo "$$log" ; fi ; \
-	      rm result.$$name ; \
+	      diff $(srcdir)/result/regexp/$$name result.$$name ; \
+	      if [ -s "$(srcdir)/result/regexp/$$name.err" -o -s "error.$$name" ] ; then diff $(srcdir)/result/regexp/$$name.err error.$$name ; fi` ; \
+	      if [ -n "$$log" ] ; then echo $$name result ; echo $$log ; fi ; \
+	      rm result.$$name error.$$name ; \
 	  fi ; fi ; done)
 
 # Disabled for now
 Exptests: testRegexp$(EXEEXT)
-	@echo "## Formal expresssions regression tests"
+	@echo "## Formal expressions regression tests"
 	-@(for i in $(srcdir)/test/expr/* ; do \
 	  name=`basename $$i`; \
 	  if [ ! -d $$i ] ; then \
@@ -1257,6 +1260,7 @@ EXTRA_DIST = xml2-config.in xml2Conf.sh.in libxml.spec.in libxml2.spec \
 	     dbgen.pl dbgenattr.pl regressions.py regressions.xml \
 	     README.tests Makefile.tests libxml2.syms timsort.h \
 	     README.zOS \
+	     CMakeLists.txt config.h.cmake.in libxml2-config.cmake.cmake.in \
 	     $(CVS_EXTRA_DIST)
 
 
diff --git a/Makefile.tests b/Makefile.tests
index 619cbfb8..9f08dcfd 100644
--- a/Makefile.tests
+++ b/Makefile.tests
@@ -1,5 +1,5 @@
 #
-# You may have to ajust to call the right compiler, or other oprions
+# You may have to adjust to call the right compiler, or other options
 # for compiling and linking
 #
 
diff --git a/README b/README
index 5c7bddf8..49575178 100644
--- a/README
+++ b/README
@@ -19,7 +19,7 @@ To assert build quality:
        There is 3 standalone tools runtest.c runsuite.c testapi.c, which
        should compile as part of the build or as any application would.
        Launch them from this directory to get results, runtest checks 
-       the proper functionning of libxml2 main APIs while testapi does
+       the proper functioning of libxml2 main APIs while testapi does
        a full coverage check. Report failures to the list.
 
 To report bugs, follow the instructions at: 
diff --git a/SAX2.c b/SAX2.c
index 5f141f9a..4450a3f6 100644
--- a/SAX2.c
+++ b/SAX2.c
@@ -590,36 +590,6 @@ xmlSAX2GetEntity(void *ctx, const xmlChar *name)
     } else {
 	ret = xmlGetDocEntity(ctxt->myDoc, name);
     }
-    if ((ret != NULL) &&
-	((ctxt->validate) || (ctxt->replaceEntities)) &&
-	(ret->children == NULL) &&
-	(ret->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)) {
-	int val;
-
-	/*
-	 * for validation purposes we really need to fetch and
-	 * parse the external entity
-	 */
-	xmlNodePtr children;
-	unsigned long oldnbent = ctxt->nbentities;
-
-        val = xmlParseCtxtExternalEntity(ctxt, ret->URI,
-		                         ret->ExternalID, &children);
-	if (val == 0) {
-	    xmlAddChildList((xmlNodePtr) ret, children);
-	} else {
-	    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_PROCESSING,
-		           "Failure to process entity %s\n", name, NULL);
-	    ctxt->validate = 0;
-	    return(NULL);
-	}
-	ret->owner = 1;
-	if (ret->checked == 0) {
-	    ret->checked = (ctxt->nbentities - oldnbent + 1) * 2;
-	    if ((ret->content != NULL) && (xmlStrchr(ret->content, '<')))
-	        ret->checked |= 1;
-	}
-    }
     return(ret);
 }
 
@@ -1693,23 +1663,23 @@ xmlSAX2StartElement(void *ctx, const xmlChar *fullname, const xmlChar **atts)
 	}
     }
 
-    /*
-     * Insert all the defaulted attributes from the DTD especially namespaces
-     */
-    if ((!ctxt->html) &&
-	((ctxt->myDoc->intSubset != NULL) ||
-	 (ctxt->myDoc->extSubset != NULL))) {
-	xmlCheckDefaultedAttributes(ctxt, name, prefix, atts);
-    }
+    if (!ctxt->html) {
+        /*
+         * Insert all the defaulted attributes from the DTD especially
+         * namespaces
+         */
+        if ((ctxt->myDoc->intSubset != NULL) ||
+            (ctxt->myDoc->extSubset != NULL)) {
+            xmlCheckDefaultedAttributes(ctxt, name, prefix, atts);
+        }
 
-    /*
-     * process all the attributes whose name start with "xmlns"
-     */
-    if (atts != NULL) {
-        i = 0;
-	att = atts[i++];
-	value = atts[i++];
-	if (!ctxt->html) {
+        /*
+         * process all the attributes whose name start with "xmlns"
+         */
+        if (atts != NULL) {
+            i = 0;
+            att = atts[i++];
+            value = atts[i++];
 	    while ((att != NULL) && (value != NULL)) {
 		if ((att[0] == 'x') && (att[1] == 'm') && (att[2] == 'l') &&
 		    (att[3] == 'n') && (att[4] == 's'))
@@ -1718,30 +1688,30 @@ xmlSAX2StartElement(void *ctx, const xmlChar *fullname, const xmlChar **atts)
 		att = atts[i++];
 		value = atts[i++];
 	    }
-	}
-    }
+        }
 
-    /*
-     * Search the namespace, note that since the attributes have been
-     * processed, the local namespaces are available.
-     */
-    ns = xmlSearchNs(ctxt->myDoc, ret, prefix);
-    if ((ns == NULL) && (parent != NULL))
-	ns = xmlSearchNs(ctxt->myDoc, parent, prefix);
-    if ((prefix != NULL) && (ns == NULL)) {
-	ns = xmlNewNs(ret, NULL, prefix);
-	xmlNsWarnMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
-		     "Namespace prefix %s is not defined\n",
-		     prefix, NULL);
-    }
+        /*
+         * Search the namespace, note that since the attributes have been
+         * processed, the local namespaces are available.
+         */
+        ns = xmlSearchNs(ctxt->myDoc, ret, prefix);
+        if ((ns == NULL) && (parent != NULL))
+            ns = xmlSearchNs(ctxt->myDoc, parent, prefix);
+        if ((prefix != NULL) && (ns == NULL)) {
+            ns = xmlNewNs(ret, NULL, prefix);
+            xmlNsWarnMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
+                         "Namespace prefix %s is not defined\n",
+                         prefix, NULL);
+        }
 
-    /*
-     * set the namespace node, making sure that if the default namespace
-     * is unbound on a parent we simply keep it NULL
-     */
-    if ((ns != NULL) && (ns->href != NULL) &&
-	((ns->href[0] != 0) || (ns->prefix != NULL)))
-	xmlSetNs(ret, ns);
+        /*
+         * set the namespace node, making sure that if the default namespace
+         * is unbound on a parent we simply keep it NULL
+         */
+        if ((ns != NULL) && (ns->href != NULL) &&
+            ((ns->href[0] != 0) || (ns->prefix != NULL)))
+            xmlSetNs(ret, ns);
+    }
 
     /*
      * process all the other attributes
@@ -2203,7 +2173,7 @@ xmlSAX2AttributeNs(xmlParserCtxtPtr ctxt,
  *               attribute values.
  *
  * SAX2 callback when an element start has been detected by the parser.
- * It provides the namespace informations for the element, as well as
+ * It provides the namespace information for the element, as well as
  * the new namespace declarations on the element.
  */
 void
@@ -2456,7 +2426,7 @@ xmlSAX2StartElementNs(void *ctx,
  * @URI:  the element namespace name if available
  *
  * SAX2 callback when an element end has been detected by the parser.
- * It provides the namespace informations for the element.
+ * It provides the namespace information for the element.
  */
 void
 xmlSAX2EndElementNs(void *ctx,
diff --git a/TODO b/TODO
index 9c322249..94d34c8b 100644
--- a/TODO
+++ b/TODO
@@ -202,7 +202,7 @@ Done:
   by the XML parser, UTF-8 should be checked when there is no "encoding"
   declared !
 - Support for UTF-8 and UTF-16 encoding
-  => added some convertion routines provided by Martin Durst
+  => added some conversion routines provided by Martin Durst
      patched them, got fixes from @@@
      I plan to keep everything internally as UTF-8 (or ISO-Latin-X)
      this is slightly more costly but more compact, and recent processors
@@ -212,7 +212,7 @@ Done:
      is enabled, tested the ISO->UTF-8 stuff
 - External entities loading: 
    - allow override by client code
-   - make sure it is alled for all external entities referenced
+   - make sure it is called for all external entities referenced
   Done, client code should use xmlSetExternalEntityLoader() to set
   the default loading routine. It will be called each time an external
   entity entity resolution is triggered.
@@ -245,8 +245,8 @@ Done:
   most cases !
 
 - progressive reading. The entity support is a first step toward
-  asbtraction of an input stream. A large part of the context is still
-  located on the stack, moving to a state machine and putting everyting
+  abstraction of an input stream. A large part of the context is still
+  located on the stack, moving to a state machine and putting everything
   in the parsing context should provide an adequate solution.
   => Rather than progressive parsing, give more power to the SAX-like
      interface. Currently the DOM-like representation is built but
diff --git a/bakefile/Readme.txt b/bakefile/Readme.txt
index 98a9ca87..ceac4435 100644
--- a/bakefile/Readme.txt
+++ b/bakefile/Readme.txt
@@ -79,7 +79,7 @@
  The template files used to generate all makefiles are only two:
  - libxml2.bkl      (the main one)
  - Bakefiles.bkgen
- All the other files can be dinamically regenerated.
+ All the other files can be dynamically regenerated.
 
 
 
diff --git a/buf.c b/buf.c
index d46da365..24368d37 100644
--- a/buf.c
+++ b/buf.c
@@ -83,7 +83,7 @@ struct _xmlBuf {
 
 /**
  * xmlBufMemoryError:
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle an out of memory condition
  * To be improved...
@@ -98,7 +98,7 @@ xmlBufMemoryError(xmlBufPtr buf, const char *extra)
 
 /**
  * xmlBufOverflowError:
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle a buffer overflow error
  * To be improved...
@@ -1233,10 +1233,12 @@ xmlBufBackToBuffer(xmlBufPtr buf) {
          * Keep the buffer but provide a truncated size value.
          */
         xmlBufOverflowError(buf, "Allocated size too big for xmlBuffer");
+        ret->use = (int) buf->use;
         ret->size = INT_MAX;
+    } else {
+        ret->use = (int) buf->use;
+        ret->size = (int) buf->size;
     }
-    ret->use = (int) buf->use;
-    ret->size = (int) buf->size;
     ret->alloc = buf->alloc;
     ret->content = buf->content;
     ret->contentIO = buf->contentIO;
@@ -1332,8 +1334,12 @@ xmlBufGetInputBase(xmlBufPtr buf, xmlParserInputPtr input) {
 int
 xmlBufSetInputBaseCur(xmlBufPtr buf, xmlParserInputPtr input,
                       size_t base, size_t cur) {
-    if ((input == NULL) || (buf == NULL) || (buf->error))
+    if (input == NULL)
         return(-1);
+    if ((buf == NULL) || (buf->error)) {
+        input->base = input->cur = input->end = BAD_CAST "";
+        return(-1);
+    }
     CHECK_COMPAT(buf)
     input->base = &buf->content[base];
     input->cur = input->base + cur;
diff --git a/c14n.c b/c14n.c
index 5b3fbe70..3efcd92e 100644
--- a/c14n.c
+++ b/c14n.c
@@ -132,7 +132,7 @@ static xmlChar *xmlC11NNormalizeString(const xmlChar * input,
 
 /**
  * xmlC14NErrMemory:
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle a redefinition of memory error
  */
@@ -147,7 +147,7 @@ xmlC14NErrMemory(const char *extra)
 
 /**
  * xmlC14NErrParam:
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle a redefinition of param error
  */
@@ -162,7 +162,7 @@ xmlC14NErrParam(const char *extra)
 
 /**
  * xmlC14NErrInternal:
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle a redefinition of internal error
  */
@@ -177,7 +177,7 @@ xmlC14NErrInternal(const char *extra)
 
 /**
  * xmlC14NErrInvalidNode:
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle a redefinition of invalid node error
  */
@@ -192,7 +192,7 @@ xmlC14NErrInvalidNode(const char *node_type, const char *extra)
 
 /**
  * xmlC14NErrUnknownNode:
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle a redefinition of unknown node error
  */
@@ -207,7 +207,7 @@ xmlC14NErrUnknownNode(int node_type, const char *extra)
 
 /**
  * xmlC14NErrRelativeNamespace:
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle a redefinition of relative namespace error
  */
@@ -228,7 +228,7 @@ xmlC14NErrRelativeNamespace(const char *ns_uri)
  * @node:  the context node
  * @error:  the error code
  * @msg:  the message
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle a redefinition of attribute error
  */
@@ -2033,13 +2033,13 @@ xmlC14NDocDumpMemory(xmlDocPtr doc, xmlNodeSetPtr nodes,
     }
 
     ret = xmlBufUse(buf->buffer);
-    if (ret > 0) {
+    if (ret >= 0) {
         *doc_txt_ptr = xmlStrndup(xmlBufContent(buf->buffer), ret);
     }
     (void) xmlOutputBufferClose(buf);
 
-    if ((*doc_txt_ptr == NULL) && (ret > 0)) {
-        xmlC14NErrMemory("coping canonicalized document");
+    if ((*doc_txt_ptr == NULL) && (ret >= 0)) {
+        xmlC14NErrMemory("copying canonicalized document");
         return (-1);
     }
     return (ret);
diff --git a/catalog.c b/catalog.c
index 7328fd31..effbb2e6 100644
--- a/catalog.c
+++ b/catalog.c
@@ -216,7 +216,7 @@ static int xmlCatalogInitialized = 0;
 
 /**
  * xmlCatalogErrMemory:
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle an out of memory condition
  */
@@ -234,7 +234,7 @@ xmlCatalogErrMemory(const char *extra)
  * @catal: the Catalog entry
  * @node: the context node
  * @msg:  the error message
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle a catalog error
  */
@@ -924,7 +924,7 @@ xmlParseCatalogFile(const char *filename) {
     xmlBufResetInput(buf->buffer, inputStream);
 
     inputPush(ctxt, inputStream);
-    if ((ctxt->directory == NULL) && (directory == NULL))
+    if (ctxt->directory == NULL)
         directory = xmlParserGetDirectory(filename);
     if ((ctxt->directory == NULL) && (directory != NULL))
         ctxt->directory = directory;
@@ -2069,8 +2069,7 @@ xmlCatalogListXMLResolve(xmlCatalogEntryPtr catal, const xmlChar *pubID,
 		ret = xmlCatalogXMLResolve(catal->children, pubID, sysID);
 		if (ret != NULL) {
 		    break;
-                } else if ((catal->children != NULL) &&
-		           (catal->children->depth > MAX_CATAL_DEPTH)) {
+                } else if (catal->children->depth > MAX_CATAL_DEPTH) {
 	            ret = NULL;
 		    break;
 	        }
@@ -2353,7 +2352,7 @@ xmlParseSGMLCatalog(xmlCatalogPtr catal, const xmlChar *value,
 	    xmlCatalogEntryType type = XML_CATA_NONE;
 
 	    cur = xmlParseSGMLCatalogName(cur, &name);
-	    if (name == NULL) {
+	    if (cur == NULL || name == NULL) {
 		/* error */
 		break;
 	    }
@@ -3254,6 +3253,7 @@ xmlLoadCatalogs(const char *pathss) {
 	    while ((*cur != 0) && (*cur != PATH_SEPARATOR) && (!xmlIsBlank_ch(*cur)))
 		cur++;
 	    path = xmlStrndup((const xmlChar *)paths, cur - paths);
+	    if (path != NULL) {
 #ifdef _WIN32
         iLen = strlen((const char*)path);
         for(i = 0; i < iLen; i++) {
@@ -3262,7 +3262,6 @@ xmlLoadCatalogs(const char *pathss) {
             }
         }
 #endif
-	    if (path != NULL) {
 		xmlLoadCatalog((const char *) path);
 		xmlFree(path);
 	    }
@@ -3427,9 +3426,10 @@ xmlCatalogAdd(const xmlChar *type, const xmlChar *orig, const xmlChar *replace)
 	(xmlStrEqual(type, BAD_CAST "catalog"))) {
 	xmlDefaultCatalog = xmlCreateNewCatalog(XML_XML_CATALOG_TYPE,
 		                          xmlCatalogDefaultPrefer);
-	xmlDefaultCatalog->xml = xmlNewCatalogEntry(XML_CATA_CATALOG, NULL,
+	if (xmlDefaultCatalog != NULL) {
+	   xmlDefaultCatalog->xml = xmlNewCatalogEntry(XML_CATA_CATALOG, NULL,
 				    orig, NULL,  xmlCatalogDefaultPrefer, NULL);
-
+	}
 	xmlRMutexUnlock(xmlCatalogMutex);
 	return(0);
     }
diff --git a/config.h.cmake.in b/config.h.cmake.in
new file mode 100644
index 00000000..22b3c920
--- /dev/null
+++ b/config.h.cmake.in
@@ -0,0 +1,288 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define if __attribute__((destructor)) is accepted */
+#cmakedefine ATTRIBUTE_DESTRUCTOR 1
+
+/* Type cast for the gethostbyname() argument */
+#cmakedefine GETHOSTBYNAME_ARG_CAST @GETHOSTBYNAME_ARG_CAST@
+
+/* Define to 1 if you have the <arpa/inet.h> header file. */
+#cmakedefine HAVE_ARPA_INET_H 1
+
+/* Define to 1 if you have the <arpa/nameser.h> header file. */
+#cmakedefine HAVE_ARPA_NAMESER_H 1
+
+/* Whether struct sockaddr::__ss_family exists */
+#cmakedefine HAVE_BROKEN_SS_FAMILY 1
+
+/* Define to 1 if you have the <ctype.h> header file. */
+#cmakedefine HAVE_CTYPE_H 1
+
+/* Define to 1 if you have the <dirent.h> header file. */
+#cmakedefine HAVE_DIRENT_H 1
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#cmakedefine HAVE_DLFCN_H 1
+
+/* Have dlopen based dso */
+#cmakedefine HAVE_DLOPEN 1
+
+/* Define to 1 if you have the <dl.h> header file. */
+#cmakedefine HAVE_DL_H 1
+
+/* Define to 1 if you have the <errno.h> header file. */
+#cmakedefine HAVE_ERRNO_H 1
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#cmakedefine HAVE_FCNTL_H 1
+
+/* Define to 1 if you have the <float.h> header file. */
+#cmakedefine HAVE_FLOAT_H 1
+
+/* Define to 1 if you have the `fprintf' function. */
+#cmakedefine HAVE_FPRINTF 1
+
+/* Define to 1 if you have the `ftime' function. */
+#cmakedefine HAVE_FTIME 1
+
+/* Define if getaddrinfo is there */
+#cmakedefine HAVE_GETADDRINFO 1
+
+/* Define to 1 if you have the `gettimeofday' function. */
+#cmakedefine HAVE_GETTIMEOFDAY 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#cmakedefine HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the `isascii' function. */
+#cmakedefine HAVE_ISASCII 1
+
+/* Define if isinf is there */
+#cmakedefine HAVE_ISINF 1
+
+/* Define if isnan is there */
+#cmakedefine HAVE_ISNAN 1
+
+/* Define if history library is there (-lhistory) */
+#cmakedefine HAVE_LIBHISTORY 1
+
+/* Define if pthread library is there (-lpthread) */
+#cmakedefine HAVE_LIBPTHREAD 1
+
+/* Define if readline library is there (-lreadline) */
+#cmakedefine HAVE_LIBREADLINE 1
+
+/* Define to 1 if you have the <limits.h> header file. */
+#cmakedefine HAVE_LIMITS_H 1
+
+/* Define to 1 if you have the `localtime' function. */
+#cmakedefine HAVE_LOCALTIME 1
+
+/* Define to 1 if you have the <lzma.h> header file. */
+#cmakedefine HAVE_LZMA_H 1
+
+/* Define to 1 if you have the <malloc.h> header file. */
+#cmakedefine HAVE_MALLOC_H 1
+
+/* Define to 1 if you have the <math.h> header file. */
+#cmakedefine HAVE_MATH_H 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#cmakedefine HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the `mmap' function. */
+#cmakedefine HAVE_MMAP 1
+
+/* Define to 1 if you have the `munmap' function. */
+#cmakedefine HAVE_MUNMAP 1
+
+/* mmap() is no good without munmap() */
+#if defined(HAVE_MMAP) && !defined(HAVE_MUNMAP)
+#  undef /**/ HAVE_MMAP
+#endif
+
+/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
+#cmakedefine HAVE_NDIR_H 1
+
+/* Define to 1 if you have the <netdb.h> header file. */
+#cmakedefine HAVE_NETDB_H 1
+
+/* Define to 1 if you have the <netinet/in.h> header file. */
+#cmakedefine HAVE_NETINET_IN_H 1
+
+/* Define to 1 if you have the <poll.h> header file. */
+#cmakedefine HAVE_POLL_H 1
+
+/* Define to 1 if you have the `printf' function. */
+#cmakedefine HAVE_PRINTF 1
+
+/* Define if <pthread.h> is there */
+#cmakedefine HAVE_PTHREAD_H 1
+
+/* Define to 1 if you have the `putenv' function. */
+#cmakedefine HAVE_PUTENV 1
+
+/* Define to 1 if you have the `rand' function. */
+#cmakedefine HAVE_RAND 1
+
+/* Define to 1 if you have the `rand_r' function. */
+#cmakedefine HAVE_RAND_R 1
+
+/* Define to 1 if you have the <resolv.h> header file. */
+#cmakedefine HAVE_RESOLV_H 1
+
+/* Have shl_load based dso */
+#cmakedefine HAVE_SHLLOAD 1
+
+/* Define to 1 if you have the `signal' function. */
+#cmakedefine HAVE_SIGNAL 1
+
+/* Define to 1 if you have the <signal.h> header file. */
+#cmakedefine HAVE_SIGNAL_H 1
+
+/* Define to 1 if you have the `snprintf' function. */
+#cmakedefine HAVE_SNPRINTF 1
+
+/* Define to 1 if you have the `sprintf' function. */
+#cmakedefine HAVE_SPRINTF 1
+
+/* Define to 1 if you have the `srand' function. */
+#cmakedefine HAVE_SRAND 1
+
+/* Define to 1 if you have the `sscanf' function. */
+#cmakedefine HAVE_SSCANF 1
+
+/* Define to 1 if you have the `stat' function. */
+#cmakedefine HAVE_STAT 1
+
+/* Define to 1 if you have the <stdarg.h> header file. */
+#cmakedefine HAVE_STDARG_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#cmakedefine HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#cmakedefine HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `strftime' function. */
+#cmakedefine HAVE_STRFTIME 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#cmakedefine HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#cmakedefine HAVE_STRING_H 1
+
+/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
+   */
+#cmakedefine HAVE_SYS_DIR_H 1
+
+/* Define to 1 if you have the <sys/mman.h> header file. */
+#cmakedefine HAVE_SYS_MMAN_H 1
+
+/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
+   */
+#cmakedefine HAVE_SYS_NDIR_H 1
+
+/* Define to 1 if you have the <sys/select.h> header file. */
+#cmakedefine HAVE_SYS_SELECT_H 1
+
+/* Define to 1 if you have the <sys/socket.h> header file. */
+#cmakedefine HAVE_SYS_SOCKET_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#cmakedefine HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/timeb.h> header file. */
+#cmakedefine HAVE_SYS_TIMEB_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#cmakedefine HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#cmakedefine HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the `time' function. */
+#cmakedefine HAVE_TIME 1
+
+/* Define to 1 if you have the <time.h> header file. */
+#cmakedefine HAVE_TIME_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#cmakedefine HAVE_UNISTD_H 1
+
+/* Whether va_copy() is available */
+#cmakedefine HAVE_VA_COPY 1
+
+/* Define to 1 if you have the `vfprintf' function. */
+#cmakedefine HAVE_VFPRINTF 1
+
+/* Define to 1 if you have the `vsnprintf' function. */
+#cmakedefine HAVE_VSNPRINTF 1
+
+/* Define to 1 if you have the `vsprintf' function. */
+#cmakedefine HAVE_VSPRINTF 1
+
+/* Define to 1 if you have the <zlib.h> header file. */
+#cmakedefine HAVE_ZLIB_H 1
+
+/* Whether __va_copy() is available */
+#cmakedefine HAVE___VA_COPY 1
+
+/* Define as const if the declaration of iconv() needs const. */
+#define ICONV_CONST @ICONV_CONST@
+
+/* Define to the sub-directory where libtool stores uninstalled libraries. */
+#cmakedefine LT_OBJDIR "@LT_OBJDIR@"
+
+/* Name of package */
+#define PACKAGE "@PACKAGE@"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "@PACKAGE_BUGREPORT@"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "@PACKAGE_NAME@"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "@PACKAGE_STRING@"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "@PACKAGE_TARNAME@"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL "@PACKAGE_URL@"
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "@PACKAGE_VERSION@"
+
+/* Type cast for the send() function 2nd arg */
+#cmakedefine SEND_ARG2_CAST @SEND_ARG2_CAST@
+
+/* Define to 1 if you have the ANSI C header files. */
+#cmakedefine STDC_HEADERS 1
+
+/* Support for IPv6 */
+#cmakedefine SUPPORT_IP6 1
+
+/* Define if va_list is an array type */
+#cmakedefine VA_LIST_IS_ARRAY 1
+
+/* Version number of package */
+#cmakedefine VERSION "@VERSION@"
+
+/* Determine what socket length (socklen_t) data type is */
+#cmakedefine XML_SOCKLEN_T @XML_SOCKLEN_T@
+
+/* Define for Solaris 2.5.1 so the uint32_t typedef from <sys/synch.h>,
+   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the
+   #define below would cause a syntax error. */
+#cmakedefine _UINT32_T @_UINT32_T@
+
+/* ss_family is not defined here, use __ss_family instead */
+#cmakedefine ss_family @ss_family@
+
+/* Define to the type of an unsigned integer type of width exactly 32 bits if
+   such a type exists and the standard includes do not define it. */
+#cmakedefine uint32_t @uint32_t@
diff --git a/configure.ac b/configure.ac
index 07113a8e..a4c675bb 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,15 +1,20 @@
 dnl Process this file with autoconf to produce a configure script.
 AC_PREREQ([2.63])
-AC_INIT
+
+m4_define([MAJOR_VERSION], 2)
+m4_define([MINOR_VERSION], 9)
+m4_define([MICRO_VERSION], 10)
+
+AC_INIT([libxml2],[MAJOR_VERSION.MINOR_VERSION.MICRO_VERSION])
 AC_CONFIG_SRCDIR([entities.c])
 AC_CONFIG_HEADERS([config.h])
 AM_MAINTAINER_MODE([enable])
 AC_CONFIG_MACRO_DIR([m4])
 AC_CANONICAL_HOST
 
-LIBXML_MAJOR_VERSION=2
-LIBXML_MINOR_VERSION=9
-LIBXML_MICRO_VERSION=10
+LIBXML_MAJOR_VERSION=MAJOR_VERSION
+LIBXML_MINOR_VERSION=MINOR_VERSION
+LIBXML_MICRO_VERSION=MICRO_VERSION
 LIBXML_MICRO_VERSION_SUFFIX=
 LIBXML_VERSION=$LIBXML_MAJOR_VERSION.$LIBXML_MINOR_VERSION.$LIBXML_MICRO_VERSION$LIBXML_MICRO_VERSION_SUFFIX
 LIBXML_VERSION_INFO=`expr $LIBXML_MAJOR_VERSION + $LIBXML_MINOR_VERSION`:$LIBXML_MICRO_VERSION:$LIBXML_MINOR_VERSION
@@ -50,7 +55,7 @@ AC_SUBST(LIBXML_VERSION_EXTRA)
 
 VERSION=${LIBXML_VERSION}
 
-AM_INIT_AUTOMAKE(libxml2, $VERSION)
+AM_INIT_AUTOMAKE([foreign])
 
 # Support silent build rules, requires at least automake-1.11. Disable
 # by either passing --disable-silent-rules to configure or passing V=1
@@ -641,6 +646,17 @@ else
       [Type cast for the send() function 2nd arg])
 fi
 
+dnl Checking whether __attribute__((destructor)) is accepted by the compiler
+AC_MSG_CHECKING([whether __attribute__((destructor)) is accepted])
+AC_TRY_COMPILE2([
+void __attribute__((destructor))
+f(void) {}], [], [
+  AC_MSG_RESULT(yes)
+  AC_DEFINE([HAVE_ATTRIBUTE_DESTRUCTOR], [1],[Define if __attribute__((destructor)) is accepted])
+  AC_DEFINE([ATTRIBUTE_DESTRUCTOR], [__attribute__((destructor))],[A form that will not confuse apibuild.py])],[
+  AC_MSG_RESULT(no)])
+
+
 dnl ***********************Checking for availability of IPv6*******************
 
 AC_MSG_CHECKING([whether to enable IPv6])
@@ -770,7 +786,7 @@ else
 
     # warnings we'd like to see
     EXTRA_CFLAGS="${EXTRA_CFLAGS} -pedantic -Wall -Wextra -Wshadow -Wpointer-arith -Wcast-align -Wwrite-strings -Waggregate-return -Wstrict-prototypes -Wmissing-prototypes -Wnested-externs -Winline -Wredundant-decls"
-    # warnings we'd like to supress
+    # warnings we'd like to suppress
     EXTRA_CFLAGS="${EXTRA_CFLAGS} -Wno-long-long -Wno-format-extra-args"
     case "${host}" in
           alpha*-*-linux* )
@@ -1503,8 +1519,8 @@ else
 
             AC_CHECK_HEADER(unicode/ucnv.h,
             AC_MSG_CHECKING(for icu)
-            AC_TRY_LINK([#include <unicode/ucnv.h>],[
-        UConverter *utf = ucnv_open("UTF-8", NULL);],[
+            AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <unicode/ucnv.h>]], [[
+        UConverter *utf = ucnv_open("UTF-8", NULL);]])],[
                 AC_MSG_RESULT(yes)
                 have_libicu=yes],[
                 AC_MSG_RESULT(no)
@@ -1515,8 +1531,8 @@ else
                 LDFLAGS="${LDFLAGS} ${ICU_LIBS}"
                 LIBS="${LIBS} -licucore"
 
-                AC_TRY_LINK([#include <unicode/ucnv.h>],[
-        UConverter *utf = ucnv_open("UTF-8", NULL);],[
+                AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <unicode/ucnv.h>]], [[
+        UConverter *utf = ucnv_open("UTF-8", NULL);]])],[
                     AC_MSG_RESULT(yes)
                     have_libicu=yes
                     ICU_LIBS="${ICU_LIBS} -licucore"
@@ -1655,7 +1671,7 @@ dnl  http://sourceforge.net/project/shownotes.php?release_id=24832
 dnl
 dnl Also *win32*config.h files redefine them for various MSC compilers.
 dnl
-dnl So do not redefine {v}snprintf to _{v}snprintf like follwing:
+dnl So do not redefine {v}snprintf to _{v}snprintf like following:
 dnl  AC_DEFINE([snprintf],[_snprintf],[Win32 Std C name mangling work-around])
 dnl  AC_DEFINE([vsnprintf],[_vsnprintf],[Win32 Std C name mangling work-around])
 dnl and do not redefine those functions is C-source files.
@@ -1704,7 +1720,7 @@ rm -f COPYING.LIB COPYING
 ln -s $srcdir/Copyright COPYING
 
 # keep on one line for cygwin c.f. #130896
-AC_CONFIG_FILES([libxml2.spec:libxml.spec.in Makefile include/Makefile include/libxml/Makefile doc/Makefile doc/examples/Makefile doc/devhelp/Makefile example/Makefile python/Makefile python/tests/Makefile xstc/Makefile include/libxml/xmlversion.h libxml-2.0.pc libxml-2.0-uninstalled.pc libxml2-config.cmake])
+AC_CONFIG_FILES([libxml2.spec:libxml.spec.in Makefile include/Makefile include/libxml/Makefile doc/Makefile doc/examples/Makefile doc/devhelp/Makefile example/Makefile fuzz/Makefile python/Makefile python/tests/Makefile xstc/Makefile include/libxml/xmlversion.h libxml-2.0.pc libxml-2.0-uninstalled.pc libxml2-config.cmake])
 AC_CONFIG_FILES([python/setup.py], [chmod +x python/setup.py])
 AC_CONFIG_FILES([xml2-config], [chmod +x xml2-config])
 AC_OUTPUT
diff --git a/debugXML.c b/debugXML.c
index d8555558..7a2ca47d 100644
--- a/debugXML.c
+++ b/debugXML.c
@@ -1342,7 +1342,7 @@ xmlCtxtDumpDTD(xmlDebugCtxtPtr ctxt, xmlDtdPtr dtd)
  * @output:  the FILE * for the output
  * @str:  the string
  *
- * Dumps informations about the string, shorten it if necessary
+ * Dumps information about the string, shorten it if necessary
  */
 void
 xmlDebugDumpString(FILE * output, const xmlChar * str)
@@ -2190,7 +2190,7 @@ xmlShellRegisterRootNamespaces(xmlShellCtxtPtr ctxt, char *arg ATTRIBUTE_UNUSED,
  * @node2:  unused
  *
  * Implements the XML shell function "grep"
- * dumps informations about the node (namespace, attributes, content).
+ * dumps information about the node (namespace, attributes, content).
  *
  * Returns 0
  */
@@ -2268,7 +2268,7 @@ xmlShellGrep(xmlShellCtxtPtr ctxt ATTRIBUTE_UNUSED,
  * @node2:  unused
  *
  * Implements the XML shell function "dir"
- * dumps informations about the node (namespace, attributes, content).
+ * dumps information about the node (namespace, attributes, content).
  *
  * Returns 0
  */
@@ -2302,7 +2302,7 @@ xmlShellDir(xmlShellCtxtPtr ctxt ATTRIBUTE_UNUSED,
  * @node2:  unused
  *
  * Implements the XML shell function "dir"
- * dumps informations about the node (namespace, attributes, content).
+ * dumps information about the node (namespace, attributes, content).
  *
  * Returns 0
  */
@@ -2900,7 +2900,7 @@ xmlShell(xmlDocPtr doc, char *filename, xmlShellReadlineFunc input,
 		  fprintf(ctxt->output, "\tbye          leave shell\n");
 		  fprintf(ctxt->output, "\tcat [node]   display node or current node\n");
 		  fprintf(ctxt->output, "\tcd [path]    change directory to path or to root\n");
-		  fprintf(ctxt->output, "\tdir [path]   dumps informations about the node (namespace, attributes, content)\n");
+		  fprintf(ctxt->output, "\tdir [path]   dumps information about the node (namespace, attributes, content)\n");
 		  fprintf(ctxt->output, "\tdu [path]    show the structure of the subtree under path or the current node\n");
 		  fprintf(ctxt->output, "\texit         leave shell\n");
 		  fprintf(ctxt->output, "\thelp         display this help\n");
diff --git a/dict.c b/dict.c
index 336e046a..90e4d814 100644
--- a/dict.c
+++ b/dict.c
@@ -10,7 +10,7 @@
  *
  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
- * MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE AUTHORS AND
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE AUTHORS AND
  * CONTRIBUTORS ACCEPT NO RESPONSIBILITY IN ANY CONCEIVABLE MANNER.
  *
  * Author: daniel@veillard.com
@@ -452,7 +452,7 @@ xmlDictComputeFastKey(const xmlChar *name, int namelen, int seed) {
     unsigned long value = seed;
 
     if (name == NULL) return(0);
-    value = *name;
+    value += *name;
     value <<= 5;
     if (namelen > 10) {
         value += name[namelen - 1];
diff --git a/doc/apibuild.py b/doc/apibuild.py
index 95d7d044..18e8a9d3 100755
--- a/doc/apibuild.py
+++ b/doc/apibuild.py
@@ -74,6 +74,7 @@ ignored_words = {
   "__declspec": (3, "Windows keyword"),
   "__stdcall": (0, "Windows keyword"),
   "ATTRIBUTE_UNUSED": (0, "macro keyword"),
+  "ATTRIBUTE_DESTRUCTOR": (0, "macro keyword"),
   "LIBEXSLT_PUBLIC": (0, "macro keyword"),
   "X_IN_Y": (5, "macro function builder"),
   "ATTRIBUTE_ALLOC_SIZE": (3, "macro for gcc checking extension"),
@@ -807,7 +808,7 @@ class CParser:
         return((args, desc))
 
      #
-     # Parse a comment block and merge the informations found in the
+     # Parse a comment block and merge the information found in the
      # parameters descriptions, finally returns a block as complete
      # as possible
      #
diff --git a/doc/devhelp/libxml2.devhelp b/doc/devhelp/libxml2.devhelp
index 2e8eab3f..51b6f262 100644
--- a/doc/devhelp/libxml2.devhelp
+++ b/doc/devhelp/libxml2.devhelp
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<book xmlns="http://www.devhelp.net/book" title="libxml2 Reference Manual" link="index.html" author="" name="libxml2">
+<book xmlns="http://www.devhelp.net/book" title="libxml2 Reference Manual" link="index.html" version="2" author="" name="libxml2">
   <chapters>
     <sub name="API" link="general.html">
       <sub name="DOCBparser" link="libxml2-DOCBparser.html"/>
diff --git a/doc/examples/examples.xml b/doc/examples/examples.xml
index cc791ed2..4974187c 100644
--- a/doc/examples/examples.xml
+++ b/doc/examples/examples.xml
@@ -141,7 +141,7 @@
   </example>
   <example filename='reader1.c'>
     <synopsis>Parse an XML file with an xmlReader</synopsis>
-    <purpose>Demonstrate the use of xmlReaderForFile() to parse an XML file and dump the informations about the nodes found in the process. (Note that the XMLReader functions require libxml2 version later than 2.6.)</purpose>
+    <purpose>Demonstrate the use of xmlReaderForFile() to parse an XML file and dump the information about the nodes found in the process. (Note that the XMLReader functions require libxml2 version later than 2.6.)</purpose>
     <usage>reader1 &lt;filename&gt;</usage>
     <test>reader1 test2.xml &gt; reader1.tmp &amp;&amp; diff reader1.tmp $(srcdir)/reader1.res</test>
     <author>Daniel Veillard</author>
diff --git a/doc/examples/reader1.c b/doc/examples/reader1.c
index e8a005a4..76516096 100644
--- a/doc/examples/reader1.c
+++ b/doc/examples/reader1.c
@@ -2,7 +2,7 @@
  * section: xmlReader
  * synopsis: Parse an XML file with an xmlReader
  * purpose: Demonstrate the use of xmlReaderForFile() to parse an XML file
- *          and dump the informations about the nodes found in the process.
+ *          and dump the information about the nodes found in the process.
  *          (Note that the XMLReader functions require libxml2 version later
  *          than 2.6.)
  * usage: reader1 <filename>
diff --git a/doc/examples/testWriter.c b/doc/examples/testWriter.c
index 82e8d3ab..67be4ab4 100644
--- a/doc/examples/testWriter.c
+++ b/doc/examples/testWriter.c
@@ -89,7 +89,7 @@ testXmlwriterFilename(const char *uri)
         return;
     }
 
-    /* Start an element named "EXAMPLE". Since thist is the first
+    /* Start an element named "EXAMPLE". Since this is the first
      * element, this will be the root element of the document. */
     rc = xmlTextWriterStartElement(writer, BAD_CAST "EXAMPLE");
     if (rc < 0) {
@@ -368,7 +368,7 @@ testXmlwriterMemory(const char *file)
         return;
     }
 
-    /* Start an element named "EXAMPLE". Since thist is the first
+    /* Start an element named "EXAMPLE". Since this is the first
      * element, this will be the root element of the document. */
     rc = xmlTextWriterStartElement(writer, BAD_CAST "EXAMPLE");
     if (rc < 0) {
@@ -644,7 +644,7 @@ testXmlwriterDoc(const char *file)
         return;
     }
 
-    /* Start an element named "EXAMPLE". Since thist is the first
+    /* Start an element named "EXAMPLE". Since this is the first
      * element, this will be the root element of the document. */
     rc = xmlTextWriterStartElement(writer, BAD_CAST "EXAMPLE");
     if (rc < 0) {
diff --git a/doc/guidelines.html b/doc/guidelines.html
index af4a7b33..14a909c0 100644
--- a/doc/guidelines.html
+++ b/doc/guidelines.html
@@ -76,7 +76,7 @@ vocabulary. Here are a few tips:</p>
   <li>use significant words for the element and attributes names.</li>
   <li>do not use attributes for general textual content, attributes
     will be modified by the parser before reaching the application,
-    spaces and line informations will be modified.</li>
+    spaces and line information will be modified.</li>
   <li>use single elements for every string that might be subject to
     localization. The canonical way to localize XML content is to use
     siblings element carrying different xml:lang attributes like in the
diff --git a/doc/html/libxml.devhelp b/doc/html/libxml.devhelp
index 006b4bfe..d26d4d85 100644
--- a/doc/html/libxml.devhelp
+++ b/doc/html/libxml.devhelp
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="utf-8"?>
-<book xmlns="http://www.devhelp.net/book" title="Gnome XML Library Reference Manual " link="index.html" author="" name="libxml">
+<book xmlns="http://www.devhelp.net/book" title="Gnome XML Library Reference Manual " link="index.html" version="2" author="" name="libxml">
   <chapters>
     <sub name="Libxml Programming Notes" link="ch01.html">
       <sub name="testOOMlib" link="libxml-testOOMlib.html"/>
diff --git a/doc/index.py b/doc/index.py
index 77f9692d..e254dc4a 100755
--- a/doc/index.py
+++ b/doc/index.py
@@ -28,7 +28,7 @@
 #    Bye
 #
 # Then run the script in the doc subdir, it will create the symbols and
-# word tables and populate them with informations extracted from 
+# word tables and populate them with information extracted from 
 # the libxml2-api.xml API description, and make them accessible read-only
 # by nobody@loaclhost the user expected to be Apache's one
 #
@@ -1177,7 +1177,7 @@ def analyzeAPITop():
     try:
 	doc = loadAPI(API)
 	ret = analyzeAPI(doc)
-	print "Analyzed %d blocs" % (ret)
+	print "Analyzed %d blocks" % (ret)
 	doc.freeDoc()
     except:
 	print "Failed to parse and analyze %s" % (API)
diff --git a/doc/python.html b/doc/python.html
index fd52966c..f41f1412 100644
--- a/doc/python.html
+++ b/doc/python.html
@@ -43,14 +43,14 @@ or libxslt wrappers or bindings:</p><ul>
   <li><a href="http://savannah.gnu.org/projects/classpathx/">LibxmlJ</a> is
     an effort to create a 100% JAXP-compatible Java wrapper for libxml2 and
     libxslt as part of GNU ClasspathX project.</li>
-  <li>Patrick McPhee provides Rexx bindings fof libxml2 and libxslt, look for
+  <li>Patrick McPhee provides Rexx bindings for libxml2 and libxslt, look for
     <a href="http://www.interlog.com/~ptjm/software.html">RexxXML</a>.</li>
   <li><a href="http://www.satimage.fr/software/en/xml_suite.html">Satimage</a>
     provides <a href="http://www.satimage.fr/software/en/downloads_osaxen.html">XMLLib
     osax</a>. This is an osax for Mac OS X with a set of commands to
     implement in AppleScript the XML DOM, XPATH and XSLT. Also includes
     commands for Property-lists (Apple's fast lookup table XML format.)</li>
-  <li>Francesco Montorsi developped <a href="https://sourceforge.net/project/showfiles.php?group_id=51305&amp;package_id=45182">wxXml2</a>
+  <li>Francesco Montorsi developed <a href="https://sourceforge.net/project/showfiles.php?group_id=51305&amp;package_id=45182">wxXml2</a>
     wrappers that interface libxml2, allowing wxWidgets applications to
     load/save/edit XML instances.</li>
 </ul><p>The distribution includes a set of Python bindings, which are guaranteed
diff --git a/doc/symbols.xml b/doc/symbols.xml
index eeb049d4..a52202a2 100644
--- a/doc/symbols.xml
+++ b/doc/symbols.xml
@@ -1768,4 +1768,7 @@
   <release version="2.9.8">
     <symbol file="hash">xmlHashDefaultDeallocator</symbol>
   </release>
+  <release version="2.9.11">
+    <symbol file="xmlIO">xmlPopOutputCallbacks</symbol>
+  </release>
 </symbols>
diff --git a/doc/xml.html b/doc/xml.html
index 1b59f901..0a16f2c9 100644
--- a/doc/xml.html
+++ b/doc/xml.html
@@ -967,7 +967,7 @@ to the <a href="https://gitlab.gnome.org/GNOME/libxml2">GIT</a> code base.</p>
 <h3>2.9.7: Nov 02 2017</h3>
 <ul>
   <li>Documentation:<br/>
-  xmlcatalog: refresh man page wrt. quering system catalog easily (Jan Pokorn√Ω)<br/>
+  xmlcatalog: refresh man page wrt. querying system catalog easily (Jan Pokorn√Ω)<br/>
   </li>
 
   <li>Portability:<br/>
@@ -1306,7 +1306,7 @@ to the <a href="https://gitlab.gnome.org/GNOME/libxml2">GIT</a> code base.</p>
   <li>Improvements:<br/>
   Reuse xmlHaltParser() where it makes sense (Daniel Veillard),<br/>
   xmlStopParser reset errNo (Daniel Veillard),<br/>
-  Reenable xz support by default (Daniel Veillard),<br/>
+  Re-enable xz support by default (Daniel Veillard),<br/>
   Recover unescaped less-than character in HTML recovery parsing (Daniel Veillard),<br/>
   Allow HTML serializer to output HTML5 DOCTYPE (Shaun McCance),<br/>
   Regression test for bug #695699 (Nick Wellnhofer),<br/>
@@ -1695,7 +1695,7 @@ Gansterer),<br/>
     Harden the buffer code and make it more compatible (Daniel Veillard),<br/>
     More cleanups for input/buffers code (Daniel Veillard),<br/>
     Cleanup function xmlBufResetInput(),<br/> to set input from Buffer (Daniel Veillard)
-    Swicth the test program for characters to new input buffers (Daniel Veillard),<br/>
+    Switch the test program for characters to new input buffers (Daniel Veillard),<br/>
     Convert the HTML tree module to the new buffers (Daniel Veillard),<br/>
     Convert of the HTML parser to new input buffers (Daniel Veillard),<br/>
     Convert the writer to new output buffer and save APIs (Daniel Veillard),<br/>
@@ -1794,7 +1794,7 @@ Gansterer),<br/>
     Avoid memory leak if xmlParserInputBufferCreateIO fails (Lin Yi-Li),
     Prevent an infinite loop when dumping a node with encoding problems (Timothy Elliott),
     xmlParseNodeInContext problems with an empty document (Tim Elliott),
-    HTML element position is not detected propperly (Pavel Andrejs),
+    HTML element position is not detected properly (Pavel Andrejs),
     Fix an off by one pointer access (J√ºri Aedla),
     Try to fix a problem with entities in SAX mode (Daniel Veillard),
     Fix a crash with xmllint --path on empty results (Daniel Veillard),
@@ -1822,7 +1822,7 @@ Gansterer),<br/>
     Small fix for previous commit (Daniel Veillard),
     Fix a potential freeing error in XPath (Daniel Veillard),
     Fix a potential memory access error (Daniel Veillard),
-    Reactivate the shared library versionning script (Daniel Veillard)
+    Reactivate the shared library versioning script (Daniel Veillard)
   </li>
 
   <li>Improvements:
@@ -2011,7 +2011,7 @@ Gansterer),<br/>
     Problem with extern extern in header (Daniel Veillard),
     Add -lnetwork for compiling on Haiku (Scott McCreary),
     Runtest portability patch for Solaris (Tim Rice),
-    Small patch to accomodate the Haiku OS (Scott McCreary),
+    Small patch to accommodate the Haiku OS (Scott McCreary),
     584605 package VxWorks folder in the distribution (Daniel Veillard),
     574017 Realloc too expensive on most platform (Daniel Veillard),
     Fix windows build (Rob Richards),
@@ -2041,7 +2041,7 @@ Gansterer),<br/>
     558452 RNG compilation of optional multiple child (Daniel Veillard),
     579746 XSD validation not correct / nilable groups (Daniel Veillard),
     502960 provide namespace stack when parsing entity (Daniel Veillard),
-    566012 part 2 fix regresion tests and push mode (Daniel Veillard),
+    566012 part 2 fix regression tests and push mode (Daniel Veillard),
     566012 autodetected encoding and encoding conflict (Daniel Veillard),
     584220 xpointer(/) and xinclude problems (Daniel Veillard),
     587663 Incorrect Attribute-Value Normalization (Daniel Veillard),
@@ -2169,14 +2169,14 @@ Gansterer),<br/>
       parsing and validation fixes based on the W3C regression tests, reader
       tree skipping function fix (Ashwin), Schemas regexps escaping fix
       (Volker Grabsch), handling of entity push errors (Ashwin), fix a slowdown
-      when encoder cant serialize characters on output</li>
+      when encoder can't serialize characters on output</li>
   <li>Code cleanup: compilation fix without the reader, without the output
       (Robert Schwebel), python whitespace (Martin), many space/tabs cleanups,
       serious cleanup of the entity handling code</li>
   <li>Improvement: switch parser to XML-1.0 5th edition, add parsing flags
       for old versions, switch URI parsing to RFC 3986,
       add xmlSchemaValidCtxtGetParserCtxt (Holger Kaelberer),
-      new hashing functions for dictionnaries (based on Stefan Behnel work),
+      new hashing functions for dictionaries (based on Stefan Behnel work),
       improve handling of misplaced html/head/body in HTML parser, better
       regression test tools and code coverage display, better algorithms
       to detect various versions of the billion laughts attacks, make
@@ -2235,7 +2235,7 @@ Gansterer),<br/>
       </li>
   <li>Code cleanup: fix open() call third argument, regexp cut'n paste
       copy error, unused variable in __xmlGlobalInitMutexLock (Hannes Eder),
-      some make distcheck realted fixes (John Carr)</li>
+      some make distcheck related fixes (John Carr)</li>
   <li>Improvements: HTTP Header: includes port number (William Brack),
       testURI --debug option, </li>
 </ul>
@@ -2331,13 +2331,13 @@ Gansterer),<br/>
   <li>bug fix: xmlGetNodePath fix (Kasimier), xmlDOMWrapAdoptNode and
       attribute (Kasimier), crash when using the recover mode, 
       xmlXPathEvalExpr problem (Kasimier), xmlXPathCompExprAdd bug (Kasimier),
-      missing destry in xmlFreeRMutex (Andrew Nosenko), XML Schemas fixes
+      missing destroy in xmlFreeRMutex (Andrew Nosenko), XML Schemas fixes
       (Kasimier), warning on entities processing, XHTML script and style
       serialization (Kasimier), python generator for long types, bug in
       xmlSchemaClearValidCtxt (Bertrand Fritsch), xmlSchemaXPathEvaluate
       allocation bug (Marton Illes), error message end of line (Rob Richards),
       fix attribute serialization in writer (Rob Richards), PHP4 DTD validation
-      crasher, parser safety patch (Ben Darnell), _private context propagation
+      crash, parser safety patch (Ben Darnell), _private context propagation
       when parsing entities (with Michael Day), fix entities behaviour when 
       using SAX, URI to file path fix (Mikhail Zabaluev), disappearing validity
       context, arg error in SAX callback (Mike Hommey), fix mixed-content
@@ -2484,7 +2484,7 @@ Gansterer),<br/>
     Anatolij), xmlSchemaPSimpleTypeErr error report (Kasimier Buchcik), xml:
     namespace ahndling in Schemas (Kasimier), empty model group in Schemas
     (Kasimier), wildcard in Schemas (Kasimier), URI composition (William),
-    xs:anyType in Schemas (Kasimier), Python resolver emmitting error
+    xs:anyType in Schemas (Kasimier), Python resolver emitting error
     messages directly, Python xmlAttr.parent (Jakub Piotr Clapa), trying to
     fix the file path/URI conversion, xmlTextReaderGetAttribute fix (Rob
     Richards), xmlSchemaFreeAnnot memleak (Kasimier), HTML UTF-8
@@ -2511,7 +2511,7 @@ Gansterer),<br/>
   <li>build fixes: Windows build (Rob Richards), Mingw compilation (Igor
     Zlatkovic), Windows Makefile (Igor), gcc warnings (Kasimier and
     andriy@google.com), use gcc weak references to pthread to avoid the
-    pthread dependancy on Linux, compilation problem (Steve Nairn), compiling
+    pthread dependency on Linux, compilation problem (Steve Nairn), compiling
     of subset (Morten Welinder), IPv6/ss_family compilation (William Brack),
     compilation when disabling parts of the library, standalone test
     distribution.</li>
@@ -2553,7 +2553,7 @@ Gansterer),<br/>
     Linux/ELF/gcc4</li>
   <li>bug fixes: schemas type decimal fixups (William Brack), xmmlint return
     code (Gerry Murphy), small schemas fixes (Matthew Burgess and GUY
-    Fabrice), workaround "DAV:" namespace brokeness in c14n (Aleksey Sanin),
+    Fabrice), workaround "DAV:" namespace brokenness in c14n (Aleksey Sanin),
     segfault in Schemas (Kasimier Buchcik), Schemas attribute validation
     (Kasimier), Prop related functions and xmlNewNodeEatName (Rob Richards),
     HTML serialization of name attribute on a elements, Python error handlers
@@ -2573,7 +2573,7 @@ Gansterer),<br/>
     Bakefile support (Francesco Montorsi), Windows compilation (Joel Reed),
     some gcc4 fixes, HP-UX portability fixes (Rick Jones).</li>
   <li>bug fixes: xmlSchemaElementDump namespace (Kasimier Buchcik), push and
-    xmlreader stopping on non-fatal errors, thread support for dictionnaries
+    xmlreader stopping on non-fatal errors, thread support for dictionaries
     reference counting (Gary Coady), internal subset and push problem, URL
     saved in xmlCopyDoc, various schemas bug fixes (Kasimier), Python paths
     fixup (Stephane Bidoul), xmlGetNodePath and namespaces, xmlSetNsProp fix
@@ -2630,7 +2630,7 @@ Gansterer),<br/>
   <li>bug fixes: problem with XML::Libxml reported by Petr Pajas,  encoding
     conversion functions return values, UTF-8 bug affecting XPath reported by
     Markus Bertheau, catalog problem with NULL entries (William Brack)</li>
-  <li>documentation: fix to xmllint man page, some API function descritpion
+  <li>documentation: fix to xmllint man page, some API function description
     were updated.</li>
   <li>improvements: DTD validation APIs provided at the Python level (Brent
     Hendricks)</li>
@@ -2777,12 +2777,12 @@ Gansterer),<br/>
     William), xmlUriEscape (Mark Vakoc), a Relax-NG notAllowed problem (with
     William), Relax-NG name classes compares (William), XInclude duplicate
     fallback (William), external DTD encoding detection (William), a DTD
-    validation bug (William), xmlReader Close() fix, recusive extention
+    validation bug (William), xmlReader Close() fix, recursive extension
     schemas</li>
   <li>improvements: use xmlRead* APIs in test tools (Mark Vakoc), indenting
     save optimization, better handle IIS broken HTTP redirect  behaviour (Ian
     Hummel), HTML parser frameset (James Bursa), libxml2-python RPM
-    dependancy, XML Schemas union support (Kasimier Buchcik), warning removal
+    dependency, XML Schemas union support (Kasimier Buchcik), warning removal
     clanup (William), keep ChangeLog compressed when installing from RPMs</li>
   <li>documentation: examples and xmlDocDumpMemory docs (John Fleck), new
     example (load, xpath, modify, save), xmlCatalogDump() comments,</li>
@@ -2836,7 +2836,7 @@ Gansterer),<br/>
     William) reported by Yuuichi Teranishi</li>
   <li>bugfixes: make test and path issues, xmlWriter attribute serialization
     (William Brack), xmlWriter indentation (William), schemas validation
-    (Eric Haszlakiewicz), XInclude dictionnaries issues (William and Oleg
+    (Eric Haszlakiewicz), XInclude dictionaries issues (William and Oleg
     Paraschenko), XInclude empty fallback (William), HTML warnings (William),
     XPointer in XInclude (William), Python namespace serialization,
     isolat1ToUTF8 bound error (Alfred Mickautsch), output of parameter
@@ -2852,13 +2852,13 @@ Gansterer),<br/>
   <li>Windows compilation: mingw, msys (Mikhail Grushinskiy), function
     prototype (Cameron Johnson), MSVC6 compiler warnings, _WINSOCKAPI_
   patch</li>
-  <li>Parsers: added xmlByteConsumed(ctxt) API to get the byte offest in
+  <li>Parsers: added xmlByteConsumed(ctxt) API to get the byte offset in
     input.</li>
 </ul>
 
 <h3>2.6.5: Jan 25 2004</h3>
 <ul>
-  <li>Bugfixes: dictionnaries for schemas (William Brack), regexp segfault
+  <li>Bugfixes: dictionaries for schemas (William Brack), regexp segfault
     (William), xs:all problem (William), a number of XPointer bugfixes
     (William), xmllint error go to stderr, DTD validation problem with
     namespace, memory leak (William), SAX1 cleanup and minimal options fixes
@@ -3890,7 +3890,7 @@ it's actually not compiled in by default. The real fixes are:
     also contains numerous fixes and enhancements:
     <ul>
       <li>added xmlStopParser() to stop parsing</li>
-      <li>improved a lot parsing speed when there is large CDATA blocs</li>
+      <li>improved a lot parsing speed when there is large CDATA blocks</li>
       <li>includes XPath patches provided by Picdar Technology</li>
       <li>tried to fix as much as possible DTD validation and namespace
         related problems</li>
@@ -4189,7 +4189,7 @@ or libxslt wrappers or bindings:</p>
   <li><a href="http://savannah.gnu.org/projects/classpathx/">LibxmlJ</a> is
     an effort to create a 100% JAXP-compatible Java wrapper for libxml2 and
     libxslt as part of GNU ClasspathX project.</li>
-  <li>Patrick McPhee provides Rexx bindings fof libxml2 and libxslt, look for
+  <li>Patrick McPhee provides Rexx bindings for libxml2 and libxslt, look for
     <a href="http://www.interlog.com/~ptjm/software.html">RexxXML</a>.</li>
   <li><a
     href="http://www.satimage.fr/software/en/xml_suite.html">Satimage</a>
@@ -4198,7 +4198,7 @@ or libxslt wrappers or bindings:</p>
     osax</a>. This is an osax for Mac OS X with a set of commands to
     implement in AppleScript the XML DOM, XPATH and XSLT. Also includes
     commands for Property-lists (Apple's fast lookup table XML format.)</li>
-  <li>Francesco Montorsi developped <a
+  <li>Francesco Montorsi developed <a
     href="https://sourceforge.net/project/showfiles.php?group_id=51305&amp;package_id=45182">wxXml2</a>
     wrappers that interface libxml2, allowing wxWidgets applications to
     load/save/edit XML instances.</li>
diff --git a/doc/xmlreader.html b/doc/xmlreader.html
index 354e5bdf..6b4db47c 100644
--- a/doc/xmlreader.html
+++ b/doc/xmlreader.html
@@ -35,9 +35,9 @@ examples using both C and the Python bindings:</p>
 <ul>
   <li><a href="#Introducti">Introduction: why a new API</a></li>
   <li><a href="#Walking">Walking a simple tree</a></li>
-  <li><a href="#Extracting">Extracting informations for the current
+  <li><a href="#Extracting">Extracting information for the current
   node</a></li>
-  <li><a href="#Extracting1">Extracting informations for the
+  <li><a href="#Extracting1">Extracting information for the
   attributes</a></li>
   <li><a href="#Validating">Validating a document</a></li>
   <li><a href="#Entities">Entities substitution</a></li>
diff --git a/encoding.c b/encoding.c
index ad4d8a63..d67c16d9 100644
--- a/encoding.c
+++ b/encoding.c
@@ -76,7 +76,7 @@ static int xmlLittleEndian = 1;
 
 /**
  * xmlEncodingErrMemory:
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle an out of memory condition
  */
@@ -170,7 +170,7 @@ closeIcuConverter(uconv_t *conv)
  * Returns 0 if success, or -1 otherwise
  * The value of @inlen after return is the number of octets consumed
  *     if the return value is positive, else unpredictable.
- * The value of @outlen after return is the number of octets consumed.
+ * The value of @outlen after return is the number of octets produced.
  */
 static int
 asciiToUTF8(unsigned char* out, int *outlen,
@@ -217,7 +217,7 @@ asciiToUTF8(unsigned char* out, int *outlen,
  * Returns 0 if success, -2 if the transcoding fails, or -1 otherwise
  * The value of @inlen after return is the number of octets consumed
  *     if the return value is positive, else unpredictable.
- * The value of @outlen after return is the number of octets consumed.
+ * The value of @outlen after return is the number of octets produced.
  */
 static int
 UTF8Toascii(unsigned char* out, int *outlen,
@@ -301,7 +301,7 @@ UTF8Toascii(unsigned char* out, int *outlen,
  * Returns the number of bytes written if success, or -1 otherwise
  * The value of @inlen after return is the number of octets consumed
  *     if the return value is positive, else unpredictable.
- * The value of @outlen after return is the number of octets consumed.
+ * The value of @outlen after return is the number of octets produced.
  */
 int
 isolat1ToUTF8(unsigned char* out, int *outlen,
@@ -396,7 +396,7 @@ UTF8ToUTF8(unsigned char* out, int *outlen,
            or -1 otherwise
  * The value of @inlen after return is the number of octets consumed
  *     if the return value is positive, else unpredictable.
- * The value of @outlen after return is the number of octets consumed.
+ * The value of @outlen after return is the number of octets produced.
  */
 int
 UTF8Toisolat1(unsigned char* out, int *outlen,
@@ -496,13 +496,18 @@ UTF16LEToUTF8(unsigned char* out, int *outlen,
 {
     unsigned char* outstart = out;
     const unsigned char* processed = inb;
-    unsigned char* outend = out + *outlen;
+    unsigned char* outend;
     unsigned short* in = (unsigned short*) inb;
     unsigned short* inend;
     unsigned int c, d, inlen;
     unsigned char *tmp;
     int bits;
 
+    if (*outlen == 0) {
+        *inlenb = 0;
+        return(0);
+    }
+    outend = out + *outlen;
     if ((*inlenb % 2) == 1)
         (*inlenb)--;
     inlen = *inlenb / 2;
@@ -1483,16 +1488,25 @@ xmlRegisterCharEncodingHandler(xmlCharEncodingHandlerPtr handler) {
     if ((handler == NULL) || (handlers == NULL)) {
         xmlEncodingErr(XML_I18N_NO_HANDLER,
 		"xmlRegisterCharEncodingHandler: NULL handler !\n", NULL);
-	return;
+        goto free_handler;
     }
 
     if (nbCharEncodingHandler >= MAX_ENCODING_HANDLERS) {
         xmlEncodingErr(XML_I18N_EXCESS_HANDLER,
 	"xmlRegisterCharEncodingHandler: Too many handler registered, see %s\n",
 	               "MAX_ENCODING_HANDLERS");
-	return;
+        goto free_handler;
     }
     handlers[nbCharEncodingHandler++] = handler;
+    return;
+
+free_handler:
+    if (handler != NULL) {
+        if (handler->name != NULL) {
+            xmlFree(handler->name);
+        }
+        xmlFree(handler);
+    }
 }
 
 /**
@@ -1784,7 +1798,7 @@ xmlFindCharEncodingHandler(const char *name) {
  * @cd:		iconv converter data structure
  * @out:  a pointer to an array of bytes to store the result
  * @outlen:  the length of @out
- * @in:  a pointer to an array of ISO Latin 1 chars
+ * @in:  a pointer to an array of input bytes
  * @inlen:  the length of @in
  *
  * Returns 0 if success, or
@@ -1795,7 +1809,7 @@ xmlFindCharEncodingHandler(const char *name) {
  *
  * The value of @inlen after return is the number of octets consumed
  *     as the return value is positive, else unpredictable.
- * The value of @outlen after return is the number of octets consumed.
+ * The value of @outlen after return is the number of octets produced.
  */
 static int
 xmlIconvWrapper(iconv_t cd, unsigned char *out, int *outlen,
@@ -1851,7 +1865,7 @@ xmlIconvWrapper(iconv_t cd, unsigned char *out, int *outlen,
  * @toUnicode : non-zero if toUnicode. 0 otherwise.
  * @out:  a pointer to an array of bytes to store the result
  * @outlen:  the length of @out
- * @in:  a pointer to an array of ISO Latin 1 chars
+ * @in:  a pointer to an array of input bytes
  * @inlen:  the length of @in
  * @flush: if true, indicates end of input
  *
@@ -1863,7 +1877,7 @@ xmlIconvWrapper(iconv_t cd, unsigned char *out, int *outlen,
  *
  * The value of @inlen after return is the number of octets consumed
  *     as the return value is positive, else unpredictable.
- * The value of @outlen after return is the number of octets consumed.
+ * The value of @outlen after return is the number of octets produced.
  */
 static int
 xmlUconvWrapper(uconv_t *cd, int toUnicode, unsigned char *out, int *outlen,
@@ -1912,6 +1926,25 @@ xmlUconvWrapper(uconv_t *cd, int toUnicode, unsigned char *out, int *outlen,
  *									*
  ************************************************************************/
 
+/**
+ * xmlEncInputChunk:
+ * @handler:  encoding handler
+ * @out:  a pointer to an array of bytes to store the result
+ * @outlen:  the length of @out
+ * @in:  a pointer to an array of input bytes
+ * @inlen:  the length of @in
+ * @flush:  flush (ICU-related)
+ *
+ * Returns 0 if success, or
+ *     -1 by lack of space, or
+ *     -2 if the transcoding fails (for *in is not valid utf8 string or
+ *        the result of transformation can't fit into the encoding we want), or
+ *     -3 if there the last byte can't form a single output char.
+ *
+ * The value of @inlen after return is the number of octets consumed
+ *     as the return value is 0, else unpredictable.
+ * The value of @outlen after return is the number of octets produced.
+ */
 static int
 xmlEncInputChunk(xmlCharEncodingHandler *handler, unsigned char *out,
                  int *outlen, const unsigned char *in, int *inlen, int flush) {
@@ -1920,6 +1953,8 @@ xmlEncInputChunk(xmlCharEncodingHandler *handler, unsigned char *out,
 
     if (handler->input != NULL) {
         ret = handler->input(out, outlen, in, inlen);
+        if (ret > 0)
+           ret = 0;
     }
 #ifdef LIBXML_ICONV_ENABLED
     else if (handler->iconv_in != NULL) {
@@ -1941,7 +1976,25 @@ xmlEncInputChunk(xmlCharEncodingHandler *handler, unsigned char *out,
     return(ret);
 }
 
-/* Returns -4 if no output function was found. */
+/**
+ * xmlEncOutputChunk:
+ * @handler:  encoding handler
+ * @out:  a pointer to an array of bytes to store the result
+ * @outlen:  the length of @out
+ * @in:  a pointer to an array of input bytes
+ * @inlen:  the length of @in
+ *
+ * Returns 0 if success, or
+ *     -1 by lack of space, or
+ *     -2 if the transcoding fails (for *in is not valid utf8 string or
+ *        the result of transformation can't fit into the encoding we want), or
+ *     -3 if there the last byte can't form a single output char.
+ *     -4 if no output function was found.
+ *
+ * The value of @inlen after return is the number of octets consumed
+ *     as the return value is 0, else unpredictable.
+ * The value of @outlen after return is the number of octets produced.
+ */
 static int
 xmlEncOutputChunk(xmlCharEncodingHandler *handler, unsigned char *out,
                   int *outlen, const unsigned char *in, int *inlen) {
@@ -1949,6 +2002,8 @@ xmlEncOutputChunk(xmlCharEncodingHandler *handler, unsigned char *out,
 
     if (handler->output != NULL) {
         ret = handler->output(out, outlen, in, inlen);
+        if (ret > 0)
+           ret = 0;
     }
 #ifdef LIBXML_ICONV_ENABLED
     else if (handler->iconv_out != NULL) {
@@ -1958,7 +2013,7 @@ xmlEncOutputChunk(xmlCharEncodingHandler *handler, unsigned char *out,
 #ifdef LIBXML_ICU_ENABLED
     else if (handler->uconv_out != NULL) {
         ret = xmlUconvWrapper(handler->uconv_out, 0, out, outlen, in, inlen,
-                              TRUE);
+                              1);
     }
 #endif /* LIBXML_ICU_ENABLED */
     else {
@@ -2054,7 +2109,7 @@ xmlCharEncFirstLineInt(xmlCharEncodingHandler *handler, xmlBufferPtr out,
      */
     if (ret == -3) ret = 0;
     if (ret == -1) ret = 0;
-    return(ret);
+    return(written ? written : ret);
 }
 
 /**
@@ -2184,7 +2239,7 @@ xmlCharEncFirstLineInput(xmlParserInputBufferPtr input, int len)
      */
     if (ret == -3) ret = 0;
     if (ret == -1) ret = 0;
-    return(ret);
+    return(c_out ? c_out : ret);
 }
 
 /**
@@ -2394,7 +2449,7 @@ xmlCharEncOutput(xmlOutputBufferPtr output, int init)
 {
     int ret;
     size_t written;
-    size_t writtentot = 0;
+    int writtentot = 0;
     size_t toconv;
     int c_in;
     int c_out;
@@ -2427,7 +2482,7 @@ retry:
 	xmlGenericError(xmlGenericErrorContext,
 		"initialized encoder\n");
 #endif
-        return(0);
+        return(c_out);
     }
 
     /*
@@ -2540,7 +2595,7 @@ retry:
             goto retry;
 	}
     }
-    return(ret);
+    return(writtentot ? writtentot : ret);
 }
 #endif
 
@@ -2705,7 +2760,7 @@ retry:
             goto retry;
 	}
     }
-    return(ret);
+    return(writtentot ? writtentot : ret);
 }
 
 /**
diff --git a/entities.c b/entities.c
index d575e9d1..08ef1428 100644
--- a/entities.c
+++ b/entities.c
@@ -71,7 +71,7 @@ static xmlEntity xmlEntityApos = {
 
 /**
  * xmlEntitiesErrMemory:
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle an out of memory condition
  */
diff --git a/error.c b/error.c
index b7d5b36b..9ff1c2ba 100644
--- a/error.c
+++ b/error.c
@@ -146,7 +146,7 @@ xmlSetStructuredErrorFunc(void *ctx, xmlStructuredErrorFunc handler) {
  * xmlParserPrintFileInfo:
  * @input:  an xmlParserInputPtr input
  *
- * Displays the associated file and line informations for the current input
+ * Displays the associated file and line information for the current input
  */
 
 void
@@ -557,6 +557,7 @@ __xmlRaiseError(xmlStructuredErrorFunc schannel,
 	 * of the usual "base" (doc->URL) for the node (bug 152623).
 	 */
         xmlNodePtr prev = baseptr;
+        char *href = NULL;
 	int inclcount = 0;
 	while (prev != NULL) {
 	    if (prev->prev == NULL)
@@ -564,21 +565,20 @@ __xmlRaiseError(xmlStructuredErrorFunc schannel,
 	    else {
 	        prev = prev->prev;
 		if (prev->type == XML_XINCLUDE_START) {
-		    if (--inclcount < 0)
-		        break;
+		    if (inclcount > 0) {
+                        --inclcount;
+                    } else {
+                        href = (char *) xmlGetProp(prev, BAD_CAST "href");
+                        if (href != NULL)
+		            break;
+                    }
 		} else if (prev->type == XML_XINCLUDE_END)
 		    inclcount++;
 	    }
 	}
-	if (prev != NULL) {
-	    if (prev->type == XML_XINCLUDE_START) {
-		prev->type = XML_ELEMENT_NODE;
-		to->file = (char *) xmlGetProp(prev, BAD_CAST "href");
-		prev->type = XML_XINCLUDE_START;
-	    } else {
-		to->file = (char *) xmlGetProp(prev, BAD_CAST "href");
-	    }
-	} else
+        if (href != NULL)
+            to->file = href;
+	else
 #endif
 	    to->file = (char *) xmlStrdup(baseptr->doc->URL);
 	if ((to->file == NULL) && (node != NULL) && (node->doc != NULL)) {
@@ -643,7 +643,7 @@ __xmlRaiseError(xmlStructuredErrorFunc schannel,
  * @domain: where the error comes from
  * @code: the error code
  * @node: the context node
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle an out of memory condition
  */
diff --git a/fuzz/.gitignore b/fuzz/.gitignore
new file mode 100644
index 00000000..02c74b11
--- /dev/null
+++ b/fuzz/.gitignore
@@ -0,0 +1,13 @@
+corpus/
+genSeed
+html
+regexp
+schema
+seed/html*
+seed/schema*
+seed/xml*
+seed/xpath*
+testFuzzer
+uri
+xml
+xpath
diff --git a/fuzz/Makefile.am b/fuzz/Makefile.am
new file mode 100644
index 00000000..2bbdbb1f
--- /dev/null
+++ b/fuzz/Makefile.am
@@ -0,0 +1,140 @@
+AUTOMAKE_OPTIONS = -Wno-syntax
+EXTRA_PROGRAMS = genSeed html regexp schema uri xml xpath
+check_PROGRAMS = testFuzzer
+EXTRA_DIST = html.dict regexp.dict schema.dict xml.dict xpath.dict \
+	     seed/uri
+CLEANFILES = $(EXTRA_PROGRAMS)
+AM_CPPFLAGS = -I$(top_srcdir)/include
+DEPENDENCIES = $(top_builddir)/libxml2.la
+LDADD = $(STATIC_BINARIES) $(top_builddir)/libxml2.la $(THREAD_LIBS) $(Z_LIBS) $(LZMA_LIBS) $(ICONV_LIBS) $(M_LIBS) $(WIN32_EXTRA_LIBADD)
+
+XML_MAX_LEN = 80000
+# Single quotes to avoid wildcard expansion by the shell
+XML_SEED_CORPUS_SRC = \
+    '$(top_srcdir)/test/*' \
+    '$(top_srcdir)/test/errors/*.xml' \
+    '$(top_srcdir)/test/errors10/*.xml' \
+    '$(top_srcdir)/test/namespaces/*' \
+    '$(top_srcdir)/test/valid/*.xml' \
+    '$(top_srcdir)/test/VC/*' \
+    '$(top_srcdir)/test/VCM/*' \
+    '$(top_srcdir)/test/XInclude/docs/*' \
+    '$(top_srcdir)/test/xmlid/*'
+
+testFuzzer_SOURCES = testFuzzer.c fuzz.c
+
+.PHONY: tests corpus clean-corpus
+
+corpus: seed/html.stamp seed/schema.stamp seed/xml.stamp seed/xpath.stamp
+
+tests: testFuzzer$(EXEEXT) corpus
+	@echo "## Running fuzzer tests"
+	@./testFuzzer$(EXEEXT)
+
+clean-corpus:
+	rm -rf seed/html.stamp seed/html
+	rm -rf seed/schema.stamp seed/schema
+	rm -rf seed/xml.stamp seed/xml
+	rm -rf seed/xpath.stamp seed/xpath
+
+# Seed corpus
+
+genSeed_SOURCES = genSeed.c fuzz.c
+
+# XML fuzzer
+
+seed/xml.stamp: genSeed$(EXEEXT)
+	@mkdir -p seed/xml
+	@./genSeed$(EXEEXT) xml $(XML_SEED_CORPUS_SRC)
+	@touch seed/xml.stamp
+
+xml_SOURCES = xml.c fuzz.c
+xml_LDFLAGS = -fsanitize=fuzzer
+
+fuzz-xml: xml$(EXEEXT) seed/xml.stamp
+	@mkdir -p corpus/xml
+	./xml$(EXEEXT) \
+	    -dict=xml.dict \
+	    -max_len=$(XML_MAX_LEN) \
+	    -timeout=20 \
+	    corpus/xml seed/xml
+
+# HTML fuzzer
+
+seed/html.stamp: genSeed$(EXEEXT)
+	@mkdir -p seed/html
+	@./genSeed$(EXEEXT) html '$(top_srcdir)/test/HTML/*'
+	@touch seed/html.stamp
+
+html_SOURCES = html.c fuzz.c
+html_LDFLAGS = -fsanitize=fuzzer
+
+fuzz-html: html$(EXEEXT) seed/html.stamp
+	@mkdir -p corpus/html
+	./html$(EXEEXT) \
+	    -dict=html.dict \
+	    -max_len=1000000 \
+	    -timeout=20 \
+	    corpus/html seed/html
+
+# Regexp fuzzer
+
+regexp_SOURCES = regexp.c fuzz.c
+regexp_LDFLAGS = -fsanitize=fuzzer
+
+fuzz-regexp: regexp$(EXEEXT)
+	@mkdir -p corpus/regexp
+	./regexp$(EXEEXT) \
+	    -dict=regexp.dict \
+	    -max_len=200 \
+	    -timeout=5 \
+	    corpus/regexp $(srcdir)/seed/regexp
+
+# URI fuzzer
+
+uri_SOURCES = uri.c fuzz.c
+uri_LDFLAGS = -fsanitize=fuzzer
+
+fuzz-uri: uri$(EXEEXT)
+	@mkdir -p corpus/uri
+	./uri$(EXEEXT) \
+	    -max_len=10000 \
+	    -timeout=5 \
+	    corpus/uri $(srcdir)/seed/uri
+
+# XML Schema fuzzer
+
+seed/schema.stamp: genSeed$(EXEEXT)
+	@mkdir -p seed/schema
+	@./genSeed$(EXEEXT) schema '$(top_srcdir)/test/schemas/*.xsd'
+	@touch seed/schema.stamp
+
+schema_SOURCES = schema.c fuzz.c
+schema_LDFLAGS = -fsanitize=fuzzer
+
+fuzz-schema: schema$(EXEEXT) seed/schema.stamp
+	@mkdir -p corpus/schema
+	./schema$(EXEEXT) \
+	    -dict=schema.dict \
+	    -max_len=$(XML_MAX_LEN) \
+	    -timeout=20 \
+	    corpus/schema seed/schema
+
+# XPath fuzzer
+
+seed/xpath.stamp: genSeed$(EXEEXT)
+	@mkdir -p seed/xpath
+	@./genSeed$(EXEEXT) xpath "$(top_builddir)/test/XPath"
+	@touch seed/xpath.stamp
+
+xpath_SOURCES = xpath.c fuzz.c
+xpath_LDFLAGS = -fsanitize=fuzzer
+
+fuzz-xpath: xpath$(EXEEXT) seed/xpath.stamp
+	@mkdir -p corpus/xpath
+	./xpath$(EXEEXT) \
+	    -dict=xpath.dict \
+	    -max_len=10000 \
+	    -timeout=20 \
+	    corpus/xpath seed/xpath
+
diff --git a/fuzz/README b/fuzz/README
new file mode 100644
index 00000000..f675ad82
--- /dev/null
+++ b/fuzz/README
@@ -0,0 +1,19 @@
+libFuzzer instructions for libxml2
+==================================
+
+Set compiler and options:
+
+    export CC=clang
+    export CFLAGS="-g -fsanitize=fuzzer-no-link,address,undefined \
+        -fno-sanitize-recover=all \
+        -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION"
+
+Build libxml2 with instrumentation:
+
+    ./configure --without-python
+    make
+
+Run fuzzers:
+
+    make -C fuzz fuzz-xml
+
diff --git a/fuzz/fuzz.c b/fuzz/fuzz.c
new file mode 100644
index 00000000..b5dfa185
--- /dev/null
+++ b/fuzz/fuzz.c
@@ -0,0 +1,349 @@
+/*
+ * fuzz.c: Common functions for fuzzing.
+ *
+ * See Copyright for the status of this software.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/stat.h>
+
+#include <libxml/hash.h>
+#include <libxml/parser.h>
+#include <libxml/parserInternals.h>
+#include <libxml/tree.h>
+#include <libxml/xmlIO.h>
+#include "fuzz.h"
+
+typedef struct {
+    const char *data;
+    size_t size;
+} xmlFuzzEntityInfo;
+
+/* Single static instance for now */
+static struct {
+    /* Original data */
+    const char *data;
+    size_t size;
+
+    /* Remaining data */
+    const char *ptr;
+    size_t remaining;
+
+    /* Buffer for unescaped strings */
+    char *outBuf;
+    char *outPtr; /* Free space at end of buffer */
+
+    xmlHashTablePtr entities; /* Maps URLs to xmlFuzzEntityInfos */
+
+    /* The first entity is the main entity. */
+    const char *mainUrl;
+    xmlFuzzEntityInfo *mainEntity;
+} fuzzData;
+
+/**
+ * xmlFuzzErrorFunc:
+ *
+ * An error function that simply discards all errors.
+ */
+void
+xmlFuzzErrorFunc(void *ctx ATTRIBUTE_UNUSED, const char *msg ATTRIBUTE_UNUSED,
+                 ...) {
+}
+
+/**
+ * xmlFuzzDataInit:
+ *
+ * Initialize fuzz data provider.
+ */
+void
+xmlFuzzDataInit(const char *data, size_t size) {
+    fuzzData.data = data;
+    fuzzData.size = size;
+    fuzzData.ptr = data;
+    fuzzData.remaining = size;
+
+    fuzzData.outBuf = xmlMalloc(size + 1);
+    fuzzData.outPtr = fuzzData.outBuf;
+
+    fuzzData.entities = xmlHashCreate(8);
+    fuzzData.mainUrl = NULL;
+    fuzzData.mainEntity = NULL;
+}
+
+/**
+ * xmlFuzzDataFree:
+ *
+ * Cleanup fuzz data provider.
+ */
+void
+xmlFuzzDataCleanup(void) {
+    xmlFree(fuzzData.outBuf);
+    xmlHashFree(fuzzData.entities, xmlHashDefaultDeallocator);
+}
+
+/**
+ * xmlFuzzReadInt:
+ * @size:  size of string in bytes
+ *
+ * Read an integer from the fuzz data.
+ */
+int
+xmlFuzzReadInt() {
+    int ret;
+
+    if (fuzzData.remaining < sizeof(int))
+        return(0);
+    memcpy(&ret, fuzzData.ptr, sizeof(int));
+    fuzzData.ptr += sizeof(int);
+    fuzzData.remaining -= sizeof(int);
+
+    return ret;
+}
+
+/**
+ * xmlFuzzReadRemaining:
+ * @size:  size of string in bytes
+ *
+ * Read remaining bytes from fuzz data.
+ */
+const char *
+xmlFuzzReadRemaining(size_t *size) {
+    const char *ret = fuzzData.ptr;
+
+    *size = fuzzData.remaining;
+    fuzzData.ptr += fuzzData.remaining;
+    fuzzData.remaining = 0;
+
+    return(ret);
+}
+
+/*
+ * xmlFuzzWriteString:
+ * @out:  output file
+ * @str:  string to write
+ *
+ * Write a random-length string to file in a format similar to
+ * FuzzedDataProvider. Backslash followed by newline marks the end of the
+ * string. Two backslashes are used to escape a backslash.
+ */
+void
+xmlFuzzWriteString(FILE *out, const char *str) {
+    for (; *str; str++) {
+        int c = (unsigned char) *str;
+        putc(c, out);
+        if (c == '\\')
+            putc(c, out);
+    }
+    putc('\\', out);
+    putc('\n', out);
+}
+
+/**
+ * xmlFuzzReadString:
+ * @size:  size of string in bytes
+ *
+ * Read a random-length string from the fuzz data.
+ *
+ * The format is similar to libFuzzer's FuzzedDataProvider but treats
+ * backslash followed by newline as end of string. This makes the fuzz data
+ * more readable. A backslash character is escaped with another backslash.
+ *
+ * Returns a zero-terminated string or NULL if the fuzz data is exhausted.
+ */
+const char *
+xmlFuzzReadString(size_t *size) {
+    const char *out = fuzzData.outPtr;
+
+    while (fuzzData.remaining > 0) {
+        int c = *fuzzData.ptr++;
+        fuzzData.remaining--;
+
+        if ((c == '\\') && (fuzzData.remaining > 0)) {
+            int c2 = *fuzzData.ptr;
+
+            if (c2 == '\n') {
+                fuzzData.ptr++;
+                fuzzData.remaining--;
+                *size = fuzzData.outPtr - out;
+                *fuzzData.outPtr++ = '\0';
+                return(out);
+            }
+            if (c2 == '\\') {
+                fuzzData.ptr++;
+                fuzzData.remaining--;
+            }
+        }
+
+        *fuzzData.outPtr++ = c;
+    }
+
+    if (fuzzData.outPtr > out) {
+        *size = fuzzData.outPtr - out;
+        *fuzzData.outPtr++ = '\0';
+        return(out);
+    }
+
+    return(NULL);
+}
+
+/**
+ * xmlFuzzReadEntities:
+ *
+ * Read entities like the main XML file, external DTDs, external parsed
+ * entities from fuzz data.
+ */
+void
+xmlFuzzReadEntities(void) {
+    size_t num = 0;
+
+    while (1) {
+        const char *url, *entity;
+        size_t urlSize, entitySize;
+        xmlFuzzEntityInfo *entityInfo;
+        
+        url = xmlFuzzReadString(&urlSize);
+        if (url == NULL) break;
+
+        entity = xmlFuzzReadString(&entitySize);
+        if (entity == NULL) break;
+
+        if (xmlHashLookup(fuzzData.entities, (xmlChar *)url) == NULL) {
+            entityInfo = xmlMalloc(sizeof(xmlFuzzEntityInfo));
+            entityInfo->data = entity;
+            entityInfo->size = entitySize;
+
+            xmlHashAddEntry(fuzzData.entities, (xmlChar *)url, entityInfo);
+
+            if (num == 0) {
+                fuzzData.mainUrl = url;
+                fuzzData.mainEntity = entityInfo;
+            }
+
+            num++;
+        }
+    }
+}
+
+/**
+ * xmlFuzzMainUrl:
+ *
+ * Returns the main URL.
+ */
+const char *
+xmlFuzzMainUrl(void) {
+    return(fuzzData.mainUrl);
+}
+
+/**
+ * xmlFuzzMainEntity:
+ * @size:  size of the main entity in bytes
+ *
+ * Returns the main entity.
+ */
+const char *
+xmlFuzzMainEntity(size_t *size) {
+    if (fuzzData.mainEntity == NULL)
+        return(NULL);
+    *size = fuzzData.mainEntity->size;
+    return(fuzzData.mainEntity->data);
+}
+
+/**
+ * xmlFuzzEntityLoader:
+ *
+ * The entity loader for fuzz data.
+ */
+xmlParserInputPtr
+xmlFuzzEntityLoader(const char *URL, const char *ID ATTRIBUTE_UNUSED,
+                    xmlParserCtxtPtr ctxt) {
+    xmlParserInputPtr input;
+    xmlFuzzEntityInfo *entity;
+
+    if (URL == NULL)
+        return(NULL);
+    entity = xmlHashLookup(fuzzData.entities, (xmlChar *) URL);
+    if (entity == NULL)
+        return(NULL);
+
+    input = xmlNewInputStream(ctxt);
+    input->filename = NULL;
+    input->buf = xmlParserInputBufferCreateMem(entity->data, entity->size,
+                                               XML_CHAR_ENCODING_NONE);
+    input->base = input->cur = xmlBufContent(input->buf->buffer);
+    input->end = input->base + entity->size;
+
+    return input;
+}
+
+/**
+ * xmlFuzzExtractStrings:
+ *
+ * Extract C strings from input data. Use exact-size allocations to detect
+ * potential memory errors.
+ */
+size_t
+xmlFuzzExtractStrings(const char *data, size_t size, char **strings,
+                      size_t numStrings) {
+    const char *start = data;
+    const char *end = data + size;
+    size_t i = 0, ret;
+
+    while (i < numStrings) {
+        size_t strSize = end - start;
+        const char *zero = memchr(start, 0, strSize);
+
+        if (zero != NULL)
+            strSize = zero - start;
+
+        strings[i] = xmlMalloc(strSize + 1);
+        memcpy(strings[i], start, strSize);
+        strings[i][strSize] = '\0';
+
+        i++;
+        if (zero != NULL)
+            start = zero + 1;
+        else
+            break;
+    }
+
+    ret = i;
+
+    while (i < numStrings) {
+        strings[i] = NULL;
+        i++;
+    }
+
+    return(ret);
+}
+
+char *
+xmlSlurpFile(const char *path, size_t *sizeRet) {
+    FILE *file;
+    struct stat statbuf;
+    char *data;
+    size_t size;
+
+    if ((stat(path, &statbuf) != 0) || (!S_ISREG(statbuf.st_mode)))
+        return(NULL);
+    size = statbuf.st_size;
+    file = fopen(path, "rb");
+    if (file == NULL)
+        return(NULL);
+    data = xmlMalloc(size + 1);
+    if (data != NULL) {
+        if (fread(data, 1, size, file) != size) {
+            xmlFree(data);
+            data = NULL;
+        } else {
+            data[size] = 0;
+            if (sizeRet != NULL)
+                *sizeRet = size;
+        }
+    }
+    fclose(file);
+
+    return(data);
+}
+
diff --git a/fuzz/fuzz.h b/fuzz/fuzz.h
new file mode 100644
index 00000000..8716af93
--- /dev/null
+++ b/fuzz/fuzz.h
@@ -0,0 +1,70 @@
+/*
+ * fuzz.h: Common functions and macros for fuzzing.
+ *
+ * See Copyright for the status of this software.
+ */
+
+#ifndef __XML_FUZZERCOMMON_H__
+#define __XML_FUZZERCOMMON_H__
+
+#include <stddef.h>
+#include <stdio.h>
+#include <libxml/parser.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int
+LLVMFuzzerInitialize(int *argc, char ***argv);
+
+int
+LLVMFuzzerTestOneInput(const char *data, size_t size);
+
+void
+xmlFuzzErrorFunc(void *ctx ATTRIBUTE_UNUSED, const char *msg ATTRIBUTE_UNUSED,
+                 ...);
+
+void
+xmlFuzzDataInit(const char *data, size_t size);
+
+void
+xmlFuzzDataCleanup(void);
+
+int
+xmlFuzzReadInt(void);
+
+const char *
+xmlFuzzReadRemaining(size_t *size);
+
+void
+xmlFuzzWriteString(FILE *out, const char *str);
+
+const char *
+xmlFuzzReadString(size_t *size);
+
+void
+xmlFuzzReadEntities(void);
+
+const char *
+xmlFuzzMainUrl(void);
+
+const char *
+xmlFuzzMainEntity(size_t *size);
+
+xmlParserInputPtr
+xmlFuzzEntityLoader(const char *URL, const char *ID, xmlParserCtxtPtr ctxt);
+
+size_t
+xmlFuzzExtractStrings(const char *data, size_t size, char **strings,
+                      size_t numStrings);
+
+char *
+xmlSlurpFile(const char *path, size_t *size);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __XML_FUZZERCOMMON_H__ */
+
diff --git a/fuzz/genSeed.c b/fuzz/genSeed.c
new file mode 100644
index 00000000..68fb87a1
--- /dev/null
+++ b/fuzz/genSeed.c
@@ -0,0 +1,407 @@
+/*
+ * xmlSeed.c: Generate the XML seed corpus for fuzzing.
+ *
+ * See Copyright for the status of this software.
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <glob.h>
+#include <libgen.h>
+#include <sys/stat.h>
+
+#ifdef _WIN32
+#include <direct.h>
+#else
+#include <unistd.h>
+#endif
+
+#include <libxml/parser.h>
+#include <libxml/parserInternals.h>
+#include <libxml/HTMLparser.h>
+#include <libxml/xinclude.h>
+#include <libxml/xmlschemas.h>
+#include "fuzz.h"
+
+#define PATH_SIZE 500
+#define SEED_BUF_SIZE 16384
+#define EXPR_SIZE 4500
+
+typedef int
+(*fileFunc)(const char *base, FILE *out);
+
+typedef int
+(*mainFunc)(const char *arg);
+
+static struct {
+    FILE *out;
+    xmlHashTablePtr entities; /* Maps URLs to xmlFuzzEntityInfos */
+    xmlExternalEntityLoader oldLoader;
+    fileFunc processFile;
+    const char *fuzzer;
+    int counter;
+    char cwd[PATH_SIZE];
+} globalData;
+
+/*
+ * A custom entity loader that writes all external DTDs or entities to a
+ * single file in the format expected by xmlFuzzEntityLoader.
+ */
+static xmlParserInputPtr
+fuzzEntityRecorder(const char *URL, const char *ID,
+                      xmlParserCtxtPtr ctxt) {
+    xmlParserInputPtr in;
+    static const int chunkSize = 16384;
+    int len;
+
+    in = xmlNoNetExternalEntityLoader(URL, ID, ctxt);
+    if (in == NULL)
+        return(NULL);
+
+    if (globalData.entities == NULL) {
+        globalData.entities = xmlHashCreate(4);
+    } else if (xmlHashLookup(globalData.entities,
+                             (const xmlChar *) URL) != NULL) {
+        return(in);
+    }
+
+    do {
+        len = xmlParserInputBufferGrow(in->buf, chunkSize);
+        if (len < 0) {
+            fprintf(stderr, "Error reading %s\n", URL);
+            xmlFreeInputStream(in);
+            return(NULL);
+        }
+    } while (len > 0);
+
+    xmlFuzzWriteString(globalData.out, URL);
+    xmlFuzzWriteString(globalData.out,
+                       (char *) xmlBufContent(in->buf->buffer));
+
+    xmlFreeInputStream(in);
+
+    xmlHashAddEntry(globalData.entities, (const xmlChar *) URL, NULL);
+
+    return(xmlNoNetExternalEntityLoader(URL, ID, ctxt));
+}
+
+static void
+fuzzRecorderInit(FILE *out) {
+    globalData.out = out;
+    globalData.entities = xmlHashCreate(8);
+    globalData.oldLoader = xmlGetExternalEntityLoader();
+    xmlSetExternalEntityLoader(fuzzEntityRecorder);
+}
+
+static void
+fuzzRecorderCleanup() {
+    xmlSetExternalEntityLoader(globalData.oldLoader);
+    xmlHashFree(globalData.entities, xmlHashDefaultDeallocator);
+    globalData.out = NULL;
+    globalData.entities = NULL;
+    globalData.oldLoader = NULL;
+}
+
+static int
+processXml(const char *docFile, FILE *out) {
+    int opts = XML_PARSE_NOENT | XML_PARSE_DTDLOAD;
+    xmlDocPtr doc;
+
+    fwrite(&opts, sizeof(opts), 1, out);
+
+    fuzzRecorderInit(out);
+
+    doc = xmlReadFile(docFile, NULL, opts);
+    xmlXIncludeProcessFlags(doc, opts);
+    xmlFreeDoc(doc);
+
+    fuzzRecorderCleanup();
+
+    return(0);
+}
+
+static int
+processHtml(const char *docFile, FILE *out) {
+    char buf[SEED_BUF_SIZE];
+    FILE *file;
+    size_t size;
+    int opts = 0;
+
+    fwrite(&opts, sizeof(opts), 1, out);
+
+    /* Copy file */
+    file = fopen(docFile, "rb");
+    if (file == NULL) {
+        fprintf(stderr, "couldn't open %s\n", docFile);
+        return(0);
+    }
+    do {
+        size = fread(buf, 1, SEED_BUF_SIZE, file);
+        if (size > 0)
+            fwrite(buf, 1, size, out);
+    } while (size == SEED_BUF_SIZE);
+    fclose(file);
+
+    return(0);
+}
+
+static int
+processSchema(const char *docFile, FILE *out) {
+    xmlSchemaPtr schema;
+    xmlSchemaParserCtxtPtr pctxt;
+
+    fuzzRecorderInit(out);
+
+    pctxt = xmlSchemaNewParserCtxt(docFile);
+    xmlSchemaSetParserErrors(pctxt, xmlFuzzErrorFunc, xmlFuzzErrorFunc, NULL);
+    schema = xmlSchemaParse(pctxt);
+    xmlSchemaFreeParserCtxt(pctxt);
+    xmlSchemaFree(schema);
+
+    fuzzRecorderCleanup();
+
+    return(0);
+}
+
+static int
+processPattern(const char *pattern) {
+    glob_t globbuf;
+    int ret = 0;
+    int res, i;
+
+    res = glob(pattern, 0, NULL, &globbuf);
+    if (res == GLOB_NOMATCH)
+        return(0);
+    if (res != 0) {
+        fprintf(stderr, "couldn't match pattern %s\n", pattern);
+        return(-1);
+    }
+
+    for (i = 0; i < globbuf.gl_pathc; i++) {
+        struct stat statbuf;
+        char outPath[PATH_SIZE];
+        char *dirBuf = NULL;
+        char *baseBuf = NULL;
+        const char *path, *dir, *base;
+        FILE *out = NULL;
+        int dirChanged = 0;
+        size_t size;
+
+        path = globbuf.gl_pathv[i];
+
+        if ((stat(path, &statbuf) != 0) || (!S_ISREG(statbuf.st_mode)))
+            continue;
+
+        dirBuf = (char *) xmlCharStrdup(path);
+        baseBuf = (char *) xmlCharStrdup(path);
+        if ((dirBuf == NULL) || (baseBuf == NULL)) {
+            fprintf(stderr, "memory allocation failed\n");
+            ret = -1;
+            goto error;
+        }
+        dir = dirname(dirBuf);
+        base = basename(baseBuf);
+
+        size = snprintf(outPath, sizeof(outPath), "seed/%s/%s",
+                        globalData.fuzzer, base);
+        if (size >= PATH_SIZE) {
+            fprintf(stderr, "creating path failed\n");
+            ret = -1;
+            goto error;
+        }
+        out = fopen(outPath, "wb");
+        if (out == NULL) {
+            fprintf(stderr, "couldn't open %s for writing\n", outPath);
+            ret = -1;
+            goto error;
+        }
+        if (chdir(dir) != 0) {
+            fprintf(stderr, "couldn't chdir to %s\n", dir);
+            ret = -1;
+            goto error;
+        }
+        dirChanged = 1;
+        if (globalData.processFile(base, out) != 0)
+            ret = -1;
+
+error:
+        if (out != NULL)
+            fclose(out);
+        xmlFree(dirBuf);
+        xmlFree(baseBuf);
+        if ((dirChanged) && (chdir(globalData.cwd) != 0)) {
+            fprintf(stderr, "couldn't chdir to %s\n", globalData.cwd);
+            ret = -1;
+            break;
+        }
+    }
+
+    globfree(&globbuf);
+    return(ret);
+}
+
+static int
+processXPath(const char *testDir, const char *prefix, const char *name,
+             const char *data, const char *subdir, int xptr) {
+    char pattern[PATH_SIZE];
+    glob_t globbuf;
+    size_t i, size;
+    int ret = 0, res;
+
+    size = snprintf(pattern, sizeof(pattern), "%s/%s/%s*",
+                    testDir, subdir, prefix);
+    if (size >= PATH_SIZE)
+        return(-1);
+    res = glob(pattern, 0, NULL, &globbuf);
+    if (res == GLOB_NOMATCH)
+        return(0);
+    if (res != 0) {
+        fprintf(stderr, "couldn't match pattern %s\n", pattern);
+        return(-1);
+    }
+
+    for (i = 0; i < globbuf.gl_pathc; i++) {
+        char *path = globbuf.gl_pathv[i];
+        struct stat statbuf;
+        FILE *in;
+        char expr[EXPR_SIZE];
+
+        if ((stat(path, &statbuf) != 0) || (!S_ISREG(statbuf.st_mode)))
+            continue;
+
+        in = fopen(path, "rb");
+        if (in == NULL) {
+            ret = -1;
+            continue;
+        }
+
+        while (fgets(expr, EXPR_SIZE, in) > 0) {
+            char outPath[PATH_SIZE];
+            FILE *out;
+            int j;
+
+            for (j = 0; expr[j] != 0; j++)
+                if (expr[j] == '\r' || expr[j] == '\n')
+                    break;
+            expr[j] = 0;
+
+            size = snprintf(outPath, sizeof(outPath), "seed/xpath/%s-%d",
+                            name, globalData.counter);
+            if (size >= PATH_SIZE) {
+                ret = -1;
+                continue;
+            }
+            out = fopen(outPath, "wb");
+            if (out == NULL) {
+                ret = -1;
+                continue;
+            }
+
+            if (xptr) {
+                xmlFuzzWriteString(out, expr);
+            } else {
+                char xptrExpr[EXPR_SIZE+100];
+
+                /* Wrap XPath expressions as XPointer */
+                snprintf(xptrExpr, sizeof(xptrExpr), "xpointer(%s)", expr);
+                xmlFuzzWriteString(out, xptrExpr);
+            }
+
+            xmlFuzzWriteString(out, data);
+
+            fclose(out);
+            globalData.counter++;
+        }
+
+        fclose(in);
+    }
+
+    globfree(&globbuf);
+
+    return(ret);
+}
+
+int
+processXPathDir(const char *testDir) {
+    char pattern[PATH_SIZE];
+    glob_t globbuf;
+    size_t i, size;
+    int ret = 0;
+
+    globalData.counter = 1;
+    if (processXPath(testDir, "", "expr", "<d></d>", "expr", 0) != 0)
+        ret = -1;
+
+    size = snprintf(pattern, sizeof(pattern), "%s/docs/*", testDir);
+    if (size >= PATH_SIZE)
+        return(1);
+    if (glob(pattern, 0, NULL, &globbuf) != 0)
+        return(1);
+
+    for (i = 0; i < globbuf.gl_pathc; i++) {
+        char *path = globbuf.gl_pathv[i];
+        char *data;
+        const char *docFile;
+
+        data = xmlSlurpFile(path, NULL);
+        if (data == NULL) {
+            ret = -1;
+            continue;
+        }
+        docFile = basename(path);
+
+        globalData.counter = 1;
+        if (processXPath(testDir, docFile, docFile, data, "tests", 0) != 0)
+            ret = -1;
+        if (processXPath(testDir, docFile, docFile, data, "xptr", 1) != 0)
+            ret = -1;
+
+        xmlFree(data);
+    }
+
+    globfree(&globbuf);
+
+    return(ret);
+}
+
+int
+main(int argc, const char **argv) {
+    mainFunc processArg = processPattern;
+    const char *fuzzer;
+    int ret = 0;
+    int xpath = 0;
+    int i;
+
+    if (argc < 3) {
+        fprintf(stderr, "usage: seed [FUZZER] [PATTERN...]\n");
+        return(1);
+    }
+
+    xmlSetGenericErrorFunc(NULL, xmlFuzzErrorFunc);
+
+    fuzzer = argv[1];
+    if (strcmp(fuzzer, "html") == 0) {
+        globalData.processFile = processHtml;
+    } else if (strcmp(fuzzer, "schema") == 0) {
+        globalData.processFile = processSchema;
+    } else if (strcmp(fuzzer, "xml") == 0) {
+        globalData.processFile = processXml;
+    } else if (strcmp(fuzzer, "xpath") == 0) {
+        processArg = processXPathDir;
+    } else {
+        fprintf(stderr, "unknown fuzzer %s\n", fuzzer);
+        return(1);
+    }
+    globalData.fuzzer = fuzzer;
+
+    if (getcwd(globalData.cwd, PATH_SIZE) == NULL) {
+        fprintf(stderr, "couldn't get current directory\n");
+        return(1);
+    }
+
+    for (i = 2; i < argc; i++)
+        processArg(argv[i]);
+
+    return(ret);
+}
+
diff --git a/fuzz/html.c b/fuzz/html.c
new file mode 100644
index 00000000..d212c1f0
--- /dev/null
+++ b/fuzz/html.c
@@ -0,0 +1,70 @@
+/*
+ * html.c: a libFuzzer target to test several HTML parser interfaces.
+ *
+ * See Copyright for the status of this software.
+ */
+
+#include <libxml/HTMLparser.h>
+#include <libxml/HTMLtree.h>
+#include "fuzz.h"
+
+int
+LLVMFuzzerInitialize(int *argc ATTRIBUTE_UNUSED,
+                     char ***argv ATTRIBUTE_UNUSED) {
+    xmlInitParser();
+    xmlSetGenericErrorFunc(NULL, xmlFuzzErrorFunc);
+
+    return 0;
+}
+
+int
+LLVMFuzzerTestOneInput(const char *data, size_t size) {
+    static const size_t maxChunkSize = 128;
+    htmlDocPtr doc;
+    htmlParserCtxtPtr ctxt;
+    xmlChar *out;
+    const char *docBuffer;
+    size_t docSize, consumed, chunkSize;
+    int opts, outSize;
+
+    xmlFuzzDataInit(data, size);
+    opts = xmlFuzzReadInt();
+
+    docBuffer = xmlFuzzReadRemaining(&docSize);
+    if (docBuffer == NULL) {
+        xmlFuzzDataCleanup();
+        return(0);
+    }
+
+    /* Pull parser */
+
+    doc = htmlReadMemory(docBuffer, docSize, NULL, NULL, opts);
+    /* Also test the serializer. */
+    htmlDocDumpMemory(doc, &out, &outSize);
+    xmlFree(out);
+    xmlFreeDoc(doc);
+
+    /* Push parser */
+
+    ctxt = htmlCreatePushParserCtxt(NULL, NULL, NULL, 0, NULL,
+                                    XML_CHAR_ENCODING_NONE);
+    htmlCtxtUseOptions(ctxt, opts);
+
+    for (consumed = 0; consumed < docSize; consumed += chunkSize) {
+        chunkSize = docSize - consumed;
+        if (chunkSize > maxChunkSize)
+            chunkSize = maxChunkSize;
+        htmlParseChunk(ctxt, docBuffer + consumed, chunkSize, 0);
+    }
+
+    htmlParseChunk(ctxt, NULL, 0, 1);
+    xmlFreeDoc(ctxt->myDoc);
+    htmlFreeParserCtxt(ctxt);
+
+    /* Cleanup */
+
+    xmlFuzzDataCleanup();
+
+    return(0);
+}
+
diff --git a/fuzz/html.dict b/fuzz/html.dict
new file mode 100644
index 00000000..801b7bb5
--- /dev/null
+++ b/fuzz/html.dict
@@ -0,0 +1,111 @@
+elem_a="<a></a>"
+elem_abbr="<abbr></abbr>"
+elem_acronym="<acronym></acronym>"
+elem_address="<address></address>"
+elem_applet="<applet></applet>"
+elem_area="<area>"
+elem_b="<b></b>"
+elem_base="<base>"
+elem_basefont="<basefont>"
+elem_bdo="<bdo></bdo>"
+elem_big="<big></big>"
+elem_blockquote="<blockquote></blockquote>"
+elem_body="<body></body>"
+elem_br="<br>"
+elem_button="<button></button>"
+elem_caption="<caption></caption>"
+elem_center="<center></center>"
+elem_cite="<cite></cite>"
+elem_code="<code></code>"
+elem_col="<col>"
+elem_colgroup="<colgroup></colgroup>"
+elem_dd="<dd></dd>"
+elem_del="<del></del>"
+elem_dfn="<dfn></dfn>"
+elem_dir="<dir></dir>"
+elem_div="<div></div>"
+elem_dl="<dl></dl>"
+elem_dt="<dt></dt>"
+elem_em="<em></em>"
+elem_embed="<embed></embed>"
+elem_fieldset="<fieldset></fieldset>"
+elem_font="<font></font>"
+elem_form="<form></form>"
+elem_frame="<frame>"
+elem_frameset="<frameset></frameset>"
+elem_h1="<h1></h1>"
+elem_h2="<h2></h2>"
+elem_h3="<h3></h3>"
+elem_h4="<h4></h4>"
+elem_h5="<h5></h5>"
+elem_h6="<h6></h6>"
+elem_head="<head></head>"
+elem_hr="<hr>"
+elem_html="<html></html>"
+elem_i="<i></i>"
+elem_iframe="<iframe></iframe>"
+elem_img="<img>"
+elem_input="<input>"
+elem_ins="<ins></ins>"
+elem_isindex="<isindex>"
+elem_kbd="<kbd></kbd>"
+elem_label="<label></label>"
+elem_legend="<legend></legend>"
+elem_li="<li></li>"
+elem_link="<link>"
+elem_map="<map></map>"
+elem_menu="<menu></menu>"
+elem_meta="<meta>"
+elem_noframes="<noframes></noframes>"
+elem_noscript="<noscript></noscript>"
+elem_object="<object></object>"
+elem_ol="<ol></ol>"
+elem_optgroup="<optgroup></optgroup>"
+elem_option="<option></option>"
+elem_p="<p></p>"
+elem_param="<param>"
+elem_pre="<pre></pre>"
+elem_q="<q></q>"
+elem_s="<s></s>"
+elem_samp="<samp></samp>"
+elem_script="<script></script>"
+elem_select="<select></select>"
+elem_small="<small></small>"
+elem_span="<span></span>"
+elem_strike="<strike></strike>"
+elem_strong="<strong></strong>"
+elem_style="<style></style>"
+elem_sub="<sub></sub>"
+elem_sup="<sup></sup>"
+elem_table="<table></table>"
+elem_tbody="<tbody></tbody>"
+elem_td="<td></td>"
+elem_textarea="<textarea></textarea>"
+elem_tfoot="<tfoot></tfoot>"
+elem_th="<th></th>"
+elem_thead="<thead></thead>"
+elem_title="<title></title>"
+elem_tr="<tr></tr>"
+elem_tt="<tt></tt>"
+elem_u="<u></u>"
+elem_ul="<ul></ul>"
+elem_var="<var></var>"
+
+attr_id=" id=\"\""
+attr_style=" style=\"\""
+
+comment="<!-- -->"
+
+doctype="<!DOCTYPE d>"
+doctype_system="<!DOCTYPE s SYSTEM \"u\">"
+doctype_public="<!DOCTYPE p PUBLIC \"i\" \"u\">"
+
+pi="<?a?>"
+
+ref_lt="&lt;"
+ref_gt="&gt;"
+ref_amp="&amp;"
+ref_apos="&apos;"
+ref_quot="&quot;"
+ref_dec="&#9;"
+ref_hex="&#xA;"
diff --git a/fuzz/html.options b/fuzz/html.options
new file mode 100644
index 00000000..a32c583e
--- /dev/null
+++ b/fuzz/html.options
@@ -0,0 +1,3 @@
+[libfuzzer]
+max_len = 1000000
+timeout = 20
diff --git a/fuzz/regexp.c b/fuzz/regexp.c
new file mode 100644
index 00000000..3b35671b
--- /dev/null
+++ b/fuzz/regexp.c
@@ -0,0 +1,43 @@
+/*
+ * regexp.c: a libFuzzer target to test the regexp module.
+ *
+ * See Copyright for the status of this software.
+ */
+
+#include <libxml/xmlregexp.h>
+#include "fuzz.h"
+
+int
+LLVMFuzzerInitialize(int *argc ATTRIBUTE_UNUSED,
+                     char ***argv ATTRIBUTE_UNUSED) {
+    xmlSetGenericErrorFunc(NULL, xmlFuzzErrorFunc);
+
+    return 0;
+}
+
+int
+LLVMFuzzerTestOneInput(const char *data, size_t size) {
+    xmlRegexpPtr regexp;
+    char *str[2] = { NULL, NULL };
+    size_t numStrings;
+
+    numStrings = xmlFuzzExtractStrings(data, size, str, 2);
+
+    /* CUR_SCHAR doesn't handle invalid UTF-8 and may cause infinite loops. */
+    if (xmlCheckUTF8(BAD_CAST str[0]) != 0) {
+        regexp = xmlRegexpCompile(BAD_CAST str[0]);
+        /* xmlRegexpExec has pathological performance in too many cases. */
+#if 0
+        if ((regexp != NULL) && (numStrings >= 2)) {
+            xmlRegexpExec(regexp, BAD_CAST str[1]);
+        }
+#endif
+        xmlRegFreeRegexp(regexp);
+    }
+
+    xmlFree(str[0]);
+    xmlFree(str[1]);
+
+    return 0;
+}
+
diff --git a/fuzz/regexp.dict b/fuzz/regexp.dict
new file mode 100644
index 00000000..30d666dc
--- /dev/null
+++ b/fuzz/regexp.dict
@@ -0,0 +1,155 @@
+quant_any="*"
+quant_opt="?"
+quant_some="+"
+quant_num="{1,2}"
+
+dot="."
+branch="|a"
+parens="()"
+parens_inner=")("
+pos_group="[a]"
+neg_group="[^a]"
+class_subtraction="[a-[b]]"
+
+esc_space="\\s"
+esc_initial="\\i"
+esc_name="\\c"
+esc_digit="\\d"
+esc_word="\\w"
+
+cat_letter="\\p{L}"
+cat_mark="\\p{M}"
+cat_number="\\p{N}"
+cat_punct="\\p{P}"
+cat_sym="\\p{S}"
+cat_sep="\\p{Z}"
+cat_other="\\p{C}"
+
+block_aegean_numbers="\\p{IsAegeanNumbers}"
+block_alphabetic_presentation_forms="\\p{IsAlphabeticPresentationForms}"
+block_arabic="\\p{IsArabic}"
+block_arabic_presentation_forms_a="\\p{IsArabicPresentationFormsA}"
+block_arabic_presentation_forms_b="\\p{IsArabicPresentationFormsB}"
+block_armenian="\\p{IsArmenian}"
+block_arrows="\\p{IsArrows}"
+block_basic_latin="\\p{IsBasicLatin}"
+block_bengali="\\p{IsBengali}"
+block_block_elements="\\p{IsBlockElements}"
+block_bopomofo="\\p{IsBopomofo}"
+block_bopomofo_extended="\\p{IsBopomofoExtended}"
+block_box_drawing="\\p{IsBoxDrawing}"
+block_braille_patterns="\\p{IsBraillePatterns}"
+block_buhid="\\p{IsBuhid}"
+block_byzantine_musical_symbols="\\p{IsByzantineMusicalSymbols}"
+block_c_j_k_compatibility="\\p{IsCJKCompatibility}"
+block_c_j_k_compatibility_forms="\\p{IsCJKCompatibilityForms}"
+block_c_j_k_compatibility_ideographs="\\p{IsCJKCompatibilityIdeographs}"
+block_c_j_k_compatibility_ideographs_supplement="\\p{IsCJKCompatibilityIdeographsSupplement}"
+block_c_j_k_radicals_supplement="\\p{IsCJKRadicalsSupplement}"
+block_c_j_k_symbolsand_punctuation="\\p{IsCJKSymbolsandPunctuation}"
+block_c_j_k_unified_ideographs="\\p{IsCJKUnifiedIdeographs}"
+block_c_j_k_unified_ideographs_extension_a="\\p{IsCJKUnifiedIdeographsExtensionA}"
+block_cjk_unified_ideographs_extension_b="\\p{IsCJKUnifiedIdeographsExtensionB}"
+block_cherokee="\\p{IsCherokee}"
+block_combining_diacritical_marks="\\p{IsCombiningDiacriticalMarks}"
+block_combining_diacritical_marksfor_symbols="\\p{IsCombiningDiacriticalMarksforSymbols}"
+block_combining_half_marks="\\p{IsCombiningHalfMarks}"
+block_combining_marksfor_symbols="\\p{IsCombiningMarksforSymbols}"
+block_control_pictures="\\p{IsControlPictures}"
+block_currency_symbols="\\p{IsCurrencySymbols}"
+block_cypriot_syllabary="\\p{IsCypriotSyllabary}"
+block_cyrillic="\\p{IsCyrillic}"
+block_cyrillic_supplement="\\p{IsCyrillicSupplement}"
+block_deseret="\\p{IsDeseret}"
+block_devanagari="\\p{IsDevanagari}"
+block_dingbats="\\p{IsDingbats}"
+block_enclosed_alphanumerics="\\p{IsEnclosedAlphanumerics}"
+block_enclosed_cjk_lettersand_months="\\p{IsEnclosedCJKLettersandMonths}"
+block_ethiopic="\\p{IsEthiopic}"
+block_general_punctuation="\\p{IsGeneralPunctuation}"
+block_geometric_shapes="\\p{IsGeometricShapes}"
+block_georgian="\\p{IsGeorgian}"
+block_gothic="\\p{IsGothic}"
+block_greek="\\p{IsGreek}"
+block_greek_extended="\\p{IsGreekExtended}"
+block_greekand_coptic="\\p{IsGreekandCoptic}"
+block_gujarati="\\p{IsGujarati}"
+block_gurmukhi="\\p{IsGurmukhi}"
+block_halfwidthand_fullwidth_forms="\\p{IsHalfwidthandFullwidthForms}"
+block_hangul_compatibility_jamo="\\p{IsHangulCompatibilityJamo}"
+block_hangul_jamo="\\p{IsHangulJamo}"
+block_hangul_syllables="\\p{IsHangulSyllables}"
+block_hanunoo="\\p{IsHanunoo}"
+block_hebrew="\\p{IsHebrew}"
+block_high_private_use_surrogates="\\p{IsHighPrivateUseSurrogates}"
+block_high_surrogates="\\p{IsHighSurrogates}"
+block_hiragana="\\p{IsHiragana}"
+block_ipa_extensions="\\p{IsIPAExtensions}"
+block_ideographic_description_characters="\\p{IsIdeographicDescriptionCharacters}"
+block_kanbun="\\p{IsKanbun}"
+block_kangxi_radicals="\\p{IsKangxiRadicals}"
+block_kannada="\\p{IsKannada}"
+block_katakana="\\p{IsKatakana}"
+block_katakana_phonetic_extensions="\\p{IsKatakanaPhoneticExtensions}"
+block_khmer="\\p{IsKhmer}"
+block_khmer_symbols="\\p{IsKhmerSymbols}"
+block_lao="\\p{IsLao}"
+block_latin1Supplement="\\p{IsLatin1Supplement}"
+block_latin_extended_a="\\p{IsLatinExtendedA}"
+block_latin_extended_b="\\p{IsLatinExtendedB}"
+block_latin_extended_additional="\\p{IsLatinExtendedAdditional}"
+block_letterlike_symbols="\\p{IsLetterlikeSymbols}"
+block_limbu="\\p{IsLimbu}"
+block_linear_b_ideograms="\\p{IsLinearBIdeograms}"
+block_linear_b_syllabary="\\p{IsLinearBSyllabary}"
+block_low_surrogates="\\p{IsLowSurrogates}"
+block_malayalam="\\p{IsMalayalam}"
+block_mathematical_alphanumeric_symbols="\\p{IsMathematicalAlphanumericSymbols}"
+block_mathematical_operators="\\p{IsMathematicalOperators}"
+block_miscellaneous_mathematical_symbols_a="\\p{IsMiscellaneousMathematicalSymbolsA}"
+block_miscellaneous_mathematical_symbols_b="\\p{IsMiscellaneousMathematicalSymbolsB}"
+block_miscellaneous_symbols="\\p{IsMiscellaneousSymbols}"
+block_miscellaneous_symbolsand_arrows="\\p{IsMiscellaneousSymbolsandArrows}"
+block_miscellaneous_technical="\\p{IsMiscellaneousTechnical}"
+block_mongolian="\\p{IsMongolian}"
+block_musical_symbols="\\p{IsMusicalSymbols}"
+block_myanmar="\\p{IsMyanmar}"
+block_number_forms="\\p{IsNumberForms}"
+block_ogham="\\p{IsOgham}"
+block_old_italic="\\p{IsOldItalic}"
+block_optical_character_recognition="\\p{IsOpticalCharacterRecognition}"
+block_oriya="\\p{IsOriya}"
+block_osmanya="\\p{IsOsmanya}"
+block_phonetic_extensions="\\p{IsPhoneticExtensions}"
+block_private_use="\\p{IsPrivateUse}"
+block_private_use_area="\\p{IsPrivateUseArea}"
+block_runic="\\p{IsRunic}"
+block_shavian="\\p{IsShavian}"
+block_sinhala="\\p{IsSinhala}"
+block_small_form_variants="\\p{IsSmallFormVariants}"
+block_spacing_modifier_letters="\\p{IsSpacingModifierLetters}"
+block_specials="\\p{IsSpecials}"
+block_superscriptsand_subscripts="\\p{IsSuperscriptsandSubscripts}"
+block_supplemental_arrows_a="\\p{IsSupplementalArrowsA}"
+block_supplemental_arrows_b="\\p{IsSupplementalArrowsB}"
+block_supplemental_mathematical_operators="\\p{IsSupplementalMathematicalOperators}"
+block_supplementary_private_use_area_a="\\p{IsSupplementaryPrivateUseAreaA}"
+block_supplementary_private_use_area_b="\\p{IsSupplementaryPrivateUseAreaB}"
+block_syriac="\\p{IsSyriac}"
+block_tagalog="\\p{IsTagalog}"
+block_tagbanwa="\\p{IsTagbanwa}"
+block_tags="\\p{IsTags}"
+block_tai_le="\\p{IsTaiLe}"
+block_tai_xuan_jing_symbols="\\p{IsTaiXuanJingSymbols}"
+block_tamil="\\p{IsTamil}"
+block_telugu="\\p{IsTelugu}"
+block_thaana="\\p{IsThaana}"
+block_thai="\\p{IsThai}"
+block_tibetan="\\p{IsTibetan}"
+block_ugaritic="\\p{IsUgaritic}"
+block_unified_canadian_aboriginal_syllabics="\\p{IsUnifiedCanadianAboriginalSyllabics}"
+block_variation_selectors="\\p{IsVariationSelectors}"
+block_variation_selectors_supplement="\\p{IsVariationSelectorsSupplement}"
+block_yi_radicals="\\p{IsYiRadicals}"
+block_yi_syllables="\\p{IsYiSyllables}"
+block_yijing_hexagram_symbols="\\p{IsYijingHexagramSymbols}"
diff --git a/fuzz/regexp.options b/fuzz/regexp.options
new file mode 100644
index 00000000..09b9e6f0
--- /dev/null
+++ b/fuzz/regexp.options
@@ -0,0 +1,3 @@
+[libfuzzer]
+max_len = 200
+timeout = 5
diff --git a/fuzz/schema.c b/fuzz/schema.c
new file mode 100644
index 00000000..f1ee9380
--- /dev/null
+++ b/fuzz/schema.c
@@ -0,0 +1,36 @@
+/*
+ * schema.c: a libFuzzer target to test the XML Schema processor.
+ *
+ * See Copyright for the status of this software.
+ */
+
+#include <libxml/xmlschemas.h>
+#include "fuzz.h"
+
+int
+LLVMFuzzerInitialize(int *argc ATTRIBUTE_UNUSED,
+                     char ***argv ATTRIBUTE_UNUSED) {
+    xmlInitParser();
+    xmlSetGenericErrorFunc(NULL, xmlFuzzErrorFunc);
+    xmlSetExternalEntityLoader(xmlFuzzEntityLoader);
+
+    return 0;
+}
+
+int
+LLVMFuzzerTestOneInput(const char *data, size_t size) {
+    xmlSchemaParserCtxtPtr pctxt;
+
+    xmlFuzzDataInit(data, size);
+    xmlFuzzReadEntities();
+
+    pctxt = xmlSchemaNewParserCtxt(xmlFuzzMainUrl());
+    xmlSchemaSetParserErrors(pctxt, xmlFuzzErrorFunc, xmlFuzzErrorFunc, NULL);
+    xmlSchemaFree(xmlSchemaParse(pctxt));
+    xmlSchemaFreeParserCtxt(pctxt);
+
+    xmlFuzzDataCleanup();
+
+    return(0);
+}
+
diff --git a/fuzz/schema.dict b/fuzz/schema.dict
new file mode 100644
index 00000000..9a8fd386
--- /dev/null
+++ b/fuzz/schema.dict
@@ -0,0 +1,55 @@
+# TODO: Add more language elements
+
+xs_annotation="<xs:annotation></xs:annotation>"
+
+xs_attribute="<xs:attribute name='a'></xs:attribute>"
+xs_attribute_required="<xs:attribute name='a' use='required'></xs:attribute>"
+xs_element="<xs:element name='e'></xs:element>"
+
+# Primitive datatypes
+type_string=" type='xs:string'"
+type_boolean=" type='xs:boolean'"
+type_decimal=" type='xs:decimal'"
+type_float=" type='xs:float'"
+type_double=" type='xs:double'"
+type_date_time=" type='xs:dateTime'"
+type_time=" type='xs:time'"
+type_date=" type='xs:date'"
+type_g_year_month=" type='xs:gYearMonth'"
+type_g_year=" type='xs:gYear'"
+type_g_month_day=" type='xs:gMonthDay'"
+type_g_day=" type='xs:gDay'"
+type_g_month=" type='xs:gMonth'"
+type_hex_binary=" type='xs:hexBinary'"
+type_base64_binary=" type='xs:base64Binary'"
+type_any_uri=" type='xs:anyURI'"
+type_qname=" type='xs:QName'"
+type_notation=" type='xs:NOTATION'"
+
+# Occurs
+occurs_min=" minOccurs='1'"
+occurs_max=" maxOccurs='9'"
+occurs_max_unbounded=" maxOccurs='unbounded'"
+
+# Simple type
+xs_restriction_integer="<xs:simpleType><xs:restriction base='xs:integer'></xs:restriction></xs:simpleType>"
+xs_restriction_string="<xs:simpleType><xs:restriction base='xs:string'></xs:restriction></xs:simpleType>"
+xs_list="<xs:simpleType><xs:list></xs:list></xs:simpleType>"
+xs_union="<xs:simpleType><xs:union></xs:union></xs:simpleType>"
+
+# Restrictions
+xs_min_exclusive="<xs:minExclusive value='0'/>"
+xs_min_inclusive="<xs:minInclusive value='0'/>"
+xs_max_exclusive="<xs:maxExclusive value='9'/>"
+xs_max_inclusive="<xs:maxInclusive value='9'/>"
+xs_total_digits="<xs:totalDigits value='3'/>"
+xs_fraction_digits="<xs:fractionDigits value='3'/>"
+xs_length="<xs:length value='3'/>"
+xs_min_length="<xs:minLength value='3'/>"
+xs_max_length="<xs:maxLength value='3'/>"
+xs_enumeration="<xs:enumeration value='a'/>"
+xs_white_space_collapse="<xs:whiteSpace value='collapse'/>"
+xs_white_space_preserve="<xs:whiteSpace value='preserve'/>"
+xs_white_space_replace="<xs:whiteSpace value='replace'/>"
+xs_pattern="<xs:pattern value='a'/>"
+
diff --git a/fuzz/schema.options b/fuzz/schema.options
new file mode 100644
index 00000000..195ec544
--- /dev/null
+++ b/fuzz/schema.options
@@ -0,0 +1,3 @@
+[libfuzzer]
+max_len = 80000
+timeout = 20
diff --git a/fuzz/seed/regexp/branch-1 b/fuzz/seed/regexp/branch-1
new file mode 100644
index 00000000..ded775ea
Binary files /dev/null and b/fuzz/seed/regexp/branch-1 differ
diff --git a/fuzz/seed/regexp/branch-10 b/fuzz/seed/regexp/branch-10
new file mode 100644
index 00000000..6700d775
Binary files /dev/null and b/fuzz/seed/regexp/branch-10 differ
diff --git a/fuzz/seed/regexp/branch-11 b/fuzz/seed/regexp/branch-11
new file mode 100644
index 00000000..d83f9181
Binary files /dev/null and b/fuzz/seed/regexp/branch-11 differ
diff --git a/fuzz/seed/regexp/branch-12 b/fuzz/seed/regexp/branch-12
new file mode 100644
index 00000000..b44dba57
Binary files /dev/null and b/fuzz/seed/regexp/branch-12 differ
diff --git a/fuzz/seed/regexp/branch-13 b/fuzz/seed/regexp/branch-13
new file mode 100644
index 00000000..64e50a00
Binary files /dev/null and b/fuzz/seed/regexp/branch-13 differ
diff --git a/fuzz/seed/regexp/branch-2 b/fuzz/seed/regexp/branch-2
new file mode 100644
index 00000000..8293d81d
Binary files /dev/null and b/fuzz/seed/regexp/branch-2 differ
diff --git a/fuzz/seed/regexp/branch-3 b/fuzz/seed/regexp/branch-3
new file mode 100644
index 00000000..696af9be
Binary files /dev/null and b/fuzz/seed/regexp/branch-3 differ
diff --git a/fuzz/seed/regexp/branch-4 b/fuzz/seed/regexp/branch-4
new file mode 100644
index 00000000..83179988
Binary files /dev/null and b/fuzz/seed/regexp/branch-4 differ
diff --git a/fuzz/seed/regexp/branch-5 b/fuzz/seed/regexp/branch-5
new file mode 100644
index 00000000..6b6db8b9
Binary files /dev/null and b/fuzz/seed/regexp/branch-5 differ
diff --git a/fuzz/seed/regexp/branch-6 b/fuzz/seed/regexp/branch-6
new file mode 100644
index 00000000..4f477902
Binary files /dev/null and b/fuzz/seed/regexp/branch-6 differ
diff --git a/fuzz/seed/regexp/branch-7 b/fuzz/seed/regexp/branch-7
new file mode 100644
index 00000000..6334f725
Binary files /dev/null and b/fuzz/seed/regexp/branch-7 differ
diff --git a/fuzz/seed/regexp/branch-8 b/fuzz/seed/regexp/branch-8
new file mode 100644
index 00000000..f77a8f4d
Binary files /dev/null and b/fuzz/seed/regexp/branch-8 differ
diff --git a/fuzz/seed/regexp/branch-9 b/fuzz/seed/regexp/branch-9
new file mode 100644
index 00000000..acd0eeca
Binary files /dev/null and b/fuzz/seed/regexp/branch-9 differ
diff --git a/fuzz/seed/regexp/bug316338-1 b/fuzz/seed/regexp/bug316338-1
new file mode 100644
index 00000000..9f0a504a
Binary files /dev/null and b/fuzz/seed/regexp/bug316338-1 differ
diff --git a/fuzz/seed/regexp/bug316338-10 b/fuzz/seed/regexp/bug316338-10
new file mode 100644
index 00000000..60685bbe
Binary files /dev/null and b/fuzz/seed/regexp/bug316338-10 differ
diff --git a/fuzz/seed/regexp/bug316338-11 b/fuzz/seed/regexp/bug316338-11
new file mode 100644
index 00000000..72a7956c
Binary files /dev/null and b/fuzz/seed/regexp/bug316338-11 differ
diff --git a/fuzz/seed/regexp/bug316338-12 b/fuzz/seed/regexp/bug316338-12
new file mode 100644
index 00000000..85416ee2
Binary files /dev/null and b/fuzz/seed/regexp/bug316338-12 differ
diff --git a/fuzz/seed/regexp/bug316338-13 b/fuzz/seed/regexp/bug316338-13
new file mode 100644
index 00000000..c91d4fea
Binary files /dev/null and b/fuzz/seed/regexp/bug316338-13 differ
diff --git a/fuzz/seed/regexp/bug316338-14 b/fuzz/seed/regexp/bug316338-14
new file mode 100644
index 00000000..a164b423
Binary files /dev/null and b/fuzz/seed/regexp/bug316338-14 differ
diff --git a/fuzz/seed/regexp/bug316338-15 b/fuzz/seed/regexp/bug316338-15
new file mode 100644
index 00000000..750c76de
Binary files /dev/null and b/fuzz/seed/regexp/bug316338-15 differ
diff --git a/fuzz/seed/regexp/bug316338-16 b/fuzz/seed/regexp/bug316338-16
new file mode 100644
index 00000000..23c5d230
Binary files /dev/null and b/fuzz/seed/regexp/bug316338-16 differ
diff --git a/fuzz/seed/regexp/bug316338-2 b/fuzz/seed/regexp/bug316338-2
new file mode 100644
index 00000000..5468d06d
Binary files /dev/null and b/fuzz/seed/regexp/bug316338-2 differ
diff --git a/fuzz/seed/regexp/bug316338-3 b/fuzz/seed/regexp/bug316338-3
new file mode 100644
index 00000000..76e1e0bc
Binary files /dev/null and b/fuzz/seed/regexp/bug316338-3 differ
diff --git a/fuzz/seed/regexp/bug316338-4 b/fuzz/seed/regexp/bug316338-4
new file mode 100644
index 00000000..e0f65a42
Binary files /dev/null and b/fuzz/seed/regexp/bug316338-4 differ
diff --git a/fuzz/seed/regexp/bug316338-5 b/fuzz/seed/regexp/bug316338-5
new file mode 100644
index 00000000..fcfaa97a
Binary files /dev/null and b/fuzz/seed/regexp/bug316338-5 differ
diff --git a/fuzz/seed/regexp/bug316338-6 b/fuzz/seed/regexp/bug316338-6
new file mode 100644
index 00000000..ce00a15b
Binary files /dev/null and b/fuzz/seed/regexp/bug316338-6 differ
diff --git a/fuzz/seed/regexp/bug316338-7 b/fuzz/seed/regexp/bug316338-7
new file mode 100644
index 00000000..127fe1f6
Binary files /dev/null and b/fuzz/seed/regexp/bug316338-7 differ
diff --git a/fuzz/seed/regexp/bug316338-8 b/fuzz/seed/regexp/bug316338-8
new file mode 100644
index 00000000..fe8bb8b2
Binary files /dev/null and b/fuzz/seed/regexp/bug316338-8 differ
diff --git a/fuzz/seed/regexp/bug316338-9 b/fuzz/seed/regexp/bug316338-9
new file mode 100644
index 00000000..3d56e5d7
Binary files /dev/null and b/fuzz/seed/regexp/bug316338-9 differ
diff --git a/fuzz/seed/regexp/bug420596-1 b/fuzz/seed/regexp/bug420596-1
new file mode 100644
index 00000000..4426933e
Binary files /dev/null and b/fuzz/seed/regexp/bug420596-1 differ
diff --git a/fuzz/seed/regexp/bug420596-2 b/fuzz/seed/regexp/bug420596-2
new file mode 100644
index 00000000..474d2b6e
Binary files /dev/null and b/fuzz/seed/regexp/bug420596-2 differ
diff --git a/fuzz/seed/regexp/bug420596-3 b/fuzz/seed/regexp/bug420596-3
new file mode 100644
index 00000000..09c75cb6
Binary files /dev/null and b/fuzz/seed/regexp/bug420596-3 differ
diff --git a/fuzz/seed/regexp/bug420596-4 b/fuzz/seed/regexp/bug420596-4
new file mode 100644
index 00000000..65d561ea
Binary files /dev/null and b/fuzz/seed/regexp/bug420596-4 differ
diff --git a/fuzz/seed/regexp/bug420596-5 b/fuzz/seed/regexp/bug420596-5
new file mode 100644
index 00000000..b6785803
Binary files /dev/null and b/fuzz/seed/regexp/bug420596-5 differ
diff --git a/fuzz/seed/regexp/bug420596-6 b/fuzz/seed/regexp/bug420596-6
new file mode 100644
index 00000000..3a05d82f
Binary files /dev/null and b/fuzz/seed/regexp/bug420596-6 differ
diff --git a/fuzz/seed/regexp/bug420596-7 b/fuzz/seed/regexp/bug420596-7
new file mode 100644
index 00000000..88e16605
Binary files /dev/null and b/fuzz/seed/regexp/bug420596-7 differ
diff --git a/fuzz/seed/regexp/bug420596-8 b/fuzz/seed/regexp/bug420596-8
new file mode 100644
index 00000000..4575a925
Binary files /dev/null and b/fuzz/seed/regexp/bug420596-8 differ
diff --git a/fuzz/seed/regexp/content-1 b/fuzz/seed/regexp/content-1
new file mode 100644
index 00000000..5acbf864
Binary files /dev/null and b/fuzz/seed/regexp/content-1 differ
diff --git a/fuzz/seed/regexp/content-10 b/fuzz/seed/regexp/content-10
new file mode 100644
index 00000000..f131454c
Binary files /dev/null and b/fuzz/seed/regexp/content-10 differ
diff --git a/fuzz/seed/regexp/content-2 b/fuzz/seed/regexp/content-2
new file mode 100644
index 00000000..4e6b663e
Binary files /dev/null and b/fuzz/seed/regexp/content-2 differ
diff --git a/fuzz/seed/regexp/content-3 b/fuzz/seed/regexp/content-3
new file mode 100644
index 00000000..b13fc8db
Binary files /dev/null and b/fuzz/seed/regexp/content-3 differ
diff --git a/fuzz/seed/regexp/content-4 b/fuzz/seed/regexp/content-4
new file mode 100644
index 00000000..47c5d6de
Binary files /dev/null and b/fuzz/seed/regexp/content-4 differ
diff --git a/fuzz/seed/regexp/content-5 b/fuzz/seed/regexp/content-5
new file mode 100644
index 00000000..f93860eb
Binary files /dev/null and b/fuzz/seed/regexp/content-5 differ
diff --git a/fuzz/seed/regexp/content-6 b/fuzz/seed/regexp/content-6
new file mode 100644
index 00000000..e5c6e14b
Binary files /dev/null and b/fuzz/seed/regexp/content-6 differ
diff --git a/fuzz/seed/regexp/content-7 b/fuzz/seed/regexp/content-7
new file mode 100644
index 00000000..4868dd2f
Binary files /dev/null and b/fuzz/seed/regexp/content-7 differ
diff --git a/fuzz/seed/regexp/content-8 b/fuzz/seed/regexp/content-8
new file mode 100644
index 00000000..a3a87d0b
Binary files /dev/null and b/fuzz/seed/regexp/content-8 differ
diff --git a/fuzz/seed/regexp/content-9 b/fuzz/seed/regexp/content-9
new file mode 100644
index 00000000..91f0d9e9
Binary files /dev/null and b/fuzz/seed/regexp/content-9 differ
diff --git a/fuzz/seed/regexp/hard-1 b/fuzz/seed/regexp/hard-1
new file mode 100644
index 00000000..ba00382e
Binary files /dev/null and b/fuzz/seed/regexp/hard-1 differ
diff --git a/fuzz/seed/regexp/hard-10 b/fuzz/seed/regexp/hard-10
new file mode 100644
index 00000000..7db28fa5
Binary files /dev/null and b/fuzz/seed/regexp/hard-10 differ
diff --git a/fuzz/seed/regexp/hard-2 b/fuzz/seed/regexp/hard-2
new file mode 100644
index 00000000..ed38b91b
Binary files /dev/null and b/fuzz/seed/regexp/hard-2 differ
diff --git a/fuzz/seed/regexp/hard-3 b/fuzz/seed/regexp/hard-3
new file mode 100644
index 00000000..7b16da0c
Binary files /dev/null and b/fuzz/seed/regexp/hard-3 differ
diff --git a/fuzz/seed/regexp/hard-4 b/fuzz/seed/regexp/hard-4
new file mode 100644
index 00000000..2ece886a
Binary files /dev/null and b/fuzz/seed/regexp/hard-4 differ
diff --git a/fuzz/seed/regexp/hard-5 b/fuzz/seed/regexp/hard-5
new file mode 100644
index 00000000..870a3ec5
Binary files /dev/null and b/fuzz/seed/regexp/hard-5 differ
diff --git a/fuzz/seed/regexp/hard-6 b/fuzz/seed/regexp/hard-6
new file mode 100644
index 00000000..06aa7d0d
Binary files /dev/null and b/fuzz/seed/regexp/hard-6 differ
diff --git a/fuzz/seed/regexp/hard-7 b/fuzz/seed/regexp/hard-7
new file mode 100644
index 00000000..50a9ec39
Binary files /dev/null and b/fuzz/seed/regexp/hard-7 differ
diff --git a/fuzz/seed/regexp/hard-8 b/fuzz/seed/regexp/hard-8
new file mode 100644
index 00000000..0991129f
Binary files /dev/null and b/fuzz/seed/regexp/hard-8 differ
diff --git a/fuzz/seed/regexp/hard-9 b/fuzz/seed/regexp/hard-9
new file mode 100644
index 00000000..5bd1d890
Binary files /dev/null and b/fuzz/seed/regexp/hard-9 differ
diff --git a/fuzz/seed/regexp/ncname-1 b/fuzz/seed/regexp/ncname-1
new file mode 100644
index 00000000..608eb9a9
Binary files /dev/null and b/fuzz/seed/regexp/ncname-1 differ
diff --git a/fuzz/seed/regexp/ncname-2 b/fuzz/seed/regexp/ncname-2
new file mode 100644
index 00000000..cfb9b960
Binary files /dev/null and b/fuzz/seed/regexp/ncname-2 differ
diff --git a/fuzz/seed/regexp/ncname-3 b/fuzz/seed/regexp/ncname-3
new file mode 100644
index 00000000..07a6a081
Binary files /dev/null and b/fuzz/seed/regexp/ncname-3 differ
diff --git a/fuzz/seed/regexp/ncname-4 b/fuzz/seed/regexp/ncname-4
new file mode 100644
index 00000000..87e937f4
Binary files /dev/null and b/fuzz/seed/regexp/ncname-4 differ
diff --git a/fuzz/seed/regexp/ncname-5 b/fuzz/seed/regexp/ncname-5
new file mode 100644
index 00000000..ad294560
Binary files /dev/null and b/fuzz/seed/regexp/ncname-5 differ
diff --git a/fuzz/seed/regexp/ranges-1 b/fuzz/seed/regexp/ranges-1
new file mode 100644
index 00000000..71448f23
Binary files /dev/null and b/fuzz/seed/regexp/ranges-1 differ
diff --git a/fuzz/seed/regexp/ranges-10 b/fuzz/seed/regexp/ranges-10
new file mode 100644
index 00000000..91aed3cf
Binary files /dev/null and b/fuzz/seed/regexp/ranges-10 differ
diff --git a/fuzz/seed/regexp/ranges-11 b/fuzz/seed/regexp/ranges-11
new file mode 100644
index 00000000..76eb5deb
Binary files /dev/null and b/fuzz/seed/regexp/ranges-11 differ
diff --git a/fuzz/seed/regexp/ranges-12 b/fuzz/seed/regexp/ranges-12
new file mode 100644
index 00000000..9c3bc663
Binary files /dev/null and b/fuzz/seed/regexp/ranges-12 differ
diff --git a/fuzz/seed/regexp/ranges-2 b/fuzz/seed/regexp/ranges-2
new file mode 100644
index 00000000..9369f7a5
Binary files /dev/null and b/fuzz/seed/regexp/ranges-2 differ
diff --git a/fuzz/seed/regexp/ranges-3 b/fuzz/seed/regexp/ranges-3
new file mode 100644
index 00000000..58a3a081
Binary files /dev/null and b/fuzz/seed/regexp/ranges-3 differ
diff --git a/fuzz/seed/regexp/ranges-4 b/fuzz/seed/regexp/ranges-4
new file mode 100644
index 00000000..da7e9dab
Binary files /dev/null and b/fuzz/seed/regexp/ranges-4 differ
diff --git a/fuzz/seed/regexp/ranges-5 b/fuzz/seed/regexp/ranges-5
new file mode 100644
index 00000000..83ad4a82
Binary files /dev/null and b/fuzz/seed/regexp/ranges-5 differ
diff --git a/fuzz/seed/regexp/ranges-6 b/fuzz/seed/regexp/ranges-6
new file mode 100644
index 00000000..3bc9758f
Binary files /dev/null and b/fuzz/seed/regexp/ranges-6 differ
diff --git a/fuzz/seed/regexp/ranges-7 b/fuzz/seed/regexp/ranges-7
new file mode 100644
index 00000000..fa890384
Binary files /dev/null and b/fuzz/seed/regexp/ranges-7 differ
diff --git a/fuzz/seed/regexp/ranges-8 b/fuzz/seed/regexp/ranges-8
new file mode 100644
index 00000000..96f0bb69
Binary files /dev/null and b/fuzz/seed/regexp/ranges-8 differ
diff --git a/fuzz/seed/regexp/ranges-9 b/fuzz/seed/regexp/ranges-9
new file mode 100644
index 00000000..8e3fc43a
Binary files /dev/null and b/fuzz/seed/regexp/ranges-9 differ
diff --git a/fuzz/seed/regexp/ranges2-1 b/fuzz/seed/regexp/ranges2-1
new file mode 100644
index 00000000..044a8eb9
Binary files /dev/null and b/fuzz/seed/regexp/ranges2-1 differ
diff --git a/fuzz/seed/regexp/ranges2-10 b/fuzz/seed/regexp/ranges2-10
new file mode 100644
index 00000000..19e2aa2d
Binary files /dev/null and b/fuzz/seed/regexp/ranges2-10 differ
diff --git a/fuzz/seed/regexp/ranges2-11 b/fuzz/seed/regexp/ranges2-11
new file mode 100644
index 00000000..89be181d
Binary files /dev/null and b/fuzz/seed/regexp/ranges2-11 differ
diff --git a/fuzz/seed/regexp/ranges2-12 b/fuzz/seed/regexp/ranges2-12
new file mode 100644
index 00000000..42ebdd31
Binary files /dev/null and b/fuzz/seed/regexp/ranges2-12 differ
diff --git a/fuzz/seed/regexp/ranges2-2 b/fuzz/seed/regexp/ranges2-2
new file mode 100644
index 00000000..026f7b84
Binary files /dev/null and b/fuzz/seed/regexp/ranges2-2 differ
diff --git a/fuzz/seed/regexp/ranges2-3 b/fuzz/seed/regexp/ranges2-3
new file mode 100644
index 00000000..83e78a9c
Binary files /dev/null and b/fuzz/seed/regexp/ranges2-3 differ
diff --git a/fuzz/seed/regexp/ranges2-4 b/fuzz/seed/regexp/ranges2-4
new file mode 100644
index 00000000..847b4e84
Binary files /dev/null and b/fuzz/seed/regexp/ranges2-4 differ
diff --git a/fuzz/seed/regexp/ranges2-5 b/fuzz/seed/regexp/ranges2-5
new file mode 100644
index 00000000..349168d3
Binary files /dev/null and b/fuzz/seed/regexp/ranges2-5 differ
diff --git a/fuzz/seed/regexp/ranges2-6 b/fuzz/seed/regexp/ranges2-6
new file mode 100644
index 00000000..5d2a4076
Binary files /dev/null and b/fuzz/seed/regexp/ranges2-6 differ
diff --git a/fuzz/seed/regexp/ranges2-7 b/fuzz/seed/regexp/ranges2-7
new file mode 100644
index 00000000..74fbafb4
Binary files /dev/null and b/fuzz/seed/regexp/ranges2-7 differ
diff --git a/fuzz/seed/regexp/ranges2-8 b/fuzz/seed/regexp/ranges2-8
new file mode 100644
index 00000000..125bfa91
Binary files /dev/null and b/fuzz/seed/regexp/ranges2-8 differ
diff --git a/fuzz/seed/regexp/ranges2-9 b/fuzz/seed/regexp/ranges2-9
new file mode 100644
index 00000000..f2cf1288
Binary files /dev/null and b/fuzz/seed/regexp/ranges2-9 differ
diff --git a/fuzz/seed/regexp/xpath-1 b/fuzz/seed/regexp/xpath-1
new file mode 100644
index 00000000..3bc17926
Binary files /dev/null and b/fuzz/seed/regexp/xpath-1 differ
diff --git a/fuzz/seed/regexp/xpath-10 b/fuzz/seed/regexp/xpath-10
new file mode 100644
index 00000000..e4f4b0cd
Binary files /dev/null and b/fuzz/seed/regexp/xpath-10 differ
diff --git a/fuzz/seed/regexp/xpath-11 b/fuzz/seed/regexp/xpath-11
new file mode 100644
index 00000000..318e0ccf
Binary files /dev/null and b/fuzz/seed/regexp/xpath-11 differ
diff --git a/fuzz/seed/regexp/xpath-12 b/fuzz/seed/regexp/xpath-12
new file mode 100644
index 00000000..f204295b
Binary files /dev/null and b/fuzz/seed/regexp/xpath-12 differ
diff --git a/fuzz/seed/regexp/xpath-13 b/fuzz/seed/regexp/xpath-13
new file mode 100644
index 00000000..70fccd59
Binary files /dev/null and b/fuzz/seed/regexp/xpath-13 differ
diff --git a/fuzz/seed/regexp/xpath-14 b/fuzz/seed/regexp/xpath-14
new file mode 100644
index 00000000..357ce2b5
Binary files /dev/null and b/fuzz/seed/regexp/xpath-14 differ
diff --git a/fuzz/seed/regexp/xpath-15 b/fuzz/seed/regexp/xpath-15
new file mode 100644
index 00000000..2a10a837
Binary files /dev/null and b/fuzz/seed/regexp/xpath-15 differ
diff --git a/fuzz/seed/regexp/xpath-16 b/fuzz/seed/regexp/xpath-16
new file mode 100644
index 00000000..1f3089fb
Binary files /dev/null and b/fuzz/seed/regexp/xpath-16 differ
diff --git a/fuzz/seed/regexp/xpath-17 b/fuzz/seed/regexp/xpath-17
new file mode 100644
index 00000000..a9d542fb
Binary files /dev/null and b/fuzz/seed/regexp/xpath-17 differ
diff --git a/fuzz/seed/regexp/xpath-18 b/fuzz/seed/regexp/xpath-18
new file mode 100644
index 00000000..651eb9d4
Binary files /dev/null and b/fuzz/seed/regexp/xpath-18 differ
diff --git a/fuzz/seed/regexp/xpath-19 b/fuzz/seed/regexp/xpath-19
new file mode 100644
index 00000000..fefea8f1
Binary files /dev/null and b/fuzz/seed/regexp/xpath-19 differ
diff --git a/fuzz/seed/regexp/xpath-2 b/fuzz/seed/regexp/xpath-2
new file mode 100644
index 00000000..81e5fba0
Binary files /dev/null and b/fuzz/seed/regexp/xpath-2 differ
diff --git a/fuzz/seed/regexp/xpath-20 b/fuzz/seed/regexp/xpath-20
new file mode 100644
index 00000000..1f3089fb
Binary files /dev/null and b/fuzz/seed/regexp/xpath-20 differ
diff --git a/fuzz/seed/regexp/xpath-21 b/fuzz/seed/regexp/xpath-21
new file mode 100644
index 00000000..706a7025
Binary files /dev/null and b/fuzz/seed/regexp/xpath-21 differ
diff --git a/fuzz/seed/regexp/xpath-22 b/fuzz/seed/regexp/xpath-22
new file mode 100644
index 00000000..a246f84c
Binary files /dev/null and b/fuzz/seed/regexp/xpath-22 differ
diff --git a/fuzz/seed/regexp/xpath-23 b/fuzz/seed/regexp/xpath-23
new file mode 100644
index 00000000..02753beb
Binary files /dev/null and b/fuzz/seed/regexp/xpath-23 differ
diff --git a/fuzz/seed/regexp/xpath-24 b/fuzz/seed/regexp/xpath-24
new file mode 100644
index 00000000..331105cd
Binary files /dev/null and b/fuzz/seed/regexp/xpath-24 differ
diff --git a/fuzz/seed/regexp/xpath-25 b/fuzz/seed/regexp/xpath-25
new file mode 100644
index 00000000..ce3da443
Binary files /dev/null and b/fuzz/seed/regexp/xpath-25 differ
diff --git a/fuzz/seed/regexp/xpath-26 b/fuzz/seed/regexp/xpath-26
new file mode 100644
index 00000000..b3bf8c23
Binary files /dev/null and b/fuzz/seed/regexp/xpath-26 differ
diff --git a/fuzz/seed/regexp/xpath-27 b/fuzz/seed/regexp/xpath-27
new file mode 100644
index 00000000..74bbe468
Binary files /dev/null and b/fuzz/seed/regexp/xpath-27 differ
diff --git a/fuzz/seed/regexp/xpath-28 b/fuzz/seed/regexp/xpath-28
new file mode 100644
index 00000000..b38a709e
Binary files /dev/null and b/fuzz/seed/regexp/xpath-28 differ
diff --git a/fuzz/seed/regexp/xpath-29 b/fuzz/seed/regexp/xpath-29
new file mode 100644
index 00000000..104d4e54
Binary files /dev/null and b/fuzz/seed/regexp/xpath-29 differ
diff --git a/fuzz/seed/regexp/xpath-3 b/fuzz/seed/regexp/xpath-3
new file mode 100644
index 00000000..6d7be85f
Binary files /dev/null and b/fuzz/seed/regexp/xpath-3 differ
diff --git a/fuzz/seed/regexp/xpath-30 b/fuzz/seed/regexp/xpath-30
new file mode 100644
index 00000000..b681ff14
Binary files /dev/null and b/fuzz/seed/regexp/xpath-30 differ
diff --git a/fuzz/seed/regexp/xpath-31 b/fuzz/seed/regexp/xpath-31
new file mode 100644
index 00000000..cd87b0e8
Binary files /dev/null and b/fuzz/seed/regexp/xpath-31 differ
diff --git a/fuzz/seed/regexp/xpath-32 b/fuzz/seed/regexp/xpath-32
new file mode 100644
index 00000000..c5cac32a
Binary files /dev/null and b/fuzz/seed/regexp/xpath-32 differ
diff --git a/fuzz/seed/regexp/xpath-33 b/fuzz/seed/regexp/xpath-33
new file mode 100644
index 00000000..89e3fcdc
Binary files /dev/null and b/fuzz/seed/regexp/xpath-33 differ
diff --git a/fuzz/seed/regexp/xpath-34 b/fuzz/seed/regexp/xpath-34
new file mode 100644
index 00000000..b65a3d6f
Binary files /dev/null and b/fuzz/seed/regexp/xpath-34 differ
diff --git a/fuzz/seed/regexp/xpath-35 b/fuzz/seed/regexp/xpath-35
new file mode 100644
index 00000000..252a70c2
Binary files /dev/null and b/fuzz/seed/regexp/xpath-35 differ
diff --git a/fuzz/seed/regexp/xpath-4 b/fuzz/seed/regexp/xpath-4
new file mode 100644
index 00000000..30718c57
Binary files /dev/null and b/fuzz/seed/regexp/xpath-4 differ
diff --git a/fuzz/seed/regexp/xpath-5 b/fuzz/seed/regexp/xpath-5
new file mode 100644
index 00000000..06ad88ef
Binary files /dev/null and b/fuzz/seed/regexp/xpath-5 differ
diff --git a/fuzz/seed/regexp/xpath-6 b/fuzz/seed/regexp/xpath-6
new file mode 100644
index 00000000..66787728
Binary files /dev/null and b/fuzz/seed/regexp/xpath-6 differ
diff --git a/fuzz/seed/regexp/xpath-7 b/fuzz/seed/regexp/xpath-7
new file mode 100644
index 00000000..e69ad856
Binary files /dev/null and b/fuzz/seed/regexp/xpath-7 differ
diff --git a/fuzz/seed/regexp/xpath-8 b/fuzz/seed/regexp/xpath-8
new file mode 100644
index 00000000..a8120ccd
Binary files /dev/null and b/fuzz/seed/regexp/xpath-8 differ
diff --git a/fuzz/seed/regexp/xpath-9 b/fuzz/seed/regexp/xpath-9
new file mode 100644
index 00000000..c037ce7f
Binary files /dev/null and b/fuzz/seed/regexp/xpath-9 differ
diff --git a/fuzz/seed/uri/dot b/fuzz/seed/uri/dot
new file mode 100644
index 00000000..945c9b46
--- /dev/null
+++ b/fuzz/seed/uri/dot
@@ -0,0 +1 @@
+.
\ No newline at end of file
diff --git a/fuzz/seed/uri/full b/fuzz/seed/uri/full
new file mode 100644
index 00000000..808e58a1
Binary files /dev/null and b/fuzz/seed/uri/full differ
diff --git a/fuzz/testFuzzer.c b/fuzz/testFuzzer.c
new file mode 100644
index 00000000..678f3243
--- /dev/null
+++ b/fuzz/testFuzzer.c
@@ -0,0 +1,160 @@
+/*
+ * testFuzzer.c: Test program for the custom entity loader used to fuzz
+ * with multiple inputs.
+ *
+ * See Copyright for the status of this software.
+ */
+
+#include <string.h>
+#include <glob.h>
+#include <libxml/parser.h>
+#include <libxml/tree.h>
+#include <libxml/xmlstring.h>
+#include "fuzz.h"
+
+#define LLVMFuzzerInitialize fuzzHtmlInit
+#define LLVMFuzzerTestOneInput fuzzHtml
+#include "html.c"
+#undef LLVMFuzzerInitialize
+#undef LLVMFuzzerTestOneInput
+
+#define LLVMFuzzerInitialize fuzzRegexpInit
+#define LLVMFuzzerTestOneInput fuzzRegexp
+#include "regexp.c"
+#undef LLVMFuzzerInitialize
+#undef LLVMFuzzerTestOneInput
+
+#define LLVMFuzzerInitialize fuzzSchemaInit
+#define LLVMFuzzerTestOneInput fuzzSchema
+#include "schema.c"
+#undef LLVMFuzzerInitialize
+#undef LLVMFuzzerTestOneInput
+
+#define LLVMFuzzerInitialize fuzzUriInit
+#define LLVMFuzzerTestOneInput fuzzUri
+#include "uri.c"
+#undef LLVMFuzzerInitialize
+#undef LLVMFuzzerTestOneInput
+
+#define LLVMFuzzerInitialize fuzzXmlInit
+#define LLVMFuzzerTestOneInput fuzzXml
+#include "xml.c"
+#undef LLVMFuzzerInitialize
+#undef LLVMFuzzerTestOneInput
+
+#define LLVMFuzzerInitialize fuzzXPathInit
+#define LLVMFuzzerTestOneInput fuzzXPath
+#include "xpath.c"
+#undef LLVMFuzzerInitialize
+#undef LLVMFuzzerTestOneInput
+
+typedef int
+(*initFunc)(int *argc, char ***argv);
+typedef int
+(*fuzzFunc)(const char *data, size_t size);
+
+int numInputs;
+
+static int
+testFuzzer(initFunc init, fuzzFunc fuzz, const char *pattern) {
+    glob_t globbuf;
+    int ret = -1;
+    int i;
+
+    if (glob(pattern, 0, NULL, &globbuf) != 0) {
+        fprintf(stderr, "pattern %s matches no files\n", pattern);
+        return(-1);
+    }
+
+    if (init != NULL)
+        init(NULL, NULL);
+
+    for (i = 0; i < globbuf.gl_pathc; i++) {
+        const char *path = globbuf.gl_pathv[i];
+        char *data;
+        size_t size;
+
+        data = xmlSlurpFile(path, &size);
+        if (data == NULL) {
+            fprintf(stderr, "couldn't read %s\n", path);
+            goto error;
+        }
+        fuzz(data, size);
+        xmlFree(data);
+
+        numInputs++;
+    }
+
+    ret = 0;
+error:
+    globfree(&globbuf);
+    return(ret);
+}
+
+static int
+testEntityLoader() {
+    static const char data[] =
+        "doc.xml\\\n"
+        "<!DOCTYPE doc SYSTEM \"doc.dtd\">\n"
+        "<doc>&ent;</doc>\\\n"
+        "doc.dtd\\\n"
+        "<!ELEMENT doc (#PCDATA)>\n"
+        "<!ENTITY ent SYSTEM \"ent.txt\">\\\n"
+        "ent.txt\\\n"
+        "Hello, world!\\\n";
+    static xmlChar expected[] =
+        "<?xml version=\"1.0\"?>\n"
+        "<!DOCTYPE doc SYSTEM \"doc.dtd\">\n"
+        "<doc>Hello, world!</doc>\n";
+    const char *docBuffer;
+    size_t docSize;
+    xmlDocPtr doc;
+    xmlChar *out;
+    int ret = 0;
+
+    xmlSetExternalEntityLoader(xmlFuzzEntityLoader);
+
+    xmlFuzzDataInit(data, sizeof(data) - 1);
+    xmlFuzzReadEntities();
+    docBuffer = xmlFuzzMainEntity(&docSize);
+    doc = xmlReadMemory(docBuffer, docSize, NULL, NULL,
+                        XML_PARSE_NOENT | XML_PARSE_DTDLOAD);
+
+    xmlDocDumpMemory(doc, &out, NULL);
+    if (xmlStrcmp(out, expected) != 0) {
+        fprintf(stderr, "Expected:\n%sGot:\n%s", expected, out);
+        ret = 1;
+    }
+
+    xmlFree(out);
+    xmlFreeDoc(doc);
+    xmlFuzzDataCleanup();
+
+    return(ret);
+}
+
+int
+main() {
+    int ret = 0;
+
+    if (testEntityLoader() != 0)
+        ret = 1;
+    if (testFuzzer(fuzzHtmlInit, fuzzHtml, "seed/html/*") != 0)
+        ret = 1;
+    if (testFuzzer(fuzzRegexpInit, fuzzRegexp, "seed/regexp/*") != 0)
+        ret = 1;
+    if (testFuzzer(fuzzSchemaInit, fuzzSchema, "seed/schema/*") != 0)
+        ret = 1;
+    if (testFuzzer(NULL, fuzzUri, "seed/uri/*") != 0)
+        ret = 1;
+    if (testFuzzer(fuzzXmlInit, fuzzXml, "seed/xml/*") != 0)
+        ret = 1;
+    if (testFuzzer(fuzzXPathInit, fuzzXPath, "seed/xpath/*") != 0)
+        ret = 1;
+
+    if (ret == 0)
+        printf("Successfully tested %d inputs\n", numInputs);
+
+    return(ret);
+}
+
diff --git a/fuzz/uri.c b/fuzz/uri.c
new file mode 100644
index 00000000..69d0439f
--- /dev/null
+++ b/fuzz/uri.c
@@ -0,0 +1,45 @@
+/*
+ * uri.c: a libFuzzer target to test the URI module.
+ *
+ * See Copyright for the status of this software.
+ */
+
+#include <libxml/uri.h>
+#include "fuzz.h"
+
+int
+LLVMFuzzerTestOneInput(const char *data, size_t size) {
+    xmlURIPtr uri;
+    char *str[2] = { NULL, NULL };
+    size_t numStrings;
+
+    numStrings = xmlFuzzExtractStrings(data, size, str, 2);
+
+    uri = xmlParseURI(str[0]);
+    xmlFree(xmlSaveUri(uri));
+    xmlFreeURI(uri);
+
+    uri = xmlParseURIRaw(str[0], 1);
+    xmlFree(xmlSaveUri(uri));
+    xmlFreeURI(uri);
+
+    xmlFree(xmlURIUnescapeString(str[0], -1, NULL));
+    xmlFree(xmlURIEscape(BAD_CAST str[0]));
+    xmlFree(xmlCanonicPath(BAD_CAST str[0]));
+    xmlFree(xmlPathToURI(BAD_CAST str[0]));
+
+    if (numStrings >= 2) {
+        xmlFree(xmlBuildURI(BAD_CAST str[1], BAD_CAST str[0]));
+        xmlFree(xmlBuildRelativeURI(BAD_CAST str[1], BAD_CAST str[0]));
+        xmlFree(xmlURIEscapeStr(BAD_CAST str[0], BAD_CAST str[1]));
+    }
+
+    /* Modifies string, so must come last. */
+    xmlNormalizeURIPath(str[0]);
+
+    xmlFree(str[0]);
+    xmlFree(str[1]);
+
+    return 0;
+}
+
diff --git a/fuzz/uri.options b/fuzz/uri.options
new file mode 100644
index 00000000..8c45a722
--- /dev/null
+++ b/fuzz/uri.options
@@ -0,0 +1,3 @@
+[libfuzzer]
+max_len = 10000
+timeout = 5
diff --git a/fuzz/xml.c b/fuzz/xml.c
new file mode 100644
index 00000000..09867cf7
--- /dev/null
+++ b/fuzz/xml.c
@@ -0,0 +1,96 @@
+/*
+ * xml.c: a libFuzzer target to test several XML parser interfaces.
+ *
+ * See Copyright for the status of this software.
+ */
+
+#include <libxml/parser.h>
+#include <libxml/tree.h>
+#include <libxml/xmlerror.h>
+#include <libxml/xinclude.h>
+#include <libxml/xmlreader.h>
+#include "fuzz.h"
+
+int
+LLVMFuzzerInitialize(int *argc ATTRIBUTE_UNUSED,
+                     char ***argv ATTRIBUTE_UNUSED) {
+    xmlInitParser();
+    xmlSetGenericErrorFunc(NULL, xmlFuzzErrorFunc);
+    xmlSetExternalEntityLoader(xmlFuzzEntityLoader);
+
+    return 0;
+}
+
+int
+LLVMFuzzerTestOneInput(const char *data, size_t size) {
+    static const size_t maxChunkSize = 128;
+    xmlDocPtr doc;
+    xmlParserCtxtPtr ctxt;
+    xmlTextReaderPtr reader;
+    xmlChar *out;
+    const char *docBuffer, *docUrl;
+    size_t docSize, consumed, chunkSize;
+    int opts, outSize;
+
+    xmlFuzzDataInit(data, size);
+    opts = xmlFuzzReadInt();
+    /* XML_PARSE_HUGE still causes timeouts. */
+    opts &= ~XML_PARSE_HUGE;
+
+    xmlFuzzReadEntities();
+    docBuffer = xmlFuzzMainEntity(&docSize);
+    docUrl = xmlFuzzMainUrl();
+    if (docBuffer == NULL) {
+        xmlFuzzDataCleanup();
+        return(0);
+    }
+
+    /* Pull parser */
+
+    doc = xmlReadMemory(docBuffer, docSize, docUrl, NULL, opts);
+    if (opts & XML_PARSE_XINCLUDE)
+        xmlXIncludeProcessFlags(doc, opts);
+    /* Also test the serializer. */
+    xmlDocDumpMemory(doc, &out, &outSize);
+    xmlFree(out);
+    xmlFreeDoc(doc);
+
+    /* Push parser */
+
+    ctxt = xmlCreatePushParserCtxt(NULL, NULL, NULL, 0, docUrl);
+    xmlCtxtUseOptions(ctxt, opts);
+
+    for (consumed = 0; consumed < docSize; consumed += chunkSize) {
+        chunkSize = docSize - consumed;
+        if (chunkSize > maxChunkSize)
+            chunkSize = maxChunkSize;
+        xmlParseChunk(ctxt, docBuffer + consumed, chunkSize, 0);
+    }
+
+    xmlParseChunk(ctxt, NULL, 0, 1);
+    if (opts & XML_PARSE_XINCLUDE)
+        xmlXIncludeProcessFlags(ctxt->myDoc, opts);
+    xmlFreeDoc(ctxt->myDoc);
+    xmlFreeParserCtxt(ctxt);
+
+    /* Reader */
+
+    reader = xmlReaderForMemory(docBuffer, docSize, NULL, NULL, opts);
+    while (xmlTextReaderRead(reader) == 1) {
+        if (xmlTextReaderNodeType(reader) == XML_ELEMENT_NODE) {
+            int i, n = xmlTextReaderAttributeCount(reader);
+            for (i=0; i<n; i++) {
+                xmlTextReaderMoveToAttributeNo(reader, i);
+                while (xmlTextReaderReadAttributeValue(reader) == 1);
+            }
+        }
+    }
+    xmlFreeTextReader(reader);
+
+    /* Cleanup */
+
+    xmlFuzzDataCleanup();
+
+    return(0);
+}
+
diff --git a/fuzz/xml.dict b/fuzz/xml.dict
new file mode 100644
index 00000000..2573aea6
--- /dev/null
+++ b/fuzz/xml.dict
@@ -0,0 +1,76 @@
+xml_decl="<?xml version='1.0'?>"
+xml_decl_latin1="<?xml version='1.0' encoding='ISO-8859-1'?>"
+
+elem_start_end="<a></a>"
+elem_empty="<a/>"
+elem_ns_start_end="<a:a xmlns:a='a'></a:a>"
+elem_ns_empty="<a:a xmlns:a='a'/>"
+
+attr=" a='a'"
+
+ns_decl=" xmlns:a='a'"
+ns_default=" xmlns='a'"
+ns_prefix="a:"
+
+cdata_section="<![CDATA[ ]]>"
+
+comment="<!-- -->"
+
+pi="<?a?>"
+
+elem_decl_any="<!ELEMENT a ANY>"
+elem_decl_empty="<!ELEMENT a EMPTY>"
+elem_decl_children="<!ELEMENT a (a)>"
+elem_decl_mixed="<!ELEMENT a (#PCDATA|a)>"
+elem_children_choice="|a"
+elem_children_seq=",a"
+elem_children_sub_choice="|(a)"
+elem_children_sub_seq=",(a)"
+elem_quant_any="*"
+elem_quant_opt="?"
+elem_quant_some="+"
+
+attlist_decl_cdata_req="<!ATTLIST a a CDATA #REQUIRED>"
+attlist_decl_cdata_imp="<!ATTLIST a a CDATA #IMPLIED>"
+attlist_decl_cdata_def="<!ATTLIST a a CDATA 'a'>"
+attlist_decl_cdata_fix="<!ATTLIST a a CDATA #FIXED 'a'>"
+attlist_decl_id="<!ATTLIST a a ID #IMPLIED>"
+attlist_decl_idref="<!ATTLIST a a IDREF #IMPLIED>"
+attlist_decl_idrefs="<!ATTLIST a a IDREFS #IMPLIED>"
+attlist_decl_entity="<!ATTLIST a a ENTITY #IMPLIED>"
+attlist_decl_entities="<!ATTLIST a a ENTITIES #IMPLIED>"
+attlist_decl_nmtoken="<!ATTLIST a a NMTOKEN #IMPLIED>"
+attlist_decl_nmtokens="<!ATTLIST a a NMTOKENS #IMPLIED>"
+attlist_decl_enum="<!ATTLIST a a (a) #IMPLIED>"
+attlist_decl_notation="<!ATTLIST a a NOTATION (a) #IMPLIED>"
+
+include_sect="<![INCLUDE[ ]]>"
+ignore_sect="<![IGNORE[ ]]>"
+
+ge_decl="<!ENTITY a 'a'>"
+ge_decl_system="<!ENTITY a SYSTEM 'a'>"
+ge_decl_system_ndata="<!ENTITY a SYSTEM 'a' NDATA a>"
+ge_decl_public="<!ENTITY a PUBLIC 'a' 'a'>"
+ge_decl_public_ndata="<!ENTITY a PUBLIC 'a' 'a' NDATA a>"
+
+pe_decl="<!ENTITY % a 'a'>"
+pe_decl_system="<!ENTITY % a SYSTEM 'a'>"
+pe_decl_public="<!ENTITY % a PUBLIC 'a' 'a'>"
+
+char_ref_dec="&#60;"
+char_ref_hex="&#x3c;"
+char_ref_quoted="&#38;#60;"
+
+ge_ref_lt="&lt;"
+ge_ref_gt="&gt;"
+ge_ref_amp="&amp;"
+ge_ref_apos="&apos;"
+ge_ref_quot="&quot;"
+ge_ref="&a;"
+ge_ref_quoted="&#38;a;"
+
+pe_ref="%a;"
+pe_ref_quoted="&#37;a;"
+
+notation_decl_public="<!NOTATION a PUBLIC 'a'>"
+notation_decl_system="<!NOTATION a SYSTEM 'a'>"
diff --git a/fuzz/xml.options b/fuzz/xml.options
new file mode 100644
index 00000000..195ec544
--- /dev/null
+++ b/fuzz/xml.options
@@ -0,0 +1,3 @@
+[libfuzzer]
+max_len = 80000
+timeout = 20
diff --git a/fuzz/xpath.c b/fuzz/xpath.c
new file mode 100644
index 00000000..767acb98
--- /dev/null
+++ b/fuzz/xpath.c
@@ -0,0 +1,48 @@
+/*
+ * xpath.c: a libFuzzer target to test XPath and XPointer expressions.
+ *
+ * See Copyright for the status of this software.
+ */
+
+#include <libxml/parser.h>
+#include <libxml/xpointer.h>
+#include "fuzz.h"
+
+int
+LLVMFuzzerInitialize(int *argc ATTRIBUTE_UNUSED,
+                     char ***argv ATTRIBUTE_UNUSED) {
+    xmlInitParser();
+    xmlSetGenericErrorFunc(NULL, xmlFuzzErrorFunc);
+
+    return 0;
+}
+
+int
+LLVMFuzzerTestOneInput(const char *data, size_t size) {
+    xmlDocPtr doc;
+    const char *expr, *xml;
+    size_t exprSize, xmlSize;
+
+    xmlFuzzDataInit(data, size);
+
+    expr = xmlFuzzReadString(&exprSize);
+    xml = xmlFuzzReadString(&xmlSize);
+
+    /* Recovery mode allows more input to be fuzzed. */
+    doc = xmlReadMemory(xml, xmlSize, NULL, NULL, XML_PARSE_RECOVER);
+    if (doc != NULL) {
+        xmlXPathContextPtr xpctxt = xmlXPathNewContext(doc);
+
+        /* Operation limit to avoid timeout */
+        xpctxt->opLimit = 500000;
+
+        xmlXPathFreeObject(xmlXPtrEval(BAD_CAST expr, xpctxt));
+        xmlXPathFreeContext(xpctxt);
+    }
+    xmlFreeDoc(doc);
+
+    xmlFuzzDataCleanup();
+
+    return(0);
+}
+
diff --git a/fuzz/xpath.dict b/fuzz/xpath.dict
new file mode 100644
index 00000000..4fe375fb
--- /dev/null
+++ b/fuzz/xpath.dict
@@ -0,0 +1,94 @@
+# XML
+
+elem_a="<a></a>"
+elem_b="<b></b>"
+elem_c="<c></c>"
+elem_d="<d></d>"
+elem_empty="<a/>"
+elem_ns_a="<a:a xmlns:a='a'></a:a>"
+elem_ns_b="<b:b xmlns:b='b'></b:b>"
+
+attr_a=" a='a'"
+attr_b=" b='b'"
+
+ns_decl=" xmlns:a='a'"
+ns_default=" xmlns='a'"
+ns_prefix_a="a:"
+ns_prefix_b="b:"
+
+cdata_section="<![CDATA[ ]]>"
+
+comment="<!-- -->"
+
+pi="<?a?>"
+
+# XPath
+
+axis_ancestor="ancestor::"
+axis_ancestor_or_self="ancestor-or-self::"
+axis_attribute="attribute::"
+axis_attribute_abbrev="@"
+axis_child="child::"
+axis_descendant="descendant::"
+axis_descendant_or_self="descendant-or-self::"
+axis_following="following::"
+axis_following_sibling="following-sibling::"
+axis_namespace="namespace::"
+axis_parent="parent::"
+axis_preceding="preceding::"
+axis_preceding_siblings="preceding-sibling::"
+axis_self="self::"
+
+node_test_ns="a:"
+
+val_num="=(1.0)"
+val_str_sq="=('a')"
+val_str_dq="=(\"a\")"
+val_node_set="=(*)"
+val_elem="=(b)"
+
+step_root="/"
+step_descendant="//"
+step_any="//*"
+step_any_l="*//"
+step_elem="//b"
+step_ns_elem="//a:a"
+step_comment="//comment()"
+step_node="//node()"
+step_node_l="node()//"
+step_pi="//processing-instruction()"
+step_text="//text()"
+step_parent="../"
+
+op_plus="+1"
+op_minus=" - 1"
+op_neg="-"
+op_mul="*1"
+op_div=" div 1"
+op_mod=" mod 1"
+op_and=" and 1"
+op_or=" or 1"
+op_ne="!=1"
+op_lt="<1"
+op_gt=">1"
+op_le="<=1"
+op_ge=">=1"
+op_predicate_num="[1]"
+op_predicate_last="[last()]"
+op_predicate_str="['a']"
+op_predicate="[1=1]"
+op_arg_num=",1"
+op_arg_str=",'a'"
+op_arg_node=",*"
+op_union="|//b"
+
+var_num="=$f"
+var_bool="=$b"
+var_str="=$s"
+var_node_set="=$n"
+
+# Unicode
+
+utf8_2="\xC3\x84"
+utf8_3="\xE2\x80\x9C"
+utf8_4="\xF0\x9F\x98\x80"
diff --git a/fuzz/xpath.options b/fuzz/xpath.options
new file mode 100644
index 00000000..02d5e976
--- /dev/null
+++ b/fuzz/xpath.options
@@ -0,0 +1,3 @@
+[libfuzzer]
+max_len = 10000
+timeout = 20
diff --git a/gentest.py b/gentest.py
index b7633004..b6cd866c 100755
--- a/gentest.py
+++ b/gentest.py
@@ -120,7 +120,7 @@ skipped_functions = [
 "xmlRegisterInputCallbacks", "xmlReaderForIO",
 "xmlOutputBufferCreateIO", "xmlRegisterOutputCallbacks",
 "xmlSaveToIO", "xmlIOHTTPOpenW",
-# library state cleanup, generate false leak informations and other
+# library state cleanup, generate false leak information and other
 # troubles, heavillyb tested otherwise.
 "xmlCleanupParser", "xmlRelaxNGCleanupTypes", "xmlSetListDoc",
 "xmlSetTreeDoc", "xmlUnlinkNode",
@@ -676,7 +676,7 @@ def generate_test(module, node):
 
     #
     # check we know how to handle the args and return values
-    # and store the informations for the generation
+    # and store the information for the generation
     #
     try:
 	args = node.xpathEval("arg")
diff --git a/globals.c b/globals.c
index 7bf985f4..0c0bdb44 100644
--- a/globals.c
+++ b/globals.c
@@ -215,7 +215,7 @@ int oldXMLWDcompatibility = 0; /* DEPRECATED */
 /**
  * xmlParserDebugEntities:
  *
- * Global setting, asking the parser to print out debugging informations.
+ * Global setting, asking the parser to print out debugging information.
  * while handling entities.
  * Disabled by default
  */
diff --git a/hash.c b/hash.c
index a83d979b..afa094ef 100644
--- a/hash.c
+++ b/hash.c
@@ -11,7 +11,7 @@
  *
  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
- * MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE AUTHORS AND
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE AUTHORS AND
  * CONTRIBUTORS ACCEPT NO RESPONSIBILITY IN ANY CONCEIVABLE MANNER.
  *
  * Author: breese@users.sourceforge.net
diff --git a/include/libxml/parser.h b/include/libxml/parser.h
index c295554f..1c86a97c 100644
--- a/include/libxml/parser.h
+++ b/include/libxml/parser.h
@@ -79,7 +79,7 @@ struct _xmlParserInput {
 /**
  * xmlParserNodeInfo:
  *
- * The parser can be asked to collect Node informations, i.e. at what
+ * The parser can be asked to collect Node information, i.e. at what
  * place in the file they were detected.
  * NOTE: This is off by default and not very well tested.
  */
@@ -231,7 +231,7 @@ struct _xmlParserCtxt {
     int                nameMax;       /* Max depth of the parsing stack */
     const xmlChar *   *nameTab;       /* array of nodes */
 
-    long               nbChars;       /* number of xmlChar processed */
+    long               nbChars;       /* unused */
     long            checkIndex;       /* used by progressive parsing lookup */
     int             keepBlanks;       /* ugly but ... */
     int             disableSAX;       /* SAX callbacks are disabled */
@@ -296,7 +296,7 @@ struct _xmlParserCtxt {
     xmlAttrPtr        freeAttrs;    /* List of freed attributes nodes */
 
     /*
-     * the complete error informations for the last error.
+     * the complete error information for the last error.
      */
     xmlError          lastError;
     xmlParserMode     parseMode;    /* the parser mode */
@@ -329,7 +329,7 @@ struct _xmlSAXLocator {
  * xmlSAXHandler:
  *
  * A SAX handler is bunch of callbacks called by the parser when processing
- * of the input generate data or structure informations.
+ * of the input generate data or structure information.
  */
 
 /**
@@ -685,7 +685,7 @@ typedef int (*hasExternalSubsetSAXFunc) (void *ctx);
  *               attribute values.
  *
  * SAX2 callback when an element start has been detected by the parser.
- * It provides the namespace informations for the element, as well as
+ * It provides the namespace information for the element, as well as
  * the new namespace declarations on the element.
  */
 
@@ -707,7 +707,7 @@ typedef void (*startElementNsSAX2Func) (void *ctx,
  * @URI:  the element namespace name if available
  *
  * SAX2 callback when an element end has been detected by the parser.
- * It provides the namespace informations for the element.
+ * It provides the namespace information for the element.
  */
 
 typedef void (*endElementNsSAX2Func)   (void *ctx,
diff --git a/include/libxml/tree.h b/include/libxml/tree.h
index 6cfd7318..1e79be92 100644
--- a/include/libxml/tree.h
+++ b/include/libxml/tree.h
@@ -443,7 +443,7 @@ struct _xmlAttr {
     struct _xmlDoc  *doc;	/* the containing document */
     xmlNs           *ns;        /* pointer to the associated namespace */
     xmlAttributeType atype;     /* the attribute type if validating */
-    void            *psvi;	/* for type/PSVI informations */
+    void            *psvi;	/* for type/PSVI information */
 };
 
 /**
@@ -502,7 +502,7 @@ struct _xmlNode {
     xmlChar         *content;   /* the content */
     struct _xmlAttr *properties;/* properties list */
     xmlNs           *nsDef;     /* namespace definitions on this node */
-    void            *psvi;	/* for type/PSVI informations */
+    void            *psvi;	/* for type/PSVI information */
     unsigned short   line;	/* line number */
     unsigned short   extra;	/* extra data for XPath/XSLT */
 };
@@ -578,7 +578,7 @@ struct _xmlDoc {
     int             charset;    /* Internal flag for charset handling,
 				   actually an xmlCharEncoding */
     struct _xmlDict *dict;      /* dict used to allocate names or NULL */
-    void           *psvi;	/* for type/PSVI informations */
+    void           *psvi;	/* for type/PSVI information */
     int             parseFlags;	/* set of xmlParserOption used to parse the
 				   document */
     int             properties;	/* set of xmlDocProperties for this document
diff --git a/include/libxml/xmlIO.h b/include/libxml/xmlIO.h
index 8690d668..095b2f56 100644
--- a/include/libxml/xmlIO.h
+++ b/include/libxml/xmlIO.h
@@ -217,6 +217,8 @@ xmlParserInputBufferPtr
  */
 XMLPUBFUN void XMLCALL
 	xmlCleanupOutputCallbacks		(void);
+XMLPUBFUN int XMLCALL
+	xmlPopOutputCallbacks			(void);
 XMLPUBFUN void XMLCALL
 	xmlRegisterDefaultOutputCallbacks(void);
 XMLPUBFUN xmlOutputBufferPtr XMLCALL
diff --git a/include/libxml/xmlexports.h b/include/libxml/xmlexports.h
index f03af0d0..aceede5e 100644
--- a/include/libxml/xmlexports.h
+++ b/include/libxml/xmlexports.h
@@ -3,43 +3,46 @@
  * Description: macros for marking symbols as exportable/importable.
  *
  * Copy: See Copyright for the status of this software.
- *
- * Author: Igor Zlatovic <igor@zlatkovic.com>
  */
 
 #ifndef __XML_EXPORTS_H__
 #define __XML_EXPORTS_H__
 
-/**
- * XMLPUBFUN, XMLPUBVAR, XMLCALL
- *
- * Macros which declare an exportable function, an exportable variable and
- * the calling convention used for functions.
- *
- * Please use an extra block for every platform/compiler combination when
- * modifying this, rather than overlong #ifdef lines. This helps
- * readability as well as the fact that different compilers on the same
- * platform might need different definitions.
- */
+#if defined(_WIN32) || defined(__CYGWIN__)
+/** DOC_DISABLE */
+
+#ifdef LIBXML_STATIC
+  #define XMLPUBLIC
+#elif defined(IN_LIBXML)
+  #define XMLPUBLIC __declspec(dllexport)
+#else
+  #define XMLPUBLIC __declspec(dllimport)
+#endif
+
+#if defined(LIBXML_FASTCALL)
+  #define XMLCALL __fastcall
+#else
+  #define XMLCALL __cdecl
+#endif
+#define XMLCDECL __cdecl
+
+/** DOC_ENABLE */
+#else /* not Windows */
 
 /**
- * XMLPUBFUN:
- *
- * Macros which declare an exportable function
- */
-#define XMLPUBFUN
-/**
- * XMLPUBVAR:
+ * XMLPUBLIC:
  *
- * Macros which declare an exportable variable
+ * Macro which declares a public symbol
  */
-#define XMLPUBVAR extern
+#define XMLPUBLIC
+
 /**
  * XMLCALL:
  *
- * Macros which declare the called convention for exported functions
+ * Macro which declares the calling convention for exported functions
  */
 #define XMLCALL
+
 /**
  * XMLCDECL:
  *
@@ -48,100 +51,21 @@
  */
 #define XMLCDECL
 
-/** DOC_DISABLE */
-
-/* Windows platform with MS compiler */
-#if defined(_WIN32) && defined(_MSC_VER)
-  #undef XMLPUBFUN
-  #undef XMLPUBVAR
-  #undef XMLCALL
-  #undef XMLCDECL
-  #if defined(IN_LIBXML) && !defined(LIBXML_STATIC)
-    #define XMLPUBFUN __declspec(dllexport)
-    #define XMLPUBVAR __declspec(dllexport)
-  #else
-    #define XMLPUBFUN
-    #if !defined(LIBXML_STATIC)
-      #define XMLPUBVAR __declspec(dllimport) extern
-    #else
-      #define XMLPUBVAR extern
-    #endif
-  #endif
-  #if defined(LIBXML_FASTCALL)
-    #define XMLCALL __fastcall
-  #else
-    #define XMLCALL __cdecl
-  #endif
-  #define XMLCDECL __cdecl
-#endif
+#endif /* platform switch */
 
-/* Windows platform with Borland compiler */
-#if defined(_WIN32) && defined(__BORLANDC__)
-  #undef XMLPUBFUN
-  #undef XMLPUBVAR
-  #undef XMLCALL
-  #undef XMLCDECL
-  #if defined(IN_LIBXML) && !defined(LIBXML_STATIC)
-    #define XMLPUBFUN __declspec(dllexport)
-    #define XMLPUBVAR __declspec(dllexport) extern
-  #else
-    #define XMLPUBFUN
-    #if !defined(LIBXML_STATIC)
-      #define XMLPUBVAR __declspec(dllimport) extern
-    #else
-      #define XMLPUBVAR extern
-    #endif
-  #endif
-  #define XMLCALL __cdecl
-  #define XMLCDECL __cdecl
-#endif
-
-/* Windows platform with GNU compiler (Mingw) */
-#if defined(_WIN32) && defined(__MINGW32__)
-  #undef XMLPUBFUN
-  #undef XMLPUBVAR
-  #undef XMLCALL
-  #undef XMLCDECL
-  /*
-   * if defined(IN_LIBXML) this raises problems on mingw with msys
-   * _imp__xmlFree listed as missing. Try to workaround the problem
-   * by also making that declaration when compiling client code.
-   */
-  #if defined(IN_LIBXML) && !defined(LIBXML_STATIC)
-    #define XMLPUBFUN __declspec(dllexport)
-    #define XMLPUBVAR __declspec(dllexport) extern
-  #else
-    #define XMLPUBFUN
-    #if !defined(LIBXML_STATIC)
-      #define XMLPUBVAR __declspec(dllimport) extern
-    #else
-      #define XMLPUBVAR extern
-    #endif
-  #endif
-  #define XMLCALL __cdecl
-  #define XMLCDECL __cdecl
-#endif
+/*
+ * XMLPUBFUN:
+ *
+ * Macro which declares an exportable function
+ */
+#define XMLPUBFUN XMLPUBLIC
 
-/* Cygwin platform (does not define _WIN32), GNU compiler */
-#if defined(__CYGWIN__)
-  #undef XMLPUBFUN
-  #undef XMLPUBVAR
-  #undef XMLCALL
-  #undef XMLCDECL
-  #if defined(IN_LIBXML) && !defined(LIBXML_STATIC)
-    #define XMLPUBFUN __declspec(dllexport)
-    #define XMLPUBVAR __declspec(dllexport)
-  #else
-    #define XMLPUBFUN
-    #if !defined(LIBXML_STATIC)
-      #define XMLPUBVAR __declspec(dllimport) extern
-    #else
-      #define XMLPUBVAR extern
-    #endif
-  #endif
-  #define XMLCALL __cdecl
-  #define XMLCDECL __cdecl
-#endif
+/**
+ * XMLPUBVAR:
+ *
+ * Macro which declares an exportable variable
+ */
+#define XMLPUBVAR XMLPUBLIC extern
 
 /* Compatibility */
 #if !defined(LIBXML_DLL_IMPORT)
diff --git a/include/libxml/xmlschemas.h b/include/libxml/xmlschemas.h
index 97930c7c..b90e9d18 100644
--- a/include/libxml/xmlschemas.h
+++ b/include/libxml/xmlschemas.h
@@ -122,7 +122,7 @@ typedef xmlSchemaValidCtxt *xmlSchemaValidCtxtPtr;
  * @line: returned line information
  *
  * A schemas validation locator, a callback called by the validator.
- * This is used when file or node informations are not available
+ * This is used when file or node information are not available
  * to find out what file and line number are affected
  *
  * Returns: 0 in case of success and -1 in case of error
diff --git a/include/libxml/xmlversion.h.in b/include/libxml/xmlversion.h.in
index 964f10d8..c995fe51 100644
--- a/include/libxml/xmlversion.h.in
+++ b/include/libxml/xmlversion.h.in
@@ -1,6 +1,6 @@
 /*
- * Summary: compile-time version informations
- * Description: compile-time version informations for the XML library
+ * Summary: compile-time version information
+ * Description: compile-time version information for the XML library
  *
  * Copy: See Copyright for the status of this software.
  *
diff --git a/include/libxml/xmlwin32version.h b/include/libxml/xmlwin32version.h
index e0f2b389..c6bc8b83 100644
--- a/include/libxml/xmlwin32version.h
+++ b/include/libxml/xmlwin32version.h
@@ -1,6 +1,6 @@
 /*
- * Summary: compile-time version informations on Windows
- * Description: compile-time version informations for the XML library
+ * Summary: compile-time version information on Windows
+ * Description: compile-time version information for the XML library
  *              when compiled on the Windows platform
  *
  * Copy: See Copyright for the status of this software.
diff --git a/include/libxml/xmlwin32version.h.in b/include/libxml/xmlwin32version.h.in
index 2176ad11..90e97ef5 100644
--- a/include/libxml/xmlwin32version.h.in
+++ b/include/libxml/xmlwin32version.h.in
@@ -1,6 +1,6 @@
 /*
- * Summary: compile-time version informations on Windows
- * Description: compile-time version informations for the XML library
+ * Summary: compile-time version information on Windows
+ * Description: compile-time version information for the XML library
  *              when compiled on the Windows platform
  *
  * Copy: See Copyright for the status of this software.
diff --git a/include/libxml/xpath.h b/include/libxml/xpath.h
index 4ef3909b..a4303ff1 100644
--- a/include/libxml/xpath.h
+++ b/include/libxml/xpath.h
@@ -373,7 +373,7 @@ typedef xmlXPathCompExpr *xmlXPathCompExprPtr;
 /**
  * xmlXPathParserContext:
  *
- * An XPath parser context. It contains pure parsing informations,
+ * An XPath parser context. It contains pure parsing information,
  * an xmlXPathContext, and the stack of objects.
  */
 struct _xmlXPathParserContext {
diff --git a/libxml.m4 b/libxml.m4
index 2d7a6f53..b5df9158 100644
--- a/libxml.m4
+++ b/libxml.m4
@@ -128,7 +128,7 @@ main()
         printf("*** being found. The easiest way to fix this is to remove the old version\n");
         printf("*** of LIBXML, but you can also set the XML2_CONFIG environment to point to the\n");
         printf("*** correct copy of xml2-config. (In this case, you will have to\n");
-        printf("*** modify your LD_LIBRARY_PATH enviroment variable, or edit /etc/ld.so.conf\n");
+        printf("*** modify your LD_LIBRARY_PATH environment variable, or edit /etc/ld.so.conf\n");
         printf("*** so that the correct libraries are found at run-time))\n");
     }
   return 1;
diff --git a/libxml2-config.cmake.cmake.in b/libxml2-config.cmake.cmake.in
new file mode 100644
index 00000000..8614f21b
--- /dev/null
+++ b/libxml2-config.cmake.cmake.in
@@ -0,0 +1,127 @@
+# libxml2-config.cmake
+# --------------------
+#
+# Libxml2 cmake module.
+# This module sets the following variables:
+#
+# ::
+#
+#   LIBXML2_INCLUDE_DIR        - Directory where LibXml2 headers are located.
+#   LIBXML2_INCLUDE_DIRS       - list of the include directories needed to use LibXml2.
+#   LIBXML2_LIBRARY            - path to the LibXml2 library.
+#   LIBXML2_LIBRARIES          - xml2 libraries to link against.
+#   LIBXML2_DEFINITIONS        - the compiler switches required for using LibXml2.
+#   LIBXML2_VERSION_MAJOR      - The major version of libxml2.
+#   LIBXML2_VERSION_MINOR      - The minor version of libxml2.
+#   LIBXML2_VERSION_PATCH      - The patch version of libxml2.
+#   LIBXML2_VERSION_STRING     - version number as a string (ex: "2.3.4")
+#   LIBXML2_MODULES            - whether libxml2 has dso support
+#   LIBXML2_XMLLINT_EXECUTABLE - path to the XML checking tool xmllint coming with LibXml2
+
+include("${CMAKE_CURRENT_LIST_DIR}/libxml2-export.cmake")
+
+@PACKAGE_INIT@
+
+set(LIBXML2_VERSION_MAJOR  @LIBXML_MAJOR_VERSION@)
+set(LIBXML2_VERSION_MINOR  @LIBXML_MINOR_VERSION@)
+set(LIBXML2_VERSION_PATCH  @LIBXML_MICRO_VERSION@)
+set(LIBXML2_VERSION_STRING "@VERSION@")
+set(LIBXML2_INSTALL_PREFIX ${PACKAGE_PREFIX_DIR})
+set(LIBXML2_INCLUDE_DIR    ${PACKAGE_PREFIX_DIR}/@CMAKE_INSTALL_INCLUDEDIR@/libxml2)
+set(LIBXML2_LIBRARY_DIR    ${PACKAGE_PREFIX_DIR}/@CMAKE_INSTALL_LIBDIR@)
+
+macro(select_library_location target basename)
+  foreach(property IN ITEMS IMPORTED_LOCATION IMPORTED_IMPLIB)
+    get_target_property(${basename}_${property}_DEBUG ${target} ${property}_DEBUG)
+    get_target_property(${basename}_${property}_MINSIZEREL ${target} ${property}_MINSIZEREL)
+    get_target_property(${basename}_${property}_RELEASE ${target} ${property}_RELEASE)
+    get_target_property(${basename}_${property}_RELWITHDEBINFO ${target} ${property}_RELWITHDEBINFO)
+
+    if(${basename}_${property}_DEBUG AND ${basename}_${property}_RELEASE)
+      set(${basename}_LIBRARY debug ${${basename}_${property}_DEBUG} optimized ${${basename}_${property}_RELEASE})
+    elseif(${basename}_${property}_DEBUG AND ${basename}_${property}_RELWITHDEBINFO)
+      set(${basename}_LIBRARY debug ${${basename}_${property}_DEBUG} optimized ${${basename}_${property}_RELWITHDEBINFO})
+    elseif(${basename}_${property}_DEBUG AND ${basename}_${property}_MINSIZEREL)
+      set(${basename}_LIBRARY debug ${${basename}_${property}_DEBUG} optimized ${${basename}_${property}_MINSIZEREL})
+    elseif(${basename}_${property}_RELEASE)
+      set(${basename}_LIBRARY ${${basename}_${property}_RELEASE})
+    elseif(${basename}_${property}_RELWITHDEBINFO)
+      set(${basename}_LIBRARY ${${basename}_${property}_RELWITHDEBINFO})
+    elseif(${basename}_${property}_MINSIZEREL)
+      set(${basename}_LIBRARY ${${basename}_${property}_MINSIZEREL})
+    elseif(${basename}_${property}_DEBUG)
+      set(${basename}_LIBRARY ${${basename}_${property}_DEBUG})
+    endif()
+  endforeach()
+endmacro()
+
+macro(select_executable_location target basename)
+  get_target_property(${basename}_IMPORTED_LOCATION_DEBUG ${target} IMPORTED_LOCATION_DEBUG)
+  get_target_property(${basename}_IMPORTED_LOCATION_MINSIZEREL ${target} IMPORTED_LOCATION_MINSIZEREL)
+  get_target_property(${basename}_IMPORTED_LOCATION_RELEASE ${target} IMPORTED_LOCATION_RELEASE)
+  get_target_property(${basename}_IMPORTED_LOCATION_RELWITHDEBINFO ${target} IMPORTED_LOCATION_RELWITHDEBINFO)
+
+  if(${basename}_IMPORTED_LOCATION_RELEASE)
+    set(${basename}_EXECUTABLE ${${basename}_IMPORTED_LOCATION_RELEASE})
+  elseif(${basename}_IMPORTED_LOCATION_RELWITHDEBINFO)
+    set(${basename}_EXECUTABLE ${${basename}_IMPORTED_LOCATION_RELWITHDEBINFO})
+  elseif(${basename}_IMPORTED_LOCATION_MINSIZEREL)
+    set(${basename}_EXECUTABLE ${${basename}_IMPORTED_LOCATION_MINSIZEREL})
+  elseif(${basename}_IMPORTED_LOCATION_DEBUG)
+    set(${basename}_EXECUTABLE ${${basename}_IMPORTED_LOCATION_DEBUG})
+  endif()
+endmacro()
+
+select_library_location(LibXml2::LibXml2 LIBXML2)
+select_executable_location(LibXml2::xmllint LIBXML2_XMLLINT)
+
+set(LIBXML2_LIBRARIES ${LIBXML2_LIBRARY})
+set(LIBXML2_INCLUDE_DIRS ${LIBXML2_INCLUDE_DIR})
+
+include(CMakeFindDependencyMacro)
+
+if(@LIBXML2_WITH_ICONV@)
+  find_dependency(Iconv)
+  list(APPEND LIBXML2_LIBRARIES    ${Iconv_LIBRARIES})
+  list(APPEND LIBXML2_INCLUDE_DIRS ${Iconv_INCLUDE_DIRS})
+endif()
+
+if(NOT @BUILD_SHARED_LIBS@)
+  set(LIBXML2_DEFINITIONS -DLIBXML_STATIC)
+
+  if(@LIBXML2_WITH_THREADS@)
+    find_dependency(Threads)
+    list(APPEND LIBXML2_LIBRARIES ${CMAKE_THREAD_LIBS_INIT})
+  endif()
+
+  if(@LIBXML2_WITH_ICU@)
+    find_dependency(ICU)
+    list(APPEND LIBXML2_LIBRARIES    ${ICU_LIBRARIES})
+    list(APPEND LIBXML2_INCLUDE_DIRS ${ICU_INCLUDE_DIRS})
+  endif()
+
+  if(@LIBXML2_WITH_LZMA@)
+    find_dependency(LibLZMA)
+    list(APPEND LIBXML2_LIBRARIES    ${LIBLZMA_LIBRARIES})
+    list(APPEND LIBXML2_INCLUDE_DIRS ${LIBLZMA_INCLUDE_DIRS})
+  endif()
+
+  if(@LIBXML2_WITH_ZLIB@)
+    find_dependency(ZLIB)
+    list(APPEND LIBXML2_LIBRARIES    ${ZLIB_LIBRARIES})
+    list(APPEND LIBXML2_INCLUDE_DIRS ${ZLIB_INCLUDE_DIRS})
+  endif()
+
+  if(UNIX)
+    list(APPEND LIBXML2_LIBRARIES m)
+  endif()
+
+  if(WIN32)
+    list(APPEND LIBXML2_LIBRARIES ws2_32)
+  endif()
+endif()
+
+# whether libxml2 has dso support
+set(LIBXML2_MODULES @LIBXML2_WITH_MODULES@)
+
+mark_as_advanced(LIBXML2_LIBRARY LIBXML2_XMLLINT_EXECUTABLE)
diff --git a/libxml2-config.cmake.in b/libxml2-config.cmake.in
index 6b16fc2e..73112efc 100644
--- a/libxml2-config.cmake.in
+++ b/libxml2-config.cmake.in
@@ -2,17 +2,26 @@
 # --------------------
 #
 # Libxml2 cmake module.
-# THis module sets the following variables:
+# This module sets the following variables:
 #
 # ::
 #
-#   LIBXML2_INCLUDE_DIRS      - Directory where libxml2 headers are located.
-#   LIBXML2_LIBRARIES         - xml2 libraries to link against.
-#   LIBXML2_VERSION_MAJOR     - The major version of libxml2.
-#   LIBXML2_VERSION_MINOR     - The minor version of libxml2.
-#   LIBXML2_VERSION_PATCH     - The patch version of libxml2.
-#   LIBXML2_VERSION_STRING    - version number as a string (ex: "2.3.4")
-#   LIBXML2_MODULES           - whether libxml2 as dso support
+#   LIBXML2_INCLUDE_DIR        - Directory where LibXml2 headers are located.
+#   LIBXML2_INCLUDE_DIRS       - list of the include directories needed to use LibXml2.
+#   LIBXML2_LIBRARY            - path to the LibXml2 library.
+#   LIBXML2_LIBRARIES          - xml2 libraries to link against.
+#   LIBXML2_DEFINITIONS        - the compiler switches required for using LibXml2.
+#   LIBXML2_VERSION_MAJOR      - The major version of libxml2.
+#   LIBXML2_VERSION_MINOR      - The minor version of libxml2.
+#   LIBXML2_VERSION_PATCH      - The patch version of libxml2.
+#   LIBXML2_VERSION_STRING     - version number as a string (ex: "2.3.4")
+#   LIBXML2_MODULES            - whether libxml2 has dso support
+#   LIBXML2_XMLLINT_EXECUTABLE - path to the XML checking tool xmllint coming with LibXml2
+#
+# The following targets are defined:
+#
+#   LibXml2::LibXml2          - the LibXml2 library
+#   LibXml2::xmllint          - the xmllint command-line executable
 
 get_filename_component(_libxml2_rootdir ${CMAKE_CURRENT_LIST_DIR}/../../../ ABSOLUTE)
 
@@ -20,31 +29,78 @@ set(LIBXML2_VERSION_MAJOR  @LIBXML_MAJOR_VERSION@)
 set(LIBXML2_VERSION_MINOR  @LIBXML_MINOR_VERSION@)
 set(LIBXML2_VERSION_MICRO  @LIBXML_MICRO_VERSION@)
 set(LIBXML2_VERSION_STRING "@VERSION@")
+set(LIBXML2_DEFINITIONS    "@XML_CFLAGS@")
 set(LIBXML2_INSTALL_PREFIX ${_libxml2_rootdir})
-set(LIBXML2_INCLUDE_DIRS   ${_libxml2_rootdir}/include ${_libxml2_rootdir}/include/libxml2)
+set(LIBXML2_INCLUDE_DIR    ${_libxml2_rootdir}/include/libxml2)
 set(LIBXML2_LIBRARY_DIR    ${_libxml2_rootdir}/lib)
-set(LIBXML2_LIBRARIES      -L${LIBXML2_LIBRARY_DIR} -lxml2)
+
+find_library(LIBXML2_LIBRARY NAMES xml2 HINTS ${LIBXML2_LIBRARY_DIR} NO_DEFAULT_PATH)
+find_program(LIBXML2_XMLLINT_EXECUTABLE NAMES xmllint HINTS ${_libxml2_rootdir}/bin NO_DEFAULT_PATH)
+
+set(LIBXML2_LIBRARIES ${LIBXML2_LIBRARY})
+set(LIBXML2_INCLUDE_DIRS ${LIBXML2_INCLUDE_DIR})
+unset(LIBXML2_INTERFACE_LINK_LIBRARIES)
+
+include(CMakeFindDependencyMacro)
+
+if(@WITH_ICONV@)
+  find_dependency(Iconv)
+  list(APPEND LIBXML2_LIBRARIES    ${Iconv_LIBRARIES})
+  list(APPEND LIBXML2_INCLUDE_DIRS ${Iconv_INCLUDE_DIRS})
+  list(APPEND LIBXML2_INTERFACE_LINK_LIBRARIES "Iconv::Iconv")
+endif()
 
 if(@WITH_THREADS@)
-  find_package(Threads REQUIRED)
-  list(APPEND LIBXML2_LIBRARIES ${CMAKE_THREAD_LIBS_INIT})
+  find_dependency(Threads)
+  list(APPEND LIBXML2_LIBRARIES    ${CMAKE_THREAD_LIBS_INIT})
+  list(APPEND LIBXML2_INTERFACE_LINK_LIBRARIES "\$<LINK_ONLY:Threads::Threads>")
+endif()
+
+if(@WITH_ICU@)
+  find_dependency(ICU)
+  list(APPEND LIBXML2_LIBRARIES    ${ICU_LIBRARIES})
+  list(APPEND LIBXML2_INCLUDE_DIRS ${ICU_INCLUDE_DIRS})
+  list(APPEND LIBXML2_INTERFACE_LINK_LIBRARIES "\$<LINK_ONLY:ICU::i18n>")
 endif()
 
 if(@WITH_LZMA@)
-  find_package(LibLZMA REQUIRED)
+  find_dependency(LibLZMA)
   list(APPEND LIBXML2_LIBRARIES    ${LIBLZMA_LIBRARIES})
   list(APPEND LIBXML2_INCLUDE_DIRS ${LIBLZMA_INCLUDE_DIRS})
+  list(APPEND LIBXML2_INTERFACE_LINK_LIBRARIES "\$<LINK_ONLY:LibLZMA::LibLZMA>")
 endif()
 
 if(@WITH_ZLIB@)
-  find_package(ZLIB REQUIRED)
+  find_dependency(ZLIB)
   list(APPEND LIBXML2_LIBRARIES    ${ZLIB_LIBRARIES})
   list(APPEND LIBXML2_INCLUDE_DIRS ${ZLIB_INCLUDE_DIRS})
+  list(APPEND LIBXML2_INTERFACE_LINK_LIBRARIES "\$<LINK_ONLY:ZLIB::ZLIB>")
+endif()
+
+if(UNIX)
+  list(APPEND LIBXML2_LIBRARIES    m)
+  list(APPEND LIBXML2_INTERFACE_LINK_LIBRARIES "\$<LINK_ONLY:m>")
 endif()
 
-list(APPEND LIBXML2_LIBRARIES @ICU_LIBS@ @ICONV_LIBS@ @M_LIBS@ @WIN32_EXTRA_LIBADD@ @LIBS@)
+if(WIN32)
+  list(APPEND LIBXML2_LIBRARIES    ws2_32)
+  list(APPEND LIBXML2_INTERFACE_LINK_LIBRARIES "\$<LINK_ONLY:ws2_32>")
+endif()
 
 # whether libxml2 has dso support
 set(LIBXML2_MODULES @WITH_MODULES@)
 
-mark_as_advanced( LIBXML2_INCLUDE_DIRS LIBXML2_LIBRARIES )
+mark_as_advanced(LIBXML2_LIBRARY LIBXML2_XMLLINT_EXECUTABLE)
+
+if(NOT TARGET LibXml2::LibXml2)
+  add_library(LibXml2::LibXml2 UNKNOWN IMPORTED)
+  set_target_properties(LibXml2::LibXml2 PROPERTIES IMPORTED_LOCATION "${LIBXML2_LIBRARY}")
+  set_target_properties(LibXml2::LibXml2 PROPERTIES INTERFACE_COMPILE_OPTIONS "${LIBXML2_DEFINITIONS}")
+  set_target_properties(LibXml2::LibXml2 PROPERTIES INTERFACE_INCLUDE_DIRECTORIES "${LIBXML2_INCLUDE_DIRS}")
+  set_target_properties(LibXml2::LibXml2 PROPERTIES INTERFACE_LINK_LIBRARIES "${LIBXML2_INTERFACE_LINK_LIBRARIES}")
+endif()
+
+if(NOT TARGET LibXml2::xmllint)
+  add_executable(LibXml2::xmllint IMPORTED)
+  set_target_properties(LibXml2::xmllint PROPERTIES IMPORTED_LOCATION "${LIBXML2_XMLLINT_EXECUTABLE}")
+endif()
diff --git a/libxml2.syms b/libxml2.syms
index c17d3d98..33bc112c 100644
--- a/libxml2.syms
+++ b/libxml2.syms
@@ -2286,3 +2286,10 @@ LIBXML2_2.9.8 {
   xmlHashDefaultDeallocator;
 } LIBXML2_2.9.1;
 
+LIBXML2_2.9.11 {
+    global:
+
+# xmlIO
+  xmlPopOutputCallbacks;
+} LIBXML2_2.9.8;
+
diff --git a/list.c b/list.c
index 24da6b1e..20207155 100644
--- a/list.c
+++ b/list.c
@@ -9,7 +9,7 @@
  *
  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
- * MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE AUTHORS AND
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE AUTHORS AND
  * CONTRIBUTORS ACCEPT NO RESPONSIBILITY IN ANY CONCEIVABLE MANNER.
  *
  * Author: Gary.Pennington@uk.sun.com
diff --git a/nanoftp.c b/nanoftp.c
index 54fa026d..18c1ce43 100644
--- a/nanoftp.c
+++ b/nanoftp.c
@@ -158,7 +158,7 @@ int have_ipv6(void) {
 
 /**
  * xmlFTPErrMemory:
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle an out of memory condition
  */
@@ -172,7 +172,7 @@ xmlFTPErrMemory(const char *extra)
  * xmlNanoFTPInit:
  *
  * Initialize the FTP protocol layer.
- * Currently it just checks for proxy informations,
+ * Currently it just checks for proxy information,
  * and get the hostname
  */
 
@@ -218,7 +218,7 @@ xmlNanoFTPInit(void) {
 /**
  * xmlNanoFTPCleanup:
  *
- * Cleanup the FTP protocol layer. This cleanup proxy informations.
+ * Cleanup the FTP protocol layer. This cleanup proxy information.
  */
 
 void
@@ -250,7 +250,7 @@ xmlNanoFTPCleanup(void) {
  * @passwd:  the proxy password
  * @type:  the type of proxy 1 for using SITE, 2 for USER a@b
  *
- * Setup the FTP proxy informations.
+ * Setup the FTP proxy information.
  * This can also be done by using ftp_proxy ftp_proxy_user and
  * ftp_proxy_password environment variables.
  */
@@ -412,7 +412,7 @@ xmlNanoFTPUpdateURL(void *ctx, const char *URL) {
  * (Re)Initialize the FTP Proxy context by parsing the URL and finding
  * the protocol host port it indicates.
  * Should be like ftp://myproxy/ or ftp://myproxy:3128/
- * A NULL URL cleans up proxy informations.
+ * A NULL URL cleans up proxy information.
  */
 
 void
@@ -1251,8 +1251,7 @@ xmlNanoFTPConnectTo(const char *server, int port) {
 	xmlNanoFTPFreeCtxt(ctxt);
 	return(NULL);
     }
-    if (port != 0)
-	ctxt->port = port;
+    ctxt->port = port;
     res = xmlNanoFTPConnect(ctxt);
     if (res < 0) {
 	xmlNanoFTPFreeCtxt(ctxt);
@@ -1268,7 +1267,7 @@ xmlNanoFTPConnectTo(const char *server, int port) {
  *
  * Tries to change the remote directory
  *
- * Returns -1 incase of error, 1 if CWD worked, 0 if it failed
+ * Returns -1 in case of error, 1 if CWD worked, 0 if it failed
  */
 
 int
@@ -1317,7 +1316,7 @@ xmlNanoFTPCwd(void *ctx, const char *directory) {
  *
  * Tries to delete an item (file or directory) from server
  *
- * Returns -1 incase of error, 1 if DELE worked, 0 if it failed
+ * Returns -1 in case of error, 1 if DELE worked, 0 if it failed
  */
 
 int
@@ -1367,7 +1366,7 @@ xmlNanoFTPDele(void *ctx, const char *file) {
  * Try to open a data connection to the server. Currently only
  * passive mode is supported.
  *
- * Returns -1 incase of error, 0 otherwise
+ * Returns -1 in case of error, 0 otherwise
  */
 
 SOCKET
@@ -1540,7 +1539,7 @@ xmlNanoFTPGetConnection(void *ctx) {
  *
  * Close the data connection from the server
  *
- * Returns -1 incase of error, 0 otherwise
+ * Returns -1 in case of error, 0 otherwise
  */
 
 int
@@ -1591,7 +1590,7 @@ xmlNanoFTPCloseConnection(void *ctx) {
  *
  * Parse at most one entry from the listing.
  *
- * Returns -1 incase of error, the length of data parsed otherwise
+ * Returns -1 in case of error, the length of data parsed otherwise
  */
 
 static int
@@ -1719,7 +1718,7 @@ xmlNanoFTPParseList(const char *list, ftpListCallback callback, void *userData)
  * Do a listing on the server. All files info are passed back
  * in the callbacks.
  *
- * Returns -1 incase of error, 0 otherwise
+ * Returns -1 in case of error, 0 otherwise
  */
 
 int
@@ -1894,7 +1893,7 @@ xmlNanoFTPGetSocket(void *ctx, const char *filename) {
  * Fetch the given file from the server. All data are passed back
  * in the callbacks. The last callback has a size of 0 block.
  *
- * Returns -1 incase of error, 0 otherwise
+ * Returns -1 in case of error, 0 otherwise
  */
 
 int
@@ -2024,7 +2023,7 @@ xmlNanoFTPOpen(const char *URL) {
  *
  * Close the connection and both control and transport
  *
- * Returns -1 incase of error, 0 otherwise
+ * Returns -1 in case of error, 0 otherwise
  */
 
 int
diff --git a/nanohttp.c b/nanohttp.c
index 018b7e18..8e840f58 100644
--- a/nanohttp.c
+++ b/nanohttp.c
@@ -160,7 +160,7 @@ static int xmlNanoHTTPFetchContent( void * ctx, char ** ptr, int * len );
 
 /**
  * xmlHTTPErrMemory:
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle an out of memory condition
  */
@@ -213,7 +213,7 @@ int have_ipv6(void) {
  * xmlNanoHTTPInit:
  *
  * Initialize the HTTP protocol layer.
- * Currently it just checks for proxy informations
+ * Currently it just checks for proxy information
  */
 
 void
@@ -344,7 +344,7 @@ xmlNanoHTTPScanURL(xmlNanoHTTPCtxtPtr ctxt, const char *URL) {
  * (Re)Initialize the HTTP Proxy context by parsing the URL and finding
  * the protocol host port it indicates.
  * Should be like http://myproxy/ or http://myproxy:3128/
- * A NULL URL cleans up proxy informations.
+ * A NULL URL cleans up proxy information.
  */
 
 void
@@ -650,7 +650,7 @@ xmlNanoHTTPRecv(xmlNanoHTTPCtxtPtr ctxt)
  * @ctxt:  an HTTP context
  *
  * Read one line in the HTTP server output, usually for extracting
- * the HTTP protocol informations from the answer header.
+ * the HTTP protocol information from the answer header.
  *
  * Returns a newly allocated string with a copy of the line, or NULL
  *         which indicate the end of the input.
@@ -693,7 +693,7 @@ xmlNanoHTTPReadLine(xmlNanoHTTPCtxtPtr ctxt) {
  * @ctxt:  an HTTP context
  * @line:  an HTTP header line
  *
- * Try to extract useful informations from the server answer.
+ * Try to extract useful information from the server answer.
  * We currently parse and process:
  *  - The HTTP revision/ return code
  *  - The Content-Type, Mime-Type and charset used
@@ -1625,7 +1625,7 @@ xmlNanoHTTPMethod(const char *URL, const char *method, const char *input,
  * This function try to fetch the indicated resource via HTTP GET
  * and save it's content in the file.
  *
- * Returns -1 in case of failure, 0 incase of success. The contentType,
+ * Returns -1 in case of failure, 0 in case of success. The contentType,
  *     if provided must be freed by the caller
  */
 int
@@ -1675,7 +1675,7 @@ xmlNanoHTTPFetch(const char *URL, const char *filename, char **contentType) {
  * This function saves the output of the HTTP transaction to a file
  * It closes and free the context at the end
  *
- * Returns -1 in case of failure, 0 incase of success.
+ * Returns -1 in case of failure, 0 in case of success.
  */
 int
 xmlNanoHTTPSave(void *ctxt, const char *filename) {
diff --git a/optim/TOTRY b/optim/TOTRY
index 6e11f7e4..5b37b0bb 100644
--- a/optim/TOTRY
+++ b/optim/TOTRY
@@ -18,6 +18,6 @@ XSLT:
 	     - constants at the XPAth level
 	   - provide more info on compiled expressions
 	     - dependances w.r.t. variables (which ones)
-	     - dependancy on the current node
-	     - dependancy on the current document
+	     - dependency on the current node
+	     - dependency on the current document
   - do not use _private but other fields in the node structures.
diff --git a/os400/iconv/bldcsndfa/ccsid_mibenum.xml b/os400/iconv/bldcsndfa/ccsid_mibenum.xml
index 8af38b42..1b924732 100644
--- a/os400/iconv/bldcsndfa/ccsid_mibenum.xml
+++ b/os400/iconv/bldcsndfa/ccsid_mibenum.xml
@@ -8,7 +8,7 @@
 ---     Author: Patrick Monnerat <pm@datasphere.ch>, DATASPHERE S.A.
 -->
 <ccsid_mibenum>
-        <assoc ccsid="0"><!-- Curent job's CCSID. --></assoc>
+        <assoc ccsid="0"><!-- Current job's CCSID. --></assoc>
         <assoc ccsid="37" mibenum="2028"><!-- EBCDIC-US -->
                 <alias>EBCDIC</alias>
         </assoc>
diff --git a/os400/libxmlrpg/catalog.rpgle b/os400/libxmlrpg/catalog.rpgle
index 1dab819d..698ec5a9 100644
--- a/os400/libxmlrpg/catalog.rpgle
+++ b/os400/libxmlrpg/catalog.rpgle
@@ -33,7 +33,7 @@
 
       * XML_CATALOG_PI:
       *
-      * The specific XML Catalog Processing Instuction name.
+      * The specific XML Catalog Processing Instruction name.
 
      d XML_CATALOG_PI  c                   'oasis-xml-catalog'
 
diff --git a/os400/libxmlrpg/parser.rpgle b/os400/libxmlrpg/parser.rpgle
index fa48d4f3..c6b17a13 100644
--- a/os400/libxmlrpg/parser.rpgle
+++ b/os400/libxmlrpg/parser.rpgle
@@ -70,7 +70,7 @@
 
       * xmlParserNodeInfo:
       *
-      * The parser can be asked to collect Node informations, i.e. at what
+      * The parser can be asked to collect Node information, i.e. at what
       * place in the file they were detected.
       * NOTE: This is off by default and not very well tested.
 
@@ -310,7 +310,7 @@
      d  freeAttrsNr                        like(xmlCint)                        # free attr. nodes
      d  freeAttrs                          like(xmlAttrPtr)                     Free attr noes list
       *
-      * the complete error informations for the last error.
+      * the complete error information for the last error.
       *
      d  lastError                          likeds(xmlError)
      d  parseMode                          like(xmlParserMode)                  The parser mode
@@ -342,7 +342,7 @@
       * xmlSAXHandler:
       *
       * A SAX handler is bunch of callbacks called by the parser when
-      * processing of the input generate data or structure informations.
+      * processing of the input generate data or structure information.
 
       * resolveEntitySAXFunc:
       * @ctx:  the user data (XML parser context)
@@ -700,7 +700,7 @@
       *                  (localname/prefix/URI/value/end) attribute values.
       *
       * SAX2 callback when an element start has been detected by the parser.
-      * It provides the namespace informations for the element, as well as
+      * It provides the namespace information for the element, as well as
       * the new namespace declarations on the element.
 
      d startElementNsSAX2Func...
@@ -714,7 +714,7 @@
       * @URI:  the element namespace name if available
       *
       * SAX2 callback when an element end has been detected by the parser.
-      * It provides the namespace informations for the element.
+      * It provides the namespace information for the element.
 
      d endElementNsSAX2Func...
      d                 s               *   based(######typedef######)
@@ -1367,7 +1367,7 @@
 
       * xmlFeature:
       *
-      * Used to examine the existance of features that can be enabled
+      * Used to examine the existence of features that can be enabled
       * or disabled at compile-time.
       * They used to be called XML_FEATURE_xxx but this clashed with Expat
 
diff --git a/os400/libxmlrpg/schemasInternals.rpgle b/os400/libxmlrpg/schemasInternals.rpgle
index 765ed007..6429eb2b 100644
--- a/os400/libxmlrpg/schemasInternals.rpgle
+++ b/os400/libxmlrpg/schemasInternals.rpgle
@@ -429,14 +429,14 @@
 
       * XML_SCHEMAS_ATTRGROUP_WILDCARD_BUILDED:
       *
-      * The attribute wildcard has been already builded.
+      * The attribute wildcard has been already built.
 
      d XML_SCHEMAS_ATTRGROUP_WILDCARD_BUILDED...
      d                 c                   X'0001'
 
       * XML_SCHEMAS_ATTRGROUP_GLOBAL:
       *
-      * The attribute wildcard has been already builded.
+      * The attribute wildcard has been already built.
 
      d XML_SCHEMAS_ATTRGROUP_GLOBAL...
      d                 c                   X'0002'
@@ -885,7 +885,7 @@
 
       * XML_SCHEMAS_ELEM_BLOCK_SUBSTITUTION:
       *
-      * disallowed substitutions: "substituion"
+      * disallowed substitutions: "substitution"
 
      d XML_SCHEMAS_ELEM_BLOCK_SUBSTITUTION...
      d                 c                   X'00002000'
diff --git a/os400/libxmlrpg/tree.rpgle b/os400/libxmlrpg/tree.rpgle
index 6512778c..3e78182c 100644
--- a/os400/libxmlrpg/tree.rpgle
+++ b/os400/libxmlrpg/tree.rpgle
@@ -519,7 +519,7 @@
       * xmlDocProperty
       *
       * Set of properties of the document as found by the parser
-      * Some of them are linked to similary named xmlParserOption
+      * Some of them are linked to similarly named xmlParserOption
 
      d xmlDocProperties...
      d                 s                   based(######typedef######)
diff --git a/os400/libxmlrpg/xmlIO.rpgle b/os400/libxmlrpg/xmlIO.rpgle
index 6c0afcc9..d0e6f747 100644
--- a/os400/libxmlrpg/xmlIO.rpgle
+++ b/os400/libxmlrpg/xmlIO.rpgle
@@ -18,7 +18,7 @@
       * @filename: the filename or URI
       *
       * Callback used in the I/O Input API to detect if the current handler
-      * can provide input fonctionnalities for this resource.
+      * can provide input functionalities for this resource.
       *
       * Returns 1 if yes and 0 if another Input module should be used
 
@@ -70,7 +70,7 @@
       * @filename: the filename or URI
       *
       * Callback used in the I/O Output API to detect if the current handler
-      * can provide output fonctionnalities for this resource.
+      * can provide output functionalities for this resource.
       *
       * Returns 1 if yes and 0 if another Output module should be used
 
diff --git a/os400/libxmlrpg/xmlTypesC.rpgle b/os400/libxmlrpg/xmlTypesC.rpgle
index 48a23bfc..3440dc10 100644
--- a/os400/libxmlrpg/xmlTypesC.rpgle
+++ b/os400/libxmlrpg/xmlTypesC.rpgle
@@ -1,4 +1,4 @@
-      * Eqivalent of C data types.
+      * Equivalent of C data types.
       *
       * Copy: See Copyright for the status of this software.
       *
diff --git a/os400/libxmlrpg/xmlexports.rpgle b/os400/libxmlrpg/xmlexports.rpgle
index 9a6fd10d..d76ad4bd 100644
--- a/os400/libxmlrpg/xmlexports.rpgle
+++ b/os400/libxmlrpg/xmlexports.rpgle
@@ -8,7 +8,7 @@
       /if not defined(XML_EXPORTS_H__)
       /define XML_EXPORTS_H__
 
-      * The definition in the original C header file are not appliable to
+      * The definition in the original C header file are not applicable to
       * ILE/RPG.
       * Therefore this file is intentionally empty.
 
diff --git a/os400/libxmlrpg/xmlschemas.rpgle b/os400/libxmlrpg/xmlschemas.rpgle
index f34ddcd3..f453bd29 100644
--- a/os400/libxmlrpg/xmlschemas.rpgle
+++ b/os400/libxmlrpg/xmlschemas.rpgle
@@ -141,7 +141,7 @@
       * @line: returned line information
       *
       * A schemas validation locator, a callback called by the validator.
-      * This is used when file or node informations are not available
+      * This is used when file or node information are not available
       * to find out what file and line number are affected
       *
       * Returns: 0 in case of success and -1 in case of error
diff --git a/os400/libxmlrpg/xmlversion.rpgle.in b/os400/libxmlrpg/xmlversion.rpgle.in
index 955599e2..94a3910f 100644
--- a/os400/libxmlrpg/xmlversion.rpgle.in
+++ b/os400/libxmlrpg/xmlversion.rpgle.in
@@ -1,5 +1,5 @@
-      * Summary: compile-time version informations
-      * Description: compile-time version informations for the XML library
+      * Summary: compile-time version information
+      * Description: compile-time version information for the XML library
       *
       * Copy: See Copyright for the status of this software.
       *
diff --git a/os400/libxmlrpg/xpath.rpgle b/os400/libxmlrpg/xpath.rpgle
index 6e591ee4..e1e15d6d 100644
--- a/os400/libxmlrpg/xpath.rpgle
+++ b/os400/libxmlrpg/xpath.rpgle
@@ -389,7 +389,7 @@
 
       * xmlXPathParserContext:
       *
-      * An XPath parser context. It contains pure parsing informations,
+      * An XPath parser context. It contains pure parsing information,
       * an xmlXPathContext, and the stack of objects.
 
      d xmlXPathParserContext...
diff --git a/os400/rpgsupport.c b/os400/rpgsupport.c
index ad4cc5dd..a2f2399e 100644
--- a/os400/rpgsupport.c
+++ b/os400/rpgsupport.c
@@ -19,7 +19,7 @@
 
 
 /**
-***     ILE/RPG cannot directly derefence a pointer and has no macros.
+***     ILE/RPG cannot directly dereference a pointer and has no macros.
 ***     The following additional procedures supply these functions.
 ***     In addition, the following code is adjusted for threads control at
 ***             compile time via the C macros.
diff --git a/os400/rpgsupport.h b/os400/rpgsupport.h
index d8016d72..8e572d45 100644
--- a/os400/rpgsupport.h
+++ b/os400/rpgsupport.h
@@ -1,5 +1,5 @@
 /**
-***     Additional delarations for ILE/RPG support.
+***     Additional declarations for ILE/RPG support.
 ***
 ***     See Copyright for the status of this software.
 ***
diff --git a/os400/transcode.c b/os400/transcode.c
index bae61872..ea71b15c 100644
--- a/os400/transcode.c
+++ b/os400/transcode.c
@@ -33,7 +33,7 @@ xmlZapDict(xmlDictPtr * dict)
 
 /**
 ***     Support for inline conversion from/to UTF-8.
-***     This is targetted to function parameter encoding conversion.
+***     This is targeted to function parameter encoding conversion.
 ***     Method is:
 ***     -       Convert string from/to UTF-8.
 ***     -       Keep it in a dictionary.
diff --git a/parser.c b/parser.c
index d1c31963..85494df4 100644
--- a/parser.c
+++ b/parser.c
@@ -1073,11 +1073,15 @@ xmlHasFeature(xmlFeature feature)
  */
 static void
 xmlDetectSAX2(xmlParserCtxtPtr ctxt) {
+    xmlSAXHandlerPtr sax;
     if (ctxt == NULL) return;
+    sax = ctxt->sax;
 #ifdef LIBXML_SAX1_ENABLED
-    if ((ctxt->sax) &&  (ctxt->sax->initialized == XML_SAX2_MAGIC) &&
-        ((ctxt->sax->startElementNs != NULL) ||
-         (ctxt->sax->endElementNs != NULL))) ctxt->sax2 = 1;
+    if ((sax) &&  (sax->initialized == XML_SAX2_MAGIC) &&
+        ((sax->startElementNs != NULL) ||
+         (sax->endElementNs != NULL) ||
+         ((sax->startElement == NULL) && (sax->endElement == NULL))))
+        ctxt->sax2 = 1;
 #else
     ctxt->sax2 = 1;
 #endif /* LIBXML_SAX1_ENABLED */
@@ -2055,7 +2059,7 @@ static int spacePop(xmlParserCtxtPtr ctxt) {
     ((unsigned char *) s)[ 9 ] == c10 )
 
 #define SKIP(val) do {							\
-    ctxt->nbChars += (val),ctxt->input->cur += (val),ctxt->input->col+=(val);			\
+    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
     if (*ctxt->input->cur == 0)						\
         xmlParserInputGrow(ctxt->input, INPUT_CHUNK);			\
   } while (0)
@@ -2066,7 +2070,6 @@ static int spacePop(xmlParserCtxtPtr ctxt) {
 	if (*(ctxt->input->cur) == '\n') {				\
 	ctxt->input->line++; ctxt->input->col = 1;			\
 	} else ctxt->input->col++;					\
-	ctxt->nbChars++;						\
 	ctxt->input->cur++;						\
     }									\
     if (*ctxt->input->cur == 0)						\
@@ -2119,7 +2122,6 @@ static void xmlGROW (xmlParserCtxtPtr ctxt) {
 #define NEXT1 {								\
 	ctxt->input->col++;						\
 	ctxt->input->cur++;						\
-	ctxt->nbChars++;						\
 	if (*ctxt->input->cur == 0)					\
 	    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);		\
     }
@@ -2156,7 +2158,7 @@ xmlSkipBlankChars(xmlParserCtxtPtr ctxt) {
      * It's Okay to use CUR/NEXT here since all the blanks are on
      * the ASCII range.
      */
-    if ((ctxt->inputNr == 1) && (ctxt->instate != XML_PARSER_DTD)) {
+    if (ctxt->instate != XML_PARSER_DTD) {
 	const xmlChar *cur;
 	/*
 	 * if we are in the document content, go really fast
@@ -2332,7 +2334,6 @@ xmlParseCharRef(xmlParserCtxtPtr ctxt) {
 	if (RAW == ';') {
 	    /* on purpose to avoid reentrancy problems with NEXT and SKIP */
 	    ctxt->input->col++;
-	    ctxt->nbChars ++;
 	    ctxt->input->cur++;
 	}
     } else if  ((RAW == '&') && (NXT(1) == '#')) {
@@ -2361,7 +2362,6 @@ xmlParseCharRef(xmlParserCtxtPtr ctxt) {
 	if (RAW == ';') {
 	    /* on purpose to avoid reentrancy problems with NEXT and SKIP */
 	    ctxt->input->col++;
-	    ctxt->nbChars ++;
 	    ctxt->input->cur++;
 	}
     } else {
@@ -2646,7 +2646,8 @@ xmlStringLenDecodeEntities(xmlParserCtxtPtr ctxt, const xmlChar *str, int len,
     else
         c = 0;
     while ((c != 0) && (c != end) && /* non input consuming loop */
-	   (c != end2) && (c != end3)) {
+           (c != end2) && (c != end3) &&
+           (ctxt->instate != XML_PARSER_EOF)) {
 
 	if (c == 0) break;
         if ((c == '&') && (str[1] == '#')) {
@@ -3332,7 +3333,6 @@ xmlParseName(xmlParserCtxtPtr ctxt) {
             }
 	    ret = xmlDictLookup(ctxt->dict, ctxt->input->cur, count);
 	    ctxt->input->cur = in;
-	    ctxt->nbChars += count;
 	    ctxt->input->col += count;
 	    if (ret == NULL)
 	        xmlErrMemory(ctxt, NULL);
@@ -3455,7 +3455,6 @@ xmlParseNCName(xmlParserCtxtPtr ctxt) {
             }
 	    ret = xmlDictLookup(ctxt->dict, ctxt->input->cur, count);
 	    ctxt->input->cur = in;
-	    ctxt->nbChars += count;
 	    ctxt->input->col += count;
 	    if (ret == NULL) {
 	        xmlErrMemory(ctxt, NULL);
@@ -3492,10 +3491,10 @@ xmlParseNameAndCompare(xmlParserCtxtPtr ctxt, xmlChar const *other) {
     while (*in != 0 && *in == *cmp) {
 	++in;
 	++cmp;
-	ctxt->input->col++;
     }
     if (*cmp == 0 && (*in == '>' || IS_BLANK_CH (*in))) {
 	/* success */
+	ctxt->input->col += in - ctxt->input->cur;
 	ctxt->input->cur = in;
 	return (const xmlChar*) 1;
     }
@@ -3911,7 +3910,6 @@ xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {
                            "AttValue length too long\n");
             goto mem_error;
         }
-	if (c == 0) break;
 	if (c == '&') {
 	    in_space = 0;
 	    if (NXT(1) == '#') {
@@ -4508,7 +4506,7 @@ get_more:
             if (ctxt->instate == XML_PARSER_EOF)
 		return;
 	    in = ctxt->input->cur;
-	} while (((*in >= 0x20) && (*in <= 0x7F)) || (*in == 0x09));
+	} while (((*in >= 0x20) && (*in <= 0x7F)) || (*in == 0x09) || (*in == 0x0a));
 	nbchar = 0;
     }
     ctxt->input->line = line;
@@ -4989,7 +4987,7 @@ get_more:
 	    ctxt->input->col++;
 	    goto get_more;
 	}
-    } while (((*in >= 0x20) && (*in <= 0x7F)) || (*in == 0x09));
+    } while (((*in >= 0x20) && (*in <= 0x7F)) || (*in == 0x09) || (*in == 0x0a));
     xmlParseCommentComplex(ctxt, buf, len, size);
     ctxt->instate = state;
     return;
@@ -5053,7 +5051,7 @@ xmlParsePITarget(xmlParserCtxtPtr ctxt) {
  * <?oasis-xml-catalog catalog="http://example.com/catalog.xml"?>
  *
  * Occurs only if allowed by the user and if happening in the Misc
- * part of the document before any doctype informations
+ * part of the document before any doctype information
  * This will add the given catalog to the parsing context in order
  * to be used if there is a resolution need further down in the document
  */
@@ -6852,6 +6850,7 @@ void
 xmlParseTextDecl(xmlParserCtxtPtr ctxt) {
     xmlChar *version;
     const xmlChar *encoding;
+    int oldstate;
 
     /*
      * We know that '<?xml' is here.
@@ -6863,6 +6862,10 @@ xmlParseTextDecl(xmlParserCtxtPtr ctxt) {
 	return;
     }
 
+    /* Avoid expansion of parameter entities when skipping blanks. */
+    oldstate = ctxt->instate;
+    ctxt->instate = XML_PARSER_START;
+
     if (SKIP_BLANKS == 0) {
 	xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 		       "Space needed after '<?xml'\n");
@@ -6890,6 +6893,7 @@ xmlParseTextDecl(xmlParserCtxtPtr ctxt) {
 	/*
 	 * The XML REC instructs us to stop parsing right here
 	 */
+        ctxt->instate = oldstate;
         return;
     }
     if ((encoding == NULL) && (ctxt->errNo == XML_ERR_OK)) {
@@ -6909,6 +6913,8 @@ xmlParseTextDecl(xmlParserCtxtPtr ctxt) {
 	MOVETO_ENDTAG(CUR_PTR);
 	NEXT;
     }
+
+    ctxt->instate = oldstate;
 }
 
 /**
@@ -7159,42 +7165,38 @@ xmlParseReference(xmlParserCtxtPtr ctxt) {
 	     (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY))&&
 		(ent->children == NULL)) {
 		ent->children = list;
-		if (ctxt->replaceEntities) {
-		    /*
-		     * Prune it directly in the generated document
-		     * except for single text nodes.
-		     */
-		    if (((list->type == XML_TEXT_NODE) &&
-			 (list->next == NULL)) ||
-			(ctxt->parseMode == XML_PARSE_READER)) {
-			list->parent = (xmlNodePtr) ent;
-			list = NULL;
-			ent->owner = 1;
-		    } else {
-			ent->owner = 0;
-			while (list != NULL) {
-			    list->parent = (xmlNodePtr) ctxt->node;
-			    list->doc = ctxt->myDoc;
-			    if (list->next == NULL)
-				ent->last = list;
-			    list = list->next;
-			}
-			list = ent->children;
+                /*
+                 * Prune it directly in the generated document
+                 * except for single text nodes.
+                 */
+                if ((ctxt->replaceEntities == 0) ||
+                    (ctxt->parseMode == XML_PARSE_READER) ||
+                    ((list->type == XML_TEXT_NODE) &&
+                     (list->next == NULL))) {
+                    ent->owner = 1;
+                    while (list != NULL) {
+                        list->parent = (xmlNodePtr) ent;
+                        xmlSetTreeDoc(list, ent->doc);
+                        if (list->next == NULL)
+                            ent->last = list;
+                        list = list->next;
+                    }
+                    list = NULL;
+                } else {
+                    ent->owner = 0;
+                    while (list != NULL) {
+                        list->parent = (xmlNodePtr) ctxt->node;
+                        list->doc = ctxt->myDoc;
+                        if (list->next == NULL)
+                            ent->last = list;
+                        list = list->next;
+                    }
+                    list = ent->children;
 #ifdef LIBXML_LEGACY_ENABLED
-			if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)
-			  xmlAddEntityReference(ent, list, NULL);
+                    if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)
+                        xmlAddEntityReference(ent, list, NULL);
 #endif /* LIBXML_LEGACY_ENABLED */
-		    }
-		} else {
-		    ent->owner = 1;
-		    while (list != NULL) {
-			list->parent = (xmlNodePtr) ent;
-			xmlSetTreeDoc(list, ent->doc);
-			if (list->next == NULL)
-			    ent->last = list;
-			list = list->next;
-		    }
-		}
+                }
 	    } else {
 		xmlFreeNodeList(list);
 		list = NULL;
@@ -8629,7 +8631,7 @@ xmlParseEndTag1(xmlParserCtxtPtr ctxt, int line) {
      *
      */
     if (name != (xmlChar*)1) {
-        if (name == NULL) name = BAD_CAST "unparseable";
+        if (name == NULL) name = BAD_CAST "unparsable";
         xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NAME_MISMATCH,
 		     "Opening and ending tag mismatch: %s line %d and %s\n",
 		                ctxt->name, line, name);
@@ -8822,6 +8824,7 @@ xmlParseQNameAndCompare(xmlParserCtxtPtr ctxt, xmlChar const *name,
 	}
 	if (*cmp == 0 && (*in == '>' || IS_BLANK_CH (*in))) {
 	    /* success */
+            ctxt->input->col += in - ctxt->input->cur;
 	    ctxt->input->cur = in;
 	    return((const xmlChar*) 1);
 	}
@@ -9672,7 +9675,7 @@ xmlParseEndTag2(xmlParserCtxtPtr ctxt, const xmlChar *prefix,
      *
      */
     if (name != (xmlChar*)1) {
-        if (name == NULL) name = BAD_CAST "unparseable";
+        if (name == NULL) name = BAD_CAST "unparsable";
         if ((line == 0) && (ctxt->node != NULL))
             line = ctxt->node->line;
         xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NAME_MISMATCH,
@@ -12230,12 +12233,12 @@ xmldecl_done:
             }
         }
 	res = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);
+        xmlBufSetInputBaseCur(ctxt->input->buf->buffer, ctxt->input, base, cur);
 	if (res < 0) {
 	    ctxt->errNo = XML_PARSER_EOF;
 	    xmlHaltParser(ctxt);
 	    return (XML_PARSER_EOF);
 	}
-        xmlBufSetInputBaseCur(ctxt->input->buf->buffer, ctxt->input, base, cur);
 #ifdef DEBUG_PUSH
 	xmlGenericError(xmlGenericErrorContext, "PP: pushed %d\n", size);
 #endif
@@ -12250,6 +12253,7 @@ xmldecl_done:
 		size_t current = ctxt->input->cur - ctxt->input->base;
 
 		nbchars = xmlCharEncInput(in, terminate);
+		xmlBufSetInputBaseCur(in->buffer, ctxt->input, base, current);
 		if (nbchars < 0) {
 		    /* TODO 2.6.0 */
 		    xmlGenericError(xmlGenericErrorContext,
@@ -12257,7 +12261,6 @@ xmldecl_done:
                     xmlHaltParser(ctxt);
 		    return(XML_ERR_INVALID_ENCODING);
 		}
-		xmlBufSetInputBaseCur(in->buffer, ctxt->input, base, current);
 	    }
 	}
     }
@@ -12895,196 +12898,28 @@ xmlParseDTD(const xmlChar *ExternalID, const xmlChar *SystemID) {
 int
 xmlParseCtxtExternalEntity(xmlParserCtxtPtr ctx, const xmlChar *URL,
 	               const xmlChar *ID, xmlNodePtr *lst) {
-    xmlParserCtxtPtr ctxt;
-    xmlDocPtr newDoc;
-    xmlNodePtr newRoot;
-    xmlSAXHandlerPtr oldsax = NULL;
-    int ret = 0;
-    xmlChar start[4];
-    xmlCharEncoding enc;
+    void *userData;
 
     if (ctx == NULL) return(-1);
-
-    if (((ctx->depth > 40) && ((ctx->options & XML_PARSE_HUGE) == 0)) ||
-        (ctx->depth > 1024)) {
-	return(XML_ERR_ENTITY_LOOP);
-    }
-
-    if (lst != NULL)
-        *lst = NULL;
-    if ((URL == NULL) && (ID == NULL))
-	return(-1);
-    if (ctx->myDoc == NULL) /* @@ relax but check for dereferences */
-	return(-1);
-
-    ctxt = xmlCreateEntityParserCtxtInternal(URL, ID, NULL, ctx);
-    if (ctxt == NULL) {
-	return(-1);
-    }
-
-    oldsax = ctxt->sax;
-    ctxt->sax = ctx->sax;
-    xmlDetectSAX2(ctxt);
-    newDoc = xmlNewDoc(BAD_CAST "1.0");
-    if (newDoc == NULL) {
-	xmlFreeParserCtxt(ctxt);
-	return(-1);
-    }
-    newDoc->properties = XML_DOC_INTERNAL;
-    if (ctx->myDoc->dict) {
-	newDoc->dict = ctx->myDoc->dict;
-	xmlDictReference(newDoc->dict);
-    }
-    if (ctx->myDoc != NULL) {
-	newDoc->intSubset = ctx->myDoc->intSubset;
-	newDoc->extSubset = ctx->myDoc->extSubset;
-    }
-    if (ctx->myDoc->URL != NULL) {
-	newDoc->URL = xmlStrdup(ctx->myDoc->URL);
-    }
-    newRoot = xmlNewDocNode(newDoc, NULL, BAD_CAST "pseudoroot", NULL);
-    if (newRoot == NULL) {
-	ctxt->sax = oldsax;
-	xmlFreeParserCtxt(ctxt);
-	newDoc->intSubset = NULL;
-	newDoc->extSubset = NULL;
-        xmlFreeDoc(newDoc);
-	return(-1);
-    }
-    xmlAddChild((xmlNodePtr) newDoc, newRoot);
-    nodePush(ctxt, newDoc->children);
-    if (ctx->myDoc == NULL) {
-	ctxt->myDoc = newDoc;
-    } else {
-	ctxt->myDoc = ctx->myDoc;
-	newDoc->children->doc = ctx->myDoc;
-    }
-
-    /*
-     * Get the 4 first bytes and decode the charset
-     * if enc != XML_CHAR_ENCODING_NONE
-     * plug some encoding conversion routines.
-     */
-    GROW
-    if ((ctxt->input->end - ctxt->input->cur) >= 4) {
-	start[0] = RAW;
-	start[1] = NXT(1);
-	start[2] = NXT(2);
-	start[3] = NXT(3);
-	enc = xmlDetectCharEncoding(start, 4);
-	if (enc != XML_CHAR_ENCODING_NONE) {
-	    xmlSwitchEncoding(ctxt, enc);
-	}
-    }
-
     /*
-     * Parse a possible text declaration first
-     */
-    if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {
-	xmlParseTextDecl(ctxt);
-	/*
-	 * An XML-1.0 document can't reference an entity not XML-1.0
-	 */
-	if ((xmlStrEqual(ctx->version, BAD_CAST "1.0")) &&
-	    (!xmlStrEqual(ctxt->input->version, BAD_CAST "1.0"))) {
-	    xmlFatalErrMsg(ctxt, XML_ERR_VERSION_MISMATCH,
-	                   "Version mismatch between document and entity\n");
-	}
-    }
-
-    /*
-     * If the user provided its own SAX callbacks then reuse the
-     * useData callback field, otherwise the expected setup in a
+     * If the user provided their own SAX callbacks, then reuse the
+     * userData callback field, otherwise the expected setup in a
      * DOM builder is to have userData == ctxt
      */
     if (ctx->userData == ctx)
-        ctxt->userData = ctxt;
+        userData = NULL;
     else
-        ctxt->userData = ctx->userData;
-
-    /*
-     * Doing validity checking on chunk doesn't make sense
-     */
-    ctxt->instate = XML_PARSER_CONTENT;
-    ctxt->validate = ctx->validate;
-    ctxt->valid = ctx->valid;
-    ctxt->loadsubset = ctx->loadsubset;
-    ctxt->depth = ctx->depth + 1;
-    ctxt->replaceEntities = ctx->replaceEntities;
-    if (ctxt->validate) {
-	ctxt->vctxt.error = ctx->vctxt.error;
-	ctxt->vctxt.warning = ctx->vctxt.warning;
-    } else {
-	ctxt->vctxt.error = NULL;
-	ctxt->vctxt.warning = NULL;
-    }
-    ctxt->vctxt.nodeTab = NULL;
-    ctxt->vctxt.nodeNr = 0;
-    ctxt->vctxt.nodeMax = 0;
-    ctxt->vctxt.node = NULL;
-    if (ctxt->dict != NULL) xmlDictFree(ctxt->dict);
-    ctxt->dict = ctx->dict;
-    ctxt->str_xml = xmlDictLookup(ctxt->dict, BAD_CAST "xml", 3);
-    ctxt->str_xmlns = xmlDictLookup(ctxt->dict, BAD_CAST "xmlns", 5);
-    ctxt->str_xml_ns = xmlDictLookup(ctxt->dict, XML_XML_NAMESPACE, 36);
-    ctxt->dictNames = ctx->dictNames;
-    ctxt->attsDefault = ctx->attsDefault;
-    ctxt->attsSpecial = ctx->attsSpecial;
-    ctxt->linenumbers = ctx->linenumbers;
-
-    xmlParseContent(ctxt);
-
-    ctx->validate = ctxt->validate;
-    ctx->valid = ctxt->valid;
-    if ((RAW == '<') && (NXT(1) == '/')) {
-	xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
-    } else if (RAW != 0) {
-	xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);
-    }
-    if (ctxt->node != newDoc->children) {
-	xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
-    }
-
-    if (!ctxt->wellFormed) {
-        if (ctxt->errNo == 0)
-	    ret = 1;
-	else
-	    ret = ctxt->errNo;
-    } else {
-	if (lst != NULL) {
-	    xmlNodePtr cur;
-
-	    /*
-	     * Return the newly created nodeset after unlinking it from
-	     * they pseudo parent.
-	     */
-	    cur = newDoc->children->children;
-	    *lst = cur;
-	    while (cur != NULL) {
-		cur->parent = NULL;
-		cur = cur->next;
-	    }
-            newDoc->children->children = NULL;
-	}
-	ret = 0;
-    }
-    ctxt->sax = oldsax;
-    ctxt->dict = NULL;
-    ctxt->attsDefault = NULL;
-    ctxt->attsSpecial = NULL;
-    xmlFreeParserCtxt(ctxt);
-    newDoc->intSubset = NULL;
-    newDoc->extSubset = NULL;
-    xmlFreeDoc(newDoc);
-
-    return(ret);
+        userData = ctx->userData;
+    return xmlParseExternalEntityPrivate(ctx->myDoc, ctx, ctx->sax,
+                                         userData, ctx->depth + 1,
+                                         URL, ID, lst);
 }
 
 /**
  * xmlParseExternalEntityPrivate:
  * @doc:  the document the chunk pertains to
  * @oldctxt:  the previous parser context if available
- * @sax:  the SAX handler bloc (possibly NULL)
+ * @sax:  the SAX handler block (possibly NULL)
  * @user_data:  The user data returned on SAX callbacks (possibly NULL)
  * @depth:  Used for loop detection, use 0
  * @URL:  the URL for the entity to load
@@ -13127,25 +12962,6 @@ xmlParseExternalEntityPrivate(xmlDocPtr doc, xmlParserCtxtPtr oldctxt,
     ctxt = xmlCreateEntityParserCtxtInternal(URL, ID, NULL, oldctxt);
     if (ctxt == NULL) return(XML_WAR_UNDECLARED_ENTITY);
     ctxt->userData = ctxt;
-    if (oldctxt != NULL) {
-	ctxt->_private = oldctxt->_private;
-	ctxt->loadsubset = oldctxt->loadsubset;
-	ctxt->validate = oldctxt->validate;
-	ctxt->external = oldctxt->external;
-	ctxt->record_info = oldctxt->record_info;
-	ctxt->node_seq.maximum = oldctxt->node_seq.maximum;
-	ctxt->node_seq.length = oldctxt->node_seq.length;
-	ctxt->node_seq.buffer = oldctxt->node_seq.buffer;
-    } else {
-	/*
-	 * Doing validity checking on chunk without context
-	 * doesn't make sense
-	 */
-	ctxt->_private = NULL;
-	ctxt->validate = 0;
-	ctxt->external = 2;
-	ctxt->loadsubset = 0;
-    }
     if (sax != NULL) {
 	oldsax = ctxt->sax;
         ctxt->sax = sax;
@@ -13155,28 +12971,25 @@ xmlParseExternalEntityPrivate(xmlDocPtr doc, xmlParserCtxtPtr oldctxt,
     xmlDetectSAX2(ctxt);
     newDoc = xmlNewDoc(BAD_CAST "1.0");
     if (newDoc == NULL) {
-	ctxt->node_seq.maximum = 0;
-	ctxt->node_seq.length = 0;
-	ctxt->node_seq.buffer = NULL;
 	xmlFreeParserCtxt(ctxt);
 	return(XML_ERR_INTERNAL_ERROR);
     }
     newDoc->properties = XML_DOC_INTERNAL;
-    newDoc->intSubset = doc->intSubset;
-    newDoc->extSubset = doc->extSubset;
-    newDoc->dict = doc->dict;
-    xmlDictReference(newDoc->dict);
-
-    if (doc->URL != NULL) {
-	newDoc->URL = xmlStrdup(doc->URL);
+    if (doc) {
+        newDoc->intSubset = doc->intSubset;
+        newDoc->extSubset = doc->extSubset;
+        if (doc->dict) {
+            newDoc->dict = doc->dict;
+            xmlDictReference(newDoc->dict);
+        }
+        if (doc->URL != NULL) {
+            newDoc->URL = xmlStrdup(doc->URL);
+        }
     }
     newRoot = xmlNewDocNode(newDoc, NULL, BAD_CAST "pseudoroot", NULL);
     if (newRoot == NULL) {
 	if (sax != NULL)
 	    ctxt->sax = oldsax;
-	ctxt->node_seq.maximum = 0;
-	ctxt->node_seq.length = 0;
-	ctxt->node_seq.buffer = NULL;
 	xmlFreeParserCtxt(ctxt);
 	newDoc->intSubset = NULL;
 	newDoc->extSubset = NULL;
@@ -13185,8 +12998,12 @@ xmlParseExternalEntityPrivate(xmlDocPtr doc, xmlParserCtxtPtr oldctxt,
     }
     xmlAddChild((xmlNodePtr) newDoc, newRoot);
     nodePush(ctxt, newDoc->children);
-    ctxt->myDoc = doc;
-    newRoot->doc = doc;
+    if (doc == NULL) {
+        ctxt->myDoc = newDoc;
+    } else {
+        ctxt->myDoc = doc;
+        newRoot->doc = doc;
+    }
 
     /*
      * Get the 4 first bytes and decode the charset
@@ -13210,10 +13027,53 @@ xmlParseExternalEntityPrivate(xmlDocPtr doc, xmlParserCtxtPtr oldctxt,
      */
     if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {
 	xmlParseTextDecl(ctxt);
+        /*
+         * An XML-1.0 document can't reference an entity not XML-1.0
+         */
+        if ((xmlStrEqual(oldctxt->version, BAD_CAST "1.0")) &&
+            (!xmlStrEqual(ctxt->input->version, BAD_CAST "1.0"))) {
+            xmlFatalErrMsg(ctxt, XML_ERR_VERSION_MISMATCH,
+                           "Version mismatch between document and entity\n");
+        }
     }
 
     ctxt->instate = XML_PARSER_CONTENT;
     ctxt->depth = depth;
+    if (oldctxt != NULL) {
+	ctxt->_private = oldctxt->_private;
+	ctxt->loadsubset = oldctxt->loadsubset;
+	ctxt->validate = oldctxt->validate;
+	ctxt->valid = oldctxt->valid;
+	ctxt->replaceEntities = oldctxt->replaceEntities;
+        if (oldctxt->validate) {
+            ctxt->vctxt.error = oldctxt->vctxt.error;
+            ctxt->vctxt.warning = oldctxt->vctxt.warning;
+            ctxt->vctxt.userData = oldctxt->vctxt.userData;
+        }
+	ctxt->external = oldctxt->external;
+        if (ctxt->dict) xmlDictFree(ctxt->dict);
+        ctxt->dict = oldctxt->dict;
+        ctxt->str_xml = xmlDictLookup(ctxt->dict, BAD_CAST "xml", 3);
+        ctxt->str_xmlns = xmlDictLookup(ctxt->dict, BAD_CAST "xmlns", 5);
+        ctxt->str_xml_ns = xmlDictLookup(ctxt->dict, XML_XML_NAMESPACE, 36);
+        ctxt->dictNames = oldctxt->dictNames;
+        ctxt->attsDefault = oldctxt->attsDefault;
+        ctxt->attsSpecial = oldctxt->attsSpecial;
+        ctxt->linenumbers = oldctxt->linenumbers;
+	ctxt->record_info = oldctxt->record_info;
+	ctxt->node_seq.maximum = oldctxt->node_seq.maximum;
+	ctxt->node_seq.length = oldctxt->node_seq.length;
+	ctxt->node_seq.buffer = oldctxt->node_seq.buffer;
+    } else {
+	/*
+	 * Doing validity checking on chunk without context
+	 * doesn't make sense
+	 */
+	ctxt->_private = NULL;
+	ctxt->validate = 0;
+	ctxt->external = 2;
+	ctxt->loadsubset = 0;
+    }
 
     xmlParseContent(ctxt);
 
@@ -13273,6 +13133,11 @@ xmlParseExternalEntityPrivate(xmlDocPtr doc, xmlParserCtxtPtr oldctxt,
     if (sax != NULL)
 	ctxt->sax = oldsax;
     if (oldctxt != NULL) {
+        ctxt->dict = NULL;
+        ctxt->attsDefault = NULL;
+        ctxt->attsSpecial = NULL;
+        oldctxt->validate = ctxt->validate;
+        oldctxt->valid = ctxt->valid;
         oldctxt->node_seq.maximum = ctxt->node_seq.maximum;
         oldctxt->node_seq.length = ctxt->node_seq.length;
         oldctxt->node_seq.buffer = ctxt->node_seq.buffer;
@@ -13292,7 +13157,7 @@ xmlParseExternalEntityPrivate(xmlDocPtr doc, xmlParserCtxtPtr oldctxt,
 /**
  * xmlParseExternalEntity:
  * @doc:  the document the chunk pertains to
- * @sax:  the SAX handler bloc (possibly NULL)
+ * @sax:  the SAX handler block (possibly NULL)
  * @user_data:  The user data returned on SAX callbacks (possibly NULL)
  * @depth:  Used for loop detection, use 0
  * @URL:  the URL for the entity to load
@@ -13318,8 +13183,8 @@ xmlParseExternalEntity(xmlDocPtr doc, xmlSAXHandlerPtr sax, void *user_data,
 
 /**
  * xmlParseBalancedChunkMemory:
- * @doc:  the document the chunk pertains to
- * @sax:  the SAX handler bloc (possibly NULL)
+ * @doc:  the document the chunk pertains to (must not be NULL)
+ * @sax:  the SAX handler block (possibly NULL)
  * @user_data:  The user data returned on SAX callbacks (possibly NULL)
  * @depth:  Used for loop detection, use 0
  * @string:  the input string in UTF8 or ISO-Latin (zero terminated)
@@ -13770,8 +13635,8 @@ xmlParseInNodeContext(xmlNodePtr node, const char *data, int datalen,
 #ifdef LIBXML_SAX1_ENABLED
 /**
  * xmlParseBalancedChunkMemoryRecover:
- * @doc:  the document the chunk pertains to
- * @sax:  the SAX handler bloc (possibly NULL)
+ * @doc:  the document the chunk pertains to (must not be NULL)
+ * @sax:  the SAX handler block (possibly NULL)
  * @user_data:  The user data returned on SAX callbacks (possibly NULL)
  * @depth:  Used for loop detection, use 0
  * @string:  the input string in UTF8 or ISO-Latin (zero terminated)
@@ -13842,6 +13707,7 @@ xmlParseBalancedChunkMemoryRecover(xmlDocPtr doc, xmlSAXHandlerPtr sax,
     } else {
 	xmlCtxtUseOptionsInternal(ctxt, XML_PARSE_NODICT, NULL);
     }
+    /* doc == NULL is only supported for historic reasons */
     if (doc != NULL) {
 	newDoc->intSubset = doc->intSubset;
 	newDoc->extSubset = doc->extSubset;
@@ -13858,6 +13724,7 @@ xmlParseBalancedChunkMemoryRecover(xmlDocPtr doc, xmlSAXHandlerPtr sax,
     }
     xmlAddChild((xmlNodePtr) newDoc, newRoot);
     nodePush(ctxt, newRoot);
+    /* doc == NULL is only supported for historic reasons */
     if (doc == NULL) {
 	ctxt->myDoc = newDoc;
     } else {
@@ -13927,8 +13794,8 @@ xmlParseBalancedChunkMemoryRecover(xmlDocPtr doc, xmlSAXHandlerPtr sax,
     xmlFreeParserCtxt(ctxt);
     newDoc->intSubset = NULL;
     newDoc->extSubset = NULL;
-    if(doc != NULL)
-	newDoc->oldNs = NULL;
+    /* This leaks the namespace list if doc == NULL */
+    newDoc->oldNs = NULL;
     xmlFreeDoc(newDoc);
 
     return(ret);
@@ -14210,7 +14077,7 @@ xmlSAXParseFileWithData(xmlSAXHandlerPtr sax, const char *filename,
 
     if ((ctxt->wellFormed) || recovery) {
         ret = ctxt->myDoc;
-	if (ret != NULL) {
+	if ((ret != NULL) && (ctxt->input->buf != NULL)) {
 	    if (ctxt->input->buf->compressed > 0)
 		ret->compression = 9;
 	    else
@@ -14741,6 +14608,10 @@ xmlInitParser(void) {
     if (xmlParserInitialized != 0)
 	return;
 
+#if defined(_WIN32) && (!defined(LIBXML_STATIC) || defined(LIBXML_STATIC_FOR_DLL))
+	atexit(xmlCleanupParser);
+#endif
+
 #ifdef LIBXML_THREAD_ENABLED
     __xmlGlobalInitMutexLock();
     if (xmlParserInitialized == 0) {
@@ -14819,6 +14690,20 @@ xmlCleanupParser(void) {
     xmlParserInitialized = 0;
 }
 
+#if defined(HAVE_ATTRIBUTE_DESTRUCTOR) && !defined(LIBXML_STATIC) && \
+    !defined(_WIN32)
+static void
+ATTRIBUTE_DESTRUCTOR
+xmlDestructor(void) {
+    /*
+     * Calling custom deallocation functions in a destructor can cause
+     * problems, for example with Nokogiri.
+     */
+    if (xmlFree == free)
+        xmlCleanupParser();
+}
+#endif
+
 /************************************************************************
  *									*
  *	New set (2.6.0) of simpler and more flexible APIs		*
@@ -14907,7 +14792,6 @@ xmlCtxtReset(xmlParserCtxtPtr ctxt)
     ctxt->vctxt.warning = xmlParserValidityWarning;
 #endif
     ctxt->record_info = 0;
-    ctxt->nbChars = 0;
     ctxt->checkIndex = 0;
     ctxt->inSubset = 0;
     ctxt->errNo = XML_ERR_OK;
diff --git a/parserInternals.c b/parserInternals.c
index b00cd08e..b0629ef3 100644
--- a/parserInternals.c
+++ b/parserInternals.c
@@ -105,7 +105,7 @@ xmlCheckVersion(int version) {
 /**
  * xmlErrMemory:
  * @ctxt:  an XML parser context
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle a redefinition of attribute error
  */
@@ -165,7 +165,7 @@ __xmlErrEncoding(xmlParserCtxtPtr ctxt, xmlParserErrors xmlerr,
  * xmlErrInternal:
  * @ctxt:  an XML parser context
  * @msg:  the error message
- * @str:  error informations
+ * @str:  error information
  *
  * Handle an internal error
  */
@@ -519,8 +519,6 @@ xmlNextChar(xmlParserCtxtPtr ctxt)
         } else
             /* 1-byte code */
             ctxt->input->cur++;
-
-        ctxt->nbChars++;
     } else {
         /*
          * Assume it's a fixed length encoding (1) with
@@ -533,7 +531,6 @@ xmlNextChar(xmlParserCtxtPtr ctxt)
         } else
             ctxt->input->col++;
         ctxt->input->cur++;
-        ctxt->nbChars++;
     }
     if (*ctxt->input->cur == 0)
         xmlParserInputGrow(ctxt->input, INPUT_CHUNK);
@@ -677,7 +674,6 @@ xmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {
 	    }
 	    if (*ctxt->input->cur == 0xD) {
 		if (ctxt->input->cur[1] == 0xA) {
-		    ctxt->nbChars++;
 		    ctxt->input->cur++;
 		}
 		return(0xA);
@@ -693,7 +689,6 @@ xmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {
     *len = 1;
     if (*ctxt->input->cur == 0xD) {
 	if (ctxt->input->cur[1] == 0xA) {
-	    ctxt->nbChars++;
 	    ctxt->input->cur++;
 	}
 	return(0xA);
@@ -1748,7 +1743,6 @@ xmlInitParserCtxt(xmlParserCtxtPtr ctxt)
         ctxt->options |= XML_PARSE_NOENT;
     }
     ctxt->record_info = 0;
-    ctxt->nbChars = 0;
     ctxt->checkIndex = 0;
     ctxt->inSubset = 0;
     ctxt->errNo = XML_ERR_OK;
@@ -1877,7 +1871,7 @@ xmlNewParserCtxt(void)
 
 /************************************************************************
  *									*
- *		Handling of node informations				*
+ *		Handling of node information				*
  *									*
  ************************************************************************/
 
diff --git a/python/generator.py b/python/generator.py
index c0cb3add..59d45e00 100755
--- a/python/generator.py
+++ b/python/generator.py
@@ -393,7 +393,7 @@ def print_function_wrapper(name, output, export, include):
                 format_args = format_args + ", &%s" % (arg[0])
             if f == 's#':
                 format_args = format_args + ", &py_buffsize%d" % num_bufs
-                c_args = c_args + "    int py_buffsize%d;\n" % num_bufs
+                c_args = c_args + "    Py_ssize_t  py_buffsize%d;\n" % num_bufs
                 num_bufs = num_bufs + 1
             if c_call != "":
                 c_call = c_call + ", "
@@ -555,6 +555,7 @@ def buildStubs():
     export.write("/* Generated */\n\n")
     wrapper = open("libxml2-py.c", "w")
     wrapper.write("/* Generated */\n\n")
+    wrapper.write("#define PY_SSIZE_T_CLEAN\n")
     wrapper.write("#include <Python.h>\n")
     wrapper.write("#include <libxml/xmlversion.h>\n")
     wrapper.write("#include <libxml/tree.h>\n")
diff --git a/python/libxml.c b/python/libxml.c
index bc676c4e..3b66bd61 100644
--- a/python/libxml.c
+++ b/python/libxml.c
@@ -11,6 +11,7 @@
  *
  * daniel@veillard.com
  */
+#define PY_SSIZE_T_CLEAN
 #include <Python.h>
 #include <fileobject.h>
 /* #include "config.h" */
@@ -294,7 +295,7 @@ xmlPythonFileReadRaw (void * context, char * buffer, int len) {
 	lenread = PyBytes_Size(ret);
 	data = PyBytes_AsString(ret);
 #ifdef PyUnicode_Check
-    } else if PyUnicode_Check (ret) {
+    } else if (PyUnicode_Check (ret)) {
 #if PY_VERSION_HEX >= 0x03030000
         Py_ssize_t size;
 	const char *tmp;
@@ -359,7 +360,7 @@ xmlPythonFileRead (void * context, char * buffer, int len) {
 	lenread = PyBytes_Size(ret);
 	data = PyBytes_AsString(ret);
 #ifdef PyUnicode_Check
-    } else if PyUnicode_Check (ret) {
+    } else if (PyUnicode_Check (ret)) {
 #if PY_VERSION_HEX >= 0x03030000
         Py_ssize_t size;
 	const char *tmp;
@@ -1048,10 +1049,10 @@ pythonCharacters(void *user_data, const xmlChar * ch, int len)
     if (type != 0) {
         if (type == 1)
             result = PyObject_CallMethod(handler, (char *) "characters",
-                                         (char *) "s#", ch, len);
+                                         (char *) "s#", ch, (Py_ssize_t)len);
         else if (type == 2)
             result = PyObject_CallMethod(handler, (char *) "data",
-                                         (char *) "s#", ch, len);
+                                         (char *) "s#", ch, (Py_ssize_t)len);
         if (PyErr_Occurred())
             PyErr_Print();
         Py_XDECREF(result);
@@ -1078,11 +1079,11 @@ pythonIgnorableWhitespace(void *user_data, const xmlChar * ch, int len)
             result =
                 PyObject_CallMethod(handler,
                                     (char *) "ignorableWhitespace",
-                                    (char *) "s#", ch, len);
+                                    (char *) "s#", ch, (Py_ssize_t)len);
         else if (type == 2)
             result =
                 PyObject_CallMethod(handler, (char *) "data",
-                                    (char *) "s#", ch, len);
+                                    (char *) "s#", ch, (Py_ssize_t)len);
         Py_XDECREF(result);
     }
 }
@@ -1223,11 +1224,11 @@ pythonCdataBlock(void *user_data, const xmlChar * ch, int len)
         if (type == 1)
             result =
                 PyObject_CallMethod(handler, (char *) "cdataBlock",
-                                    (char *) "s#", ch, len);
+                                    (char *) "s#", ch, (Py_ssize_t)len);
         else if (type == 2)
             result =
                 PyObject_CallMethod(handler, (char *) "cdata",
-                                    (char *) "s#", ch, len);
+                                    (char *) "s#", ch, (Py_ssize_t)len);
         if (PyErr_Occurred())
             PyErr_Print();
         Py_XDECREF(result);
diff --git a/python/libxml.py b/python/libxml.py
index 2466cc9f..1e458d17 100644
--- a/python/libxml.py
+++ b/python/libxml.py
@@ -392,7 +392,7 @@ class xmlCore:
         last = property(get_last, None, None, "Last sibling node")
         next = property(get_next, None, None, "Next sibling node")
         prev = property(get_prev, None, None, "Previous sibling node")
-        properties = property(get_properties, None, None, "List of properies")
+        properties = property(get_properties, None, None, "List of properties")
         content = property(get_content, None, None, "Content of this node")
         name = property(get_name, None, None, "Node name")
         type = property(get_type, None, None, "Node type")
diff --git a/python/libxml2-python-api.xml b/python/libxml2-python-api.xml
index 032b44ba..e84faad6 100644
--- a/python/libxml2-python-api.xml
+++ b/python/libxml2-python-api.xml
@@ -60,13 +60,13 @@
       <info>Create a libxml2 output buffer from a Python file</info>
       <return type='xmlOutputBufferPtr' info="the output buffer"/>
       <arg name='file' type='pythonObject' info='the Python file'/>
-      <arg name='encoding' type='xmlChar *' info='an optionnal encoding'/>
+      <arg name='encoding' type='xmlChar *' info='an optional encoding'/>
     </function>
     <function name='xmlCreateInputBuffer' file='python'>
       <info>Create a libxml2 input buffer from a Python file</info>
       <return type='xmlParserInputBufferPtr' info="the input buffer"/>
       <arg name='file' type='pythonObject' info='the Python file'/>
-      <arg name='encoding' type='xmlChar *' info='an optionnal encoding'/>
+      <arg name='encoding' type='xmlChar *' info='an optional encoding'/>
     </function>
     <function name='xmlSetEntityLoader' file='python'>
       <info>Set the entity resolver as a python function</info>
diff --git a/python/tests/nsdel.py b/python/tests/nsdel.py
index 079399a0..8558248c 100755
--- a/python/tests/nsdel.py
+++ b/python/tests/nsdel.py
@@ -42,7 +42,7 @@ checkNamespaceDefs(node, 0)
 ns.freeNsList()
 doc.freeDoc()
 
-# Remove a namespace refered to by a child
+# Remove a namespace referred to by a child
 doc = libxml2.newDoc("1.0")
 root = doc.newChild(None, "root", None)
 namespace = root.newNs("http://example.com/sample", "s")
diff --git a/python/tests/reader2.py b/python/tests/reader2.py
index 85705750..b50180df 100755
--- a/python/tests/reader2.py
+++ b/python/tests/reader2.py
@@ -1,4 +1,5 @@
 #!/usr/bin/python -u
+# -*- coding: utf-8 -*-
 #
 # this tests the DTD validation with the XmlTextReader interface
 #
@@ -16,44 +17,131 @@ except:
 # Memory debug specific
 libxml2.debugMemory(1)
 
-err=""
-expect="""../../test/valid/rss.xml:177: element rss: validity error : Element rss does not carry attribute version
+err = ""
+dir_prefix = "../../test/valid/"
+# This dictionary reflects the contents of the files
+# ../../test/valid/*.xml.err that are not empty, except that
+# the file paths in the messages start with ../../test/
+
+expect = {
+    '766956':
+"""../../test/valid/dtds/766956.dtd:2: parser error : PEReference: expecting ';'
+%√§%ent;
+   ^
+../../test/valid/dtds/766956.dtd:2: parser error : Content error in the external subset
+%√§%ent;
+        ^
+Entity: line 1: 
+value
+^
+""",
+    '781333':
+"""../../test/valid/781333.xml:4: element a: validity error : Element a content does not follow the DTD, expecting ( ..., got 
+<a/>
+    ^
+../../test/valid/781333.xml:5: element a: validity error : Element a content does not follow the DTD, Expecting more child
+
+^
+""",
+    'cond_sect2':
+"""../../test/valid/dtds/cond_sect2.dtd:15: parser error : All markup of the conditional section is not in the same entity
+    %ent;
+         ^
+Entity: line 1: 
+]]>
+^
+../../test/valid/dtds/cond_sect2.dtd:17: parser error : Content error in the external subset
+
+^
+""",
+    'rss':
+"""../../test/valid/rss.xml:177: element rss: validity error : Element rss does not carry attribute version
 </rss>
       ^
-../../test/valid/xlink.xml:450: element termdef: validity error : ID dt-arc already defined
+""",
+    't8':
+"""../../test/valid/t8.xml:6: parser error : internal error: xmlParseInternalSubset: error detected in Markup declaration
+
+%defroot; %defmiddle; %deftest;
+         ^
+Entity: line 1: 
+&lt;!ELEMENT root (middle) >
+^
+../../test/valid/t8.xml:6: parser error : internal error: xmlParseInternalSubset: error detected in Markup declaration
+
+%defroot; %defmiddle; %deftest;
+                     ^
+Entity: line 1: 
+&lt;!ELEMENT middle (test) >
+^
+../../test/valid/t8.xml:6: parser error : internal error: xmlParseInternalSubset: error detected in Markup declaration
+
+%defroot; %defmiddle; %deftest;
+                               ^
+Entity: line 1: 
+&lt;!ELEMENT test (#PCDATA) >
+^
+""",
+    't8a':
+"""../../test/valid/t8a.xml:6: parser error : internal error: xmlParseInternalSubset: error detected in Markup declaration
+
+%defroot;%defmiddle;%deftest;
+         ^
+Entity: line 1: 
+&lt;!ELEMENT root (middle) >
+^
+../../test/valid/t8a.xml:6: parser error : internal error: xmlParseInternalSubset: error detected in Markup declaration
+
+%defroot;%defmiddle;%deftest;
+                    ^
+Entity: line 1: 
+&lt;!ELEMENT middle (test) >
+^
+../../test/valid/t8a.xml:6: parser error : internal error: xmlParseInternalSubset: error detected in Markup declaration
+
+%defroot;%defmiddle;%deftest;
+                             ^
+Entity: line 1: 
+&lt;!ELEMENT test (#PCDATA) >
+^
+""",
+    'xlink':
+"""../../test/valid/xlink.xml:450: element termdef: validity error : ID dt-arc already defined
 	<p><termdef id="dt-arc" term="Arc">An <ter
 	                                  ^
-../../test/valid/xlink.xml:530: validity error : attribute def line 199 references an unknown ID "dt-xlg"
+validity error : attribute def line 199 references an unknown ID "dt-xlg"
+""",
+}
+
+# Add prefix_dir and extension to the keys
+expect = {"{}{}.xml".format(dir_prefix, key): val for key, val in expect.items()}
 
-^
-"""
 def callback(ctx, str):
     global err
     err = err + "%s" % (str)
 libxml2.registerErrorHandler(callback, "")
 
-valid_files = glob.glob("../../test/valid/*.x*")
+parsing_error_files = ["766956", "cond_sect2", "t8", "t8a"]
+expect_parsing_error = ["{}{}.xml".format(dir_prefix, f) for f in parsing_error_files]
+
+valid_files = glob.glob(dir_prefix + "*.x*")
 valid_files.sort()
 for file in valid_files:
-    if file.find("t8") != -1:
-        continue
-    if file == "../../test/valid/rss.xml":
-        continue
-    if file == "../../test/valid/xlink.xml":
-        continue
+    err = ""
     reader = libxml2.newTextReaderFilename(file)
     #print "%s:" % (file)
     reader.SetParserProp(libxml2.PARSER_VALIDATE, 1)
     ret = reader.Read()
     while ret == 1:
         ret = reader.Read()
-    if ret != 0:
+    if ret != 0 and file not in expect_parsing_error:
         print("Error parsing and validating %s" % (file))
-	#sys.exit(1)
-
-if err != expect:
-    print(err)
-
+        #sys.exit(1)
+    if (err):
+        if not(file in expect and err == expect[file]):
+            print("Error: ", err)
+            if file in expect:
+                print("Expected: ", expect[file])
 #
 # another separate test based on Stephane Bidoul one
 #
diff --git a/python/tests/tstLastError.py b/python/tests/tstLastError.py
index 81d0acc4..1758a9fb 100755
--- a/python/tests/tstLastError.py
+++ b/python/tests/tstLastError.py
@@ -25,7 +25,10 @@ class TestCase(unittest.TestCase):
         when the exception is raised, check the libxml2.lastError for
         expected values."""
         # disable the default error handler
-        libxml2.registerErrorHandler(None,None)
+        def noerr(ctx, str):
+            pass
+        # None is not acceptable as function.
+        libxml2.registerErrorHandler(noerr,None)
         try:
             f(*args)
         except exc:
@@ -40,12 +43,12 @@ class TestCase(unittest.TestCase):
                 print("file =",e.file())
                 print("line =",e.line())
                 print()
-            self.failUnlessEqual(domain,e.domain())
-            self.failUnlessEqual(code,e.code())
-            self.failUnlessEqual(message,e.message())
-            self.failUnlessEqual(level,e.level())
-            self.failUnlessEqual(file,e.file())
-            self.failUnlessEqual(line,e.line())
+            self.assertEqual(domain,e.domain())
+            self.assertEqual(code,e.code())
+            self.assertEqual(message,e.message())
+            self.assertEqual(level,e.level())
+            self.assertEqual(file,e.file())
+            self.assertEqual(line,e.line())
         else:
             self.fail("exception %s should have been raised" % exc)
 
diff --git a/python/tests/validate.py b/python/tests/validate.py
index 16c0386f..cec9cb0f 100755
--- a/python/tests/validate.py
+++ b/python/tests/validate.py
@@ -36,7 +36,7 @@ while i > 0:
         sys.exit(1)
     i = i - 1
 
-#desactivate error messages from the validation
+#deactivate error messages from the validation
 def noerr(ctx, str):
     pass
 
diff --git a/python/types.c b/python/types.c
index c2bafeb1..ed284ec7 100644
--- a/python/types.c
+++ b/python/types.c
@@ -602,16 +602,16 @@ libxml_xmlXPathObjectPtrConvert(PyObject *obj)
     if (obj == NULL) {
         return (NULL);
     }
-    if PyFloat_Check (obj) {
+    if (PyFloat_Check (obj)) {
         ret = xmlXPathNewFloat((double) PyFloat_AS_DOUBLE(obj));
-    } else if PyLong_Check(obj) {
+    } else if (PyLong_Check(obj)) {
 #ifdef PyLong_AS_LONG
         ret = xmlXPathNewFloat((double) PyLong_AS_LONG(obj));
 #else
         ret = xmlXPathNewFloat((double) PyInt_AS_LONG(obj));
 #endif
 #ifdef PyBool_Check
-    } else if PyBool_Check (obj) {
+    } else if (PyBool_Check (obj)) {
 
         if (obj == Py_True) {
           ret = xmlXPathNewBoolean(1);
@@ -620,14 +620,14 @@ libxml_xmlXPathObjectPtrConvert(PyObject *obj)
           ret = xmlXPathNewBoolean(0);
         }
 #endif
-    } else if PyBytes_Check (obj) {
+    } else if (PyBytes_Check (obj)) {
         xmlChar *str;
 
         str = xmlStrndup((const xmlChar *) PyBytes_AS_STRING(obj),
                          PyBytes_GET_SIZE(obj));
         ret = xmlXPathWrapString(str);
 #ifdef PyUnicode_Check
-    } else if PyUnicode_Check (obj) {
+    } else if (PyUnicode_Check (obj)) {
 #if PY_VERSION_HEX >= 0x03030000
         xmlChar *str;
 	const char *tmp;
@@ -650,7 +650,7 @@ libxml_xmlXPathObjectPtrConvert(PyObject *obj)
 	ret = xmlXPathWrapString(str);
 #endif
 #endif
-    } else if PyList_Check (obj) {
+    } else if (PyList_Check (obj)) {
         int i;
         PyObject *node;
         xmlNodePtr cur;
diff --git a/relaxng.c b/relaxng.c
index 13fd954c..0ceecb58 100644
--- a/relaxng.c
+++ b/relaxng.c
@@ -430,7 +430,7 @@ struct _xmlRelaxNGDocument {
 /**
  * xmlRngPErrMemory:
  * @ctxt:  an Relax-NG parser context
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle a redefinition of attribute error
  */
@@ -465,7 +465,7 @@ xmlRngPErrMemory(xmlRelaxNGParserCtxtPtr ctxt, const char *extra)
 /**
  * xmlRngVErrMemory:
  * @ctxt:  a Relax-NG validation context
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle a redefinition of attribute error
  */
@@ -1409,7 +1409,7 @@ xmlRelaxNGFreeValidState(xmlRelaxNGValidCtxtPtr ctxt,
  * @ctxt: a RelaxNG parser context
  * @flags: a set of flags values
  *
- * Semi private function used to pass informations to a parser context
+ * Semi private function used to pass information to a parser context
  * which are a combination of xmlRelaxNGParserFlag .
  *
  * Returns 0 if success and -1 in case of error
@@ -8165,7 +8165,7 @@ xmlRelaxNGElemPop(xmlRelaxNGValidCtxtPtr ctxt)
  @ @inputdata:  callback data, the Relax NG validation context
  *
  * Handle the callback and if needed validate the element children.
- * some of the in/out informations are passed via the context in @inputdata.
+ * some of the in/out information are passed via the context in @inputdata.
  */
 static void
 xmlRelaxNGValidateProgressiveCallback(xmlRegExecCtxtPtr exec
@@ -11000,7 +11000,7 @@ xmlRelaxNGFreeValidCtxt(xmlRelaxNGValidCtxtPtr ctxt)
  * @warn: the warning function
  * @ctx: the functions context
  *
- * Set the error and warning callback informations
+ * Set the error and warning callback information
  */
 void
 xmlRelaxNGSetValidErrors(xmlRelaxNGValidCtxtPtr ctxt,
@@ -11042,7 +11042,7 @@ xmlRelaxNGSetValidStructuredErrors(xmlRelaxNGValidCtxtPtr ctxt,
  * @warn: the warning function result
  * @ctx: the functions context result
  *
- * Get the error and warning callback informations
+ * Get the error and warning callback information
  *
  * Returns -1 in case of error and 0 otherwise
  */
diff --git a/result/HTML/758606.html b/result/HTML/758606.html
index 4f21f628..3974ca90 100644
--- a/result/HTML/758606.html
+++ b/result/HTML/758606.html
@@ -1,2 +1,2 @@
-<!DOCTYPE >
+<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
 
diff --git a/result/HTML/758606.html.err b/result/HTML/758606.html.err
index 060433a8..e3e61265 100644
--- a/result/HTML/758606.html.err
+++ b/result/HTML/758606.html.err
@@ -1,16 +1,7 @@
-./test/HTML/758606.html:1: HTML parser error : Comment not terminated 
-<!--
+./test/HTML/758606.html:1: HTML parser error : Invalid char in comment 0xC
 <!--<!doctype
-    ^
-./test/HTML/758606.html:1: HTML parser error : Invalid char in CDATA 0xC
-<!--<!doctype
-    ^
-./test/HTML/758606.html:1: HTML parser error : Misplaced DOCTYPE declaration
-<!--<!doctype
-     ^
-./test/HTML/758606.html:2: HTML parser error : htmlParseDocTypeDecl : no DOCTYPE name !
-
-^
-./test/HTML/758606.html:2: HTML parser error : DOCTYPE improperly terminated
+      ^
+./test/HTML/758606.html:2: HTML parser error : Comment not terminated 
+<!--<!doctyp
 
 ^
diff --git a/result/HTML/758606.html.sax b/result/HTML/758606.html.sax
index d44a5cf4..a21a9f82 100644
--- a/result/HTML/758606.html.sax
+++ b/result/HTML/758606.html.sax
@@ -1,10 +1,6 @@
 SAX.setDocumentLocator()
 SAX.startDocument()
+SAX.error: Invalid char in comment 0xC
 SAX.error: Comment not terminated 
-<!--
-SAX.error: Invalid char in CDATA 0xC
-SAX.error: Misplaced DOCTYPE declaration
-SAX.error: htmlParseDocTypeDecl : no DOCTYPE name !
-SAX.error: DOCTYPE improperly terminated
-SAX.internalSubset((null), , )
+<!--<!doctyp
 SAX.endDocument()
diff --git a/result/HTML/758606_2.html b/result/HTML/758606_2.html
index 273816a0..3974ca90 100644
--- a/result/HTML/758606_2.html
+++ b/result/HTML/758606_2.html
@@ -1,2 +1,2 @@
-<!DOCTYPE >
-<html><body><p>&#145;</p></body></html>
+<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
+
diff --git a/result/HTML/758606_2.html.err b/result/HTML/758606_2.html.err
index 4be039f4..e9bf4060 100644
--- a/result/HTML/758606_2.html.err
+++ b/result/HTML/758606_2.html.err
@@ -1,16 +1,7 @@
-./test/HTML/758606_2.html:1: HTML parser error : Comment not terminated 
-<!--
-<!--ë<!dOctYPE
-    ^
-./test/HTML/758606_2.html:1: HTML parser error : Invalid char in CDATA 0xC
-<!--ë<!dOctYPE
-    ^
-./test/HTML/758606_2.html:1: HTML parser error : Misplaced DOCTYPE declaration
+./test/HTML/758606_2.html:1: HTML parser error : Invalid char in comment 0xC
 ¬ë<!dOctYPE
   ^
-./test/HTML/758606_2.html:2: HTML parser error : htmlParseDocTypeDecl : no DOCTYPE name !
-
-^
-./test/HTML/758606_2.html:2: HTML parser error : DOCTYPE improperly terminated
+./test/HTML/758606_2.html:2: HTML parser error : Comment not terminated 
+<!--¬ë<!dOctYP
 
 ^
diff --git a/result/HTML/758606_2.html.sax b/result/HTML/758606_2.html.sax
index 80ff3d77..8a46d9ca 100644
--- a/result/HTML/758606_2.html.sax
+++ b/result/HTML/758606_2.html.sax
@@ -1,17 +1,6 @@
 SAX.setDocumentLocator()
 SAX.startDocument()
+SAX.error: Invalid char in comment 0xC
 SAX.error: Comment not terminated 
-<!--
-SAX.error: Invalid char in CDATA 0xC
-SAX.startElement(html)
-SAX.startElement(body)
-SAX.startElement(p)
-SAX.characters(&#145;, 2)
-SAX.error: Misplaced DOCTYPE declaration
-SAX.error: htmlParseDocTypeDecl : no DOCTYPE name !
-SAX.error: DOCTYPE improperly terminated
-SAX.internalSubset((null), , )
-SAX.endElement(p)
-SAX.endElement(body)
-SAX.endElement(html)
+<!--¬ë<!dOctYP
 SAX.endDocument()
diff --git a/result/HTML/chunked_attr.html b/result/HTML/chunked_attr.html
new file mode 100644
index 00000000..2fd71a6e
--- /dev/null
+++ b/result/HTML/chunked_attr.html
@@ -0,0 +1,46 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
+<html>
+<!--
+This tests internal state tracking of the push parser and assumes a chunk
+size of 4096 (or a divisor of 4096) and an initial chunk of size 4.
+Make sure that the first '<' in the attribute value ends up near
+offset 4100.
+-->
+<body>
+<p>
+Filler bytes follow:
+
+      100 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      200 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      300 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      400 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      500 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      600 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      700 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      800 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      900 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+     1000 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      100 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      200 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      300 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      400 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      500 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      600 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      700 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      800 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      900 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+     2000 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      100 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      200 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      300 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      400 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      500 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      600 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      700 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      800 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+xxx
+</p>
+<div fill1="123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789" onmouseover="x&lt;b&gt;text&lt;/b&gt;x" fill2="123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789" fill3="123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789" fill4="123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789" fill5="123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789" fill6="123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789">
+</div>
+</body>
+</html>
diff --git a/result/HTML/chunked_attr.html.err b/result/HTML/chunked_attr.html.err
new file mode 100644
index 00000000..e69de29b
diff --git a/result/HTML/chunked_attr.html.sax b/result/HTML/chunked_attr.html.sax
new file mode 100644
index 00000000..5f9e9702
--- /dev/null
+++ b/result/HTML/chunked_attr.html.sax
@@ -0,0 +1,41 @@
+SAX.setDocumentLocator()
+SAX.startDocument()
+SAX.startElement(html)
+SAX.characters(
+, 1)
+SAX.comment(
+This tests internal state tracking of the push parser and assumes a chunk
+size of 4096 (or a divisor of 4096) and an initial chunk of size 4.
+Make sure that the first '<' in the attribute value ends up near
+offset 4100.
+)
+SAX.characters(
+, 1)
+SAX.startElement(body)
+SAX.characters(
+, 1)
+SAX.startElement(p)
+SAX.characters(
+Filler bytes follow:
+
+      1, 1000)
+SAX.characters(89 123456789 123456789
+      1, 1000)
+SAX.characters(89 123456789 123456789
+      1, 827)
+SAX.endElement(p)
+SAX.characters(
+, 1)
+SAX.startElement(div, fill1='123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789', onmouseover='x&lt;b&gt;text&lt;/b&gt;x', fill2='123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789', fill3='123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789', fill4='123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789', fill5='123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789', fill6='123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789')
+SAX.characters(
+, 1)
+SAX.endElement(div)
+SAX.characters(
+, 1)
+SAX.endElement(body)
+SAX.characters(
+, 1)
+SAX.endElement(html)
+SAX.characters(
+, 1)
+SAX.endDocument()
diff --git a/result/HTML/doc3.htm b/result/HTML/doc3.htm
index e9d5e448..2cc68b9b 100644
--- a/result/HTML/doc3.htm
+++ b/result/HTML/doc3.htm
@@ -521,7 +521,6 @@ eval("page" + id + " = window.open(URL, '" + id + "', 'toolbars=0, scrollbars=0,
 							document.write("ype=js&size=100x90&url=http://www.goto.com/");
 							document.write("d/search/ssn/&target=_blank&Partner=SSN8042");
 							document.write("DF8478957377>");
-							document.write("RIPT>");
 							} else {
 							document.write("<A TARGET=_blank ");
 							document.write("HREF=http://www.goto.com/d/search/ssn/?from");
diff --git a/result/HTML/doc3.htm.err b/result/HTML/doc3.htm.err
index cdf715a6..5e2491da 100644
--- a/result/HTML/doc3.htm.err
+++ b/result/HTML/doc3.htm.err
@@ -46,9 +46,9 @@ om/ad_static.asp?pid=2097&sid=1881&asid=7708"></a></IFRAME></CENTER></LI></FONT>
 ./test/HTML/doc3.htm:803: HTML parser error : End tag : expected '>'
 							document.write("DF8478957377></SC");
 							                                 ^
-./test/HTML/doc3.htm:803: HTML parser error : Unexpected end tag : sc
-							document.write("DF8478957377></SC");
-							                                 ^
+./test/HTML/doc3.htm:804: HTML parser error : Unexpected end tag : sc
+							document.write("RIPT>");
+							                     ^
 ./test/HTML/doc3.htm:811: HTML parser error : Unexpected end tag : a
 							document.write("ype=gif&size=100x90></A>");
 							                                        ^
diff --git a/result/HTML/doc3.htm.sax b/result/HTML/doc3.htm.sax
index fb33cf22..9237ad3c 100644
--- a/result/HTML/doc3.htm.sax
+++ b/result/HTML/doc3.htm.sax
@@ -2700,7 +2700,8 @@ SAX.cdata(");
 SAX.error: End tag : expected '>'
 SAX.error: Unexpected end tag : sc
 SAX.cdata(");
-							document.write("RI, 361)
+							} else {
+							d, 328)
 SAX.error: Unexpected end tag : a
 SAX.cdata(");
 							}
diff --git a/result/HTML/wired.html b/result/HTML/wired.html
index 74d366e3..3da303f8 100644
--- a/result/HTML/wired.html
+++ b/result/HTML/wired.html
@@ -462,13 +462,13 @@ or <a href="/news/pointcast/0,1366,,00.html">PointCast</a></font><br>
 
 <font size="2" face="Arial,Helvetica, sans-serif"><b><a href="/news/school/0,1383,,00.html">Making the Grade</a></b></font><br><font size="2" face="Arial, Helvetica, sans-serif"><font size="1" face="Arial, Geneva, sans-serif" color="#000000">Reading, writing, and ROM.  <br><i>Sponsored by <a href="http://r.hotwired.com/r/wn_sch_r_nav_uop/http://ads25.focalink.com/SmartBanner/page?12630.53" style="text-decoration:none"><font color="#000000">U of Phoenix</font></a></i></font><br><br> 
 
-<font size="2" face="Arial,Helvetica, sans-serif"><b><a href="/news/infostructure/0,1377,,00.html">Infostructure</a></b></font><br><font size="1" face="Arial, Helvetica, sans-serif" color="#000000">An IS/IT resource <br><i>Sponsored by <a href="http://r.wired.com/r/wn_is_r_ssec/http://ad.doubleclick.net/clk;653163;3599571;s?http://www.sprintbiz.com/s%0Aervlet/appservlet?from=/wired/sprint/&amp;template=/security/security.html&amp;SITE=%0Awired.com&amp;BANNER=Sprint" style="text-decoration:none"><font color="#000000">Sprint</font></a></i></font></font><br><br> 
+<font size="2" face="Arial,Helvetica, sans-serif"><b><a href="/news/infostructure/0,1377,,00.html">Infostructure</a></b></font><br><font size="1" face="Arial, Helvetica, sans-serif" color="#000000">An IS/IT resource <br><i>Sponsored by <a href="http://r.wired.com/r/wn_is_r_ssec/http://ad.doubleclick.net/clk;653163;3599571;s?http://www.sprintbiz.com/s%0Aervlet/appservlet?from=/wired/sprint/&amp;template=/security/security.html&amp;SITE=%0Awired.com&amp;BANNER=Sprint" style="text-decoration:none"><font color="#000000">Sprint</font></a></i></font><br><br> 
 
 <font size="2" face="Arial,Helvetica, sans-serif"><b><a href="/news/y2k/0,1360,,00.html">Y2K Watch</a></b></font><br><font size="2" face="Arial, Helvetica, sans-serif"><font size="1" face="Arial, Geneva, sans-serif" color="#000000">Tick... Tick... Tick...</font><br><br> 
 
 <font face="Arial, Helvetica, sans-serif" size="2"><b><i><a href="/news/special_reports/1,1293,,00.html">More Hoo-Ha</a></i></b></font><br>&nbsp;<br>
 
-</font></font></font></font></font></font></font></font>
+</font></font></font></font></font></font></font></font></font>
 </td>
 </tr>
 <!-- start of Gen News -->
diff --git a/result/HTML/wired.html.err b/result/HTML/wired.html.err
index 70db11b0..116bbd2f 100644
--- a/result/HTML/wired.html.err
+++ b/result/HTML/wired.html.err
@@ -242,6 +242,9 @@ com&BANNER=Sprint" style="text-decoration:none"><font color="#000000">Sprint</a>
 </td>
      ^
 ./test/HTML/wired.html:414: HTML parser error : Opening and ending tag mismatch: td and font
+</td>
+     ^
+./test/HTML/wired.html:414: HTML parser error : Opening and ending tag mismatch: td and font
 </td>
      ^
 ./test/HTML/wired.html:432: HTML parser error : htmlParseEntityRef: expecting ';'
diff --git a/result/HTML/wired.html.sax b/result/HTML/wired.html.sax
index d5b16297..bb787656 100644
--- a/result/HTML/wired.html.sax
+++ b/result/HTML/wired.html.sax
@@ -1962,7 +1962,6 @@ SAX.endElement(a)
 SAX.endElement(i)
 SAX.error: End tag : expected '>'
 SAX.endElement(font)
-SAX.endElement(font)
 SAX.startElement(br)
 SAX.endElement(br)
 SAX.startElement(br)
@@ -2023,6 +2022,8 @@ SAX.error: Opening and ending tag mismatch: td and font
 SAX.endElement(font)
 SAX.error: Opening and ending tag mismatch: td and font
 SAX.endElement(font)
+SAX.error: Opening and ending tag mismatch: td and font
+SAX.endElement(font)
 SAX.endElement(td)
 SAX.characters(
 , 1)
diff --git a/result/XInclude/fallback3.xml b/result/XInclude/fallback3.xml
new file mode 100644
index 00000000..b4235514
--- /dev/null
+++ b/result/XInclude/fallback3.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0"?>
+<a>
+    <doc xml:base="../ents/something.xml">
+<p>something</p>
+<p>really</p>
+<p>simple</p>
+</doc>
+</a>
diff --git a/result/XInclude/fallback3.xml.err b/result/XInclude/fallback3.xml.err
new file mode 100644
index 00000000..e69de29b
diff --git a/result/XInclude/fallback3.xml.rdr b/result/XInclude/fallback3.xml.rdr
new file mode 100644
index 00000000..aa2f1374
--- /dev/null
+++ b/result/XInclude/fallback3.xml.rdr
@@ -0,0 +1,25 @@
+0 1 a 0 0
+1 14 #text 0 1 
+    
+1 1 doc 0 0
+2 14 #text 0 1 
+
+2 1 p 0 0
+3 3 #text 0 1 something
+2 15 p 0 0
+2 14 #text 0 1 
+
+2 1 p 0 0
+3 3 #text 0 1 really
+2 15 p 0 0
+2 14 #text 0 1 
+
+2 1 p 0 0
+3 3 #text 0 1 simple
+2 15 p 0 0
+2 14 #text 0 1 
+
+1 15 doc 0 0
+1 14 #text 0 1 
+
+0 15 a 0 0
diff --git a/result/XInclude/fallback4.xml b/result/XInclude/fallback4.xml
new file mode 100644
index 00000000..9883fd54
--- /dev/null
+++ b/result/XInclude/fallback4.xml
@@ -0,0 +1,10 @@
+<?xml version="1.0"?>
+<a>
+    
+            <doc xml:base="../ents/something.xml">
+<p>something</p>
+<p>really</p>
+<p>simple</p>
+</doc>
+        
+</a>
diff --git a/result/XInclude/fallback4.xml.err b/result/XInclude/fallback4.xml.err
new file mode 100644
index 00000000..e69de29b
diff --git a/result/XInclude/fallback4.xml.rdr b/result/XInclude/fallback4.xml.rdr
new file mode 100644
index 00000000..628b9513
--- /dev/null
+++ b/result/XInclude/fallback4.xml.rdr
@@ -0,0 +1,29 @@
+0 1 a 0 0
+1 14 #text 0 1 
+    
+1 14 #text 0 1 
+            
+1 1 doc 0 0
+2 14 #text 0 1 
+
+2 1 p 0 0
+3 3 #text 0 1 something
+2 15 p 0 0
+2 14 #text 0 1 
+
+2 1 p 0 0
+3 3 #text 0 1 really
+2 15 p 0 0
+2 14 #text 0 1 
+
+2 1 p 0 0
+3 3 #text 0 1 simple
+2 15 p 0 0
+2 14 #text 0 1 
+
+1 15 doc 0 0
+1 14 #text 0 1 
+        
+1 14 #text 0 1 
+
+0 15 a 0 0
diff --git a/result/XInclude/fallback5.xml b/result/XInclude/fallback5.xml
new file mode 100644
index 00000000..0ba503d9
--- /dev/null
+++ b/result/XInclude/fallback5.xml
@@ -0,0 +1,51 @@
+<?xml version="1.0"?>
+<a>
+ 
+   <elem/>
+   
+     <elem/>
+     
+       <elem/>
+       
+         <elem/>
+         
+           <elem/>
+           
+             <elem/>
+             
+               <elem/>
+               
+                 <elem/>
+                 
+                   <elem/>
+                   
+                     <elem/>
+                     
+                       <elem/>
+                       
+                         <elem/>
+                         
+                           <elem/>
+                           
+                             <elem/>
+                             
+                               <elem/>
+                               
+                                 <elem/>
+                                
+                              
+                            
+                          
+                        
+                      
+                    
+                  
+                
+              
+            
+          
+        
+      
+    
+  
+</a>
diff --git a/result/XInclude/fallback5.xml.rdr b/result/XInclude/fallback5.xml.rdr
new file mode 100644
index 00000000..0e1dab71
--- /dev/null
+++ b/result/XInclude/fallback5.xml.rdr
@@ -0,0 +1,116 @@
+0 1 a 0 0
+1 14 #text 0 1 
+ 
+1 14 #text 0 1 
+   
+1 1 elem 1 0
+1 14 #text 0 1 
+   
+1 14 #text 0 1 
+     
+1 1 elem 1 0
+1 14 #text 0 1 
+     
+1 14 #text 0 1 
+       
+1 1 elem 1 0
+1 14 #text 0 1 
+       
+1 14 #text 0 1 
+         
+1 1 elem 1 0
+1 14 #text 0 1 
+         
+1 14 #text 0 1 
+           
+1 1 elem 1 0
+1 14 #text 0 1 
+           
+1 14 #text 0 1 
+             
+1 1 elem 1 0
+1 14 #text 0 1 
+             
+1 14 #text 0 1 
+               
+1 1 elem 1 0
+1 14 #text 0 1 
+               
+1 14 #text 0 1 
+                 
+1 1 elem 1 0
+1 14 #text 0 1 
+                 
+1 14 #text 0 1 
+                   
+1 1 elem 1 0
+1 14 #text 0 1 
+                   
+1 14 #text 0 1 
+                     
+1 1 elem 1 0
+1 14 #text 0 1 
+                     
+1 14 #text 0 1 
+                       
+1 1 elem 1 0
+1 14 #text 0 1 
+                       
+1 14 #text 0 1 
+                         
+1 1 elem 1 0
+1 14 #text 0 1 
+                         
+1 14 #text 0 1 
+                           
+1 1 elem 1 0
+1 14 #text 0 1 
+                           
+1 14 #text 0 1 
+                             
+1 1 elem 1 0
+1 14 #text 0 1 
+                             
+1 14 #text 0 1 
+                               
+1 1 elem 1 0
+1 14 #text 0 1 
+                               
+1 14 #text 0 1 
+                                 
+1 1 elem 1 0
+1 14 #text 0 1 
+                                
+1 14 #text 0 1 
+                              
+1 14 #text 0 1 
+                            
+1 14 #text 0 1 
+                          
+1 14 #text 0 1 
+                        
+1 14 #text 0 1 
+                      
+1 14 #text 0 1 
+                    
+1 14 #text 0 1 
+                  
+1 14 #text 0 1 
+                
+1 14 #text 0 1 
+              
+1 14 #text 0 1 
+            
+1 14 #text 0 1 
+          
+1 14 #text 0 1 
+        
+1 14 #text 0 1 
+      
+1 14 #text 0 1 
+    
+1 14 #text 0 1 
+  
+1 14 #text 0 1 
+
+0 15 a 0 0
diff --git a/result/XInclude/fallback6.xml b/result/XInclude/fallback6.xml
new file mode 100644
index 00000000..2b5d4116
--- /dev/null
+++ b/result/XInclude/fallback6.xml
@@ -0,0 +1 @@
+<?xml version="1.0"?>
diff --git a/result/XInclude/fallback6.xml.rdr b/result/XInclude/fallback6.xml.rdr
new file mode 100644
index 00000000..e69de29b
diff --git a/result/XInclude/ns1.xml b/result/XInclude/ns1.xml
new file mode 100644
index 00000000..ab41fb7a
--- /dev/null
+++ b/result/XInclude/ns1.xml
@@ -0,0 +1,10 @@
+<?xml version="1.0"?>
+<doc xmlns:xi="http://www.w3.org/2001/XInclude">
+    <ns:elem xmlns:ns="urn:foo" xml:id="a"/>
+    <elem xmlns:ns="urn:foo">
+        <ns:elem xml:id="a"/>
+    </elem>
+    
+            <ns:elem xmlns:ns="urn:bar"/>
+        
+</doc>
diff --git a/result/XInclude/ns1.xml.rdr b/result/XInclude/ns1.xml.rdr
new file mode 100644
index 00000000..f23702f5
--- /dev/null
+++ b/result/XInclude/ns1.xml.rdr
@@ -0,0 +1,23 @@
+0 1 doc 0 0
+1 14 #text 0 1 
+    
+1 1 ns:elem 1 0
+1 14 #text 0 1 
+    
+1 1 elem 0 0
+2 14 #text 0 1 
+        
+2 1 ns:elem 1 0
+2 14 #text 0 1 
+    
+1 15 elem 0 0
+1 14 #text 0 1 
+    
+1 14 #text 0 1 
+            
+1 1 ns:elem 1 0
+1 14 #text 0 1 
+        
+1 14 #text 0 1 
+
+0 15 doc 0 0
diff --git a/result/att7.rde b/result/att7.rde
index afcef5fe..60796379 100644
--- a/result/att7.rde
+++ b/result/att7.rde
@@ -5,8 +5,7 @@
 1 1 test 1 0
 1 14 #text 0 1 
     
-1 1 test 0 0
-1 15 test 0 0
+1 1 test 1 0
 1 14 #text 0 1 
 
 0 15 x 0 0
diff --git a/result/ent9.rde b/result/ent9.rde
index 38b9f431..22061467 100644
--- a/result/ent9.rde
+++ b/result/ent9.rde
@@ -12,8 +12,7 @@
 2 1 c 0 0
 2 15 c 0 0
 2 3 #text 0 1 ,
-2 1 d 0 0
-2 15 d 0 0
+2 1 d 1 0
 1 15 ent 0 0
 1 14 #text 0 1 
    
@@ -292,8 +291,7 @@
 2 1 c 0 0
 2 15 c 0 0
 2 3 #text 0 1 ,
-2 1 d 0 0
-2 15 d 0 0
+2 1 d 1 0
 1 15 ent 0 0
 1 14 #text 0 1 
 
diff --git a/result/errors/754946.xml.ent b/result/errors/754946.xml.ent
new file mode 100644
index 00000000..be777817
--- /dev/null
+++ b/result/errors/754946.xml.ent
@@ -0,0 +1,20 @@
+./test/errors/754946.xml:3: parser error : internal error: xmlParseInternalSubset: error detected in Markup declaration
+
+  %SYSTEM;
+          ^
+Entity: line 1: 
+A<lbbbbbbbbbbbbbbbbbbb_
+^
+./test/errors/754946.xml:4: parser error : internal error: xmlParseInternalSubset: error detected in Markup declaration
+
+  <![
+  ^
+./test/errors/754946.xml:4: parser error : DOCTYPE improperly terminated
+  <![
+  ^
+./test/errors/754946.xml:4: parser error : StartTag: invalid element name
+  <![
+   ^
+./test/errors/754946.xml:4: parser error : Extra content at the end of the document
+  <![
+   ^
diff --git a/result/errors/754947.xml.ent b/result/errors/754947.xml.ent
new file mode 100644
index 00000000..51e9b4ed
--- /dev/null
+++ b/result/errors/754947.xml.ent
@@ -0,0 +1,7 @@
+./test/errors/754947.xml:1: parser error : Input is not proper UTF-8, indicate encoding !
+Bytes: 0xEE 0x5D 0x5D 0x3E
+<d><![CDATA[0000000000000Ó]]>
+                         ^
+./test/errors/754947.xml:1: parser error : EndTag: '</' not found
+<d><![CDATA[0000000000000Ó]]>
+                             ^
diff --git a/result/errors/758588.xml.ent b/result/errors/758588.xml.ent
new file mode 100644
index 00000000..dfa59bcf
--- /dev/null
+++ b/result/errors/758588.xml.ent
@@ -0,0 +1,9 @@
+./test/errors/758588.xml:1: namespace error : Namespace prefix a-340282366920938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867261d on a is not defined
+63472597946867209384634725979468672093846347259794686720938463472597946867261d:a
+                                                                               ^
+./test/errors/758588.xml:1: parser error : expected '>'
+2597946867209384634725979468672093846347259794686720938463472597946867261d:a></a
+                                                                               ^
+./test/errors/758588.xml:1: parser error : Opening and ending tag mismatch: a line 1 and a
+2597946867209384634725979468672093846347259794686720938463472597946867261d:a></a
+                                                                               ^
diff --git a/result/errors/759020.xml.ent b/result/errors/759020.xml.ent
new file mode 100644
index 00000000..a0d30517
--- /dev/null
+++ b/result/errors/759020.xml.ent
@@ -0,0 +1,6 @@
+./test/errors/759020.xml:3: namespace warning : xmlns: URI 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 is not absolute
+0000000000000000000000000000000000000000000000000000000000000000000000000000000'
+                                                                               ^
+./test/errors/759020.xml:46: parser error : Couldn't find end of Start Tag s00 line 2
+                                                                   
+                                                                   ^
diff --git a/result/errors/759398.xml.ent b/result/errors/759398.xml.ent
new file mode 100644
index 00000000..bc9e5e03
--- /dev/null
+++ b/result/errors/759398.xml.ent
@@ -0,0 +1,12 @@
+./test/errors/759398.xml:210: parser error : StartTag: invalid element name
+need to worry about parsers whi<! don't expand PErefs finding
+                                ^
+./test/errors/759398.xml:309: parser error : Opening and ending tag mismatch: ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññ‚Ññm line 205 and termdef
+and provide access to their content and structure.</termdef> <termdef
+                                                            ^
+./test/errors/759398.xml:314: parser error : Opening and ending tag mismatch: spec line 205 and p
+data and the information it must provide to the application.</p>
+                                                                ^
+./test/errors/759398.xml:316: parser error : Extra content at the end of the document
+<div2 id='sec-origin-goals'>
+^
diff --git a/result/errors/759573-2.xml.ent b/result/errors/759573-2.xml.ent
new file mode 100644
index 00000000..4c454758
--- /dev/null
+++ b/result/errors/759573-2.xml.ent
@@ -0,0 +1,35 @@
+Entity: line 1: parser error : Space required after '<!ENTITY'
+%zz;
+    ^
+Entity: line 1: 
+<!ENTITY<?xDOCTYPEm~?>
+        ^
+Entity: line 1: parser error : xmlParseEntityDecl: no name
+%zz;
+    ^
+Entity: line 1: 
+<!ENTITY<?xDOCTYPEm~?>
+        ^
+Entity: line 1: parser error : ParsePI: PI xDOCTYPEm space expected
+%zz;
+    ^
+Entity: line 1: 
+<!ENTITY<?xDOCTYPEm~?>
+                   ^
+./test/errors/759573-2.xml:6: parser error : internal error: xmlParseInternalSubset: error detected in Markup declaration
+
+%xx;ˇggKENSMYNT&#35;MENTD&#372zz;'>
+    ^
+Entity: line 2: 
+<![INCLUDE[
+^
+./test/errors/759573-2.xml:6: parser error : internal error: xmlParseInternalSubset: error detected in Markup declaration
+
+%xx;ˇggKENSMYNT&#35;MENTD&#372zz;'>
+    ^
+./test/errors/759573-2.xml:6: parser error : DOCTYPE improperly terminated
+%xx;ˇggKENSMYNT&#35;MENTD&#372zz;'>
+    ^
+./test/errors/759573-2.xml:6: parser error : Start tag expected, '<' not found
+%xx;ˇggKENSMYNT&#35;MENTD&#372zz;'>
+    ^
diff --git a/result/errors/759573.xml.ent b/result/errors/759573.xml.ent
new file mode 100644
index 00000000..55247503
--- /dev/null
+++ b/result/errors/759573.xml.ent
@@ -0,0 +1,32 @@
+./test/errors/759573.xml:1: parser error : Space required after '<!ENTITY'
+ELEMENT t (A)><!ENTITY % xx '&#37;<![INCLUDE[000&#37;&#3000;000&#37;z;'><!ENTITY
+                                                                               ^
+./test/errors/759573.xml:1: parser error : Space required after the entity name
+LEMENT t (A)><!ENTITY % xx '&#37;<![INCLUDE[000&#37;&#3000;000&#37;z;'><!ENTITYz
+                                                                               ^
+./test/errors/759573.xml:1: parser error : Entity value required
+LEMENT t (A)><!ENTITY % xx '&#37;<![INCLUDE[000&#37;&#3000;000&#37;z;'><!ENTITYz
+                                                                               ^
+./test/errors/759573.xml:1: parser error : PEReference: no name
+T t (A)><!ENTITY % xx '&#37;<![INCLUDE[000&#37;&#3000;000&#37;z;'><!ENTITYz>%xx;
+                                                                               ^
+Entity: line 1: 
+%<![INCLUDE[000%‡Æ∏000%z;
+ ^
+./test/errors/759573.xml:1: parser error : internal error: xmlParseInternalSubset: error detected in Markup declaration
+
+T t (A)><!ENTITY % xx '&#37;<![INCLUDE[000&#37;&#3000;000&#37;z;'><!ENTITYz>%xx;
+                                                                               ^
+Entity: line 1: 
+%<![INCLUDE[000%‡Æ∏000%z;
+ ^
+./test/errors/759573.xml:1: parser error : internal error: xmlParseInternalSubset: error detected in Markup declaration
+
+T t (A)><!ENTITY % xx '&#37;<![INCLUDE[000&#37;&#3000;000&#37;z;'><!ENTITYz>%xx;
+                                                                               ^
+./test/errors/759573.xml:1: parser error : DOCTYPE improperly terminated
+T t (A)><!ENTITY % xx '&#37;<![INCLUDE[000&#37;&#3000;000&#37;z;'><!ENTITYz>%xx;
+                                                                               ^
+./test/errors/759573.xml:1: parser error : Start tag expected, '<' not found
+T t (A)><!ENTITY % xx '&#37;<![INCLUDE[000&#37;&#3000;000&#37;z;'><!ENTITYz>%xx;
+                                                                               ^
diff --git a/result/errors/759579.xml.ent b/result/errors/759579.xml.ent
new file mode 100644
index 00000000..288026e6
--- /dev/null
+++ b/result/errors/759579.xml.ent
@@ -0,0 +1,6 @@
+Entity: line 2: parser error : Detected an entity reference loop
+        %z; %z; %z; %z; %z;
+           ^
+Entity: line 2: 
+        %z; %z; %z; %z; %z;
+           ^
diff --git a/result/errors/attr1.xml.ent b/result/errors/attr1.xml.ent
new file mode 100644
index 00000000..c4c4fc84
--- /dev/null
+++ b/result/errors/attr1.xml.ent
@@ -0,0 +1,9 @@
+./test/errors/attr1.xml:2: parser error : AttValue: ' expected
+
+^
+./test/errors/attr1.xml:2: parser error : attributes construct error
+
+^
+./test/errors/attr1.xml:2: parser error : Couldn't find end of Start Tag foo line 1
+
+^
diff --git a/result/errors/attr2.xml.ent b/result/errors/attr2.xml.ent
new file mode 100644
index 00000000..77e342e3
--- /dev/null
+++ b/result/errors/attr2.xml.ent
@@ -0,0 +1,9 @@
+./test/errors/attr2.xml:2: parser error : AttValue: ' expected
+
+^
+./test/errors/attr2.xml:2: parser error : attributes construct error
+
+^
+./test/errors/attr2.xml:2: parser error : Couldn't find end of Start Tag foo line 1
+
+^
diff --git a/result/errors/attr3.xml.ent b/result/errors/attr3.xml.ent
new file mode 100644
index 00000000..a628ca79
--- /dev/null
+++ b/result/errors/attr3.xml.ent
@@ -0,0 +1,3 @@
+./test/errors/attr3.xml:4: validity warning : Attribute a1 of element doc: already defined
+<!ATTLIST doc a1 CDATA "z1">
+                           ^
diff --git a/result/errors/attr4.xml.ent b/result/errors/attr4.xml.ent
new file mode 100644
index 00000000..a9966d85
--- /dev/null
+++ b/result/errors/attr4.xml.ent
@@ -0,0 +1,12 @@
+./test/errors/attr4.xml:1: parser error : invalid character in attribute value
+<ROOT attr="XY"/>
+              ^
+./test/errors/attr4.xml:1: parser error : attributes construct error
+<ROOT attr="XY"/>
+              ^
+./test/errors/attr4.xml:1: parser error : Couldn't find end of Start Tag ROOT line 1
+<ROOT attr="XY"/>
+              ^
+./test/errors/attr4.xml:1: parser error : Extra content at the end of the document
+<ROOT attr="XY"/>
+              ^
diff --git a/result/errors/cdata.xml.ent b/result/errors/cdata.xml.ent
new file mode 100644
index 00000000..f757963f
--- /dev/null
+++ b/result/errors/cdata.xml.ent
@@ -0,0 +1,4 @@
+./test/errors/cdata.xml:2: parser error : Input is not proper UTF-8, indicate encoding !
+Bytes: 0xE1 0x72 0x5D 0x5D
+<A><![CDATA[C·r]]></A>
+             ^
diff --git a/result/errors/charref1.xml.ent b/result/errors/charref1.xml.ent
new file mode 100644
index 00000000..dbf30054
--- /dev/null
+++ b/result/errors/charref1.xml.ent
@@ -0,0 +1,3 @@
+./test/errors/charref1.xml:1: parser error : xmlParseCharRef: character reference out of bounds
+<bla>&#010100000000000000000000000000000000000000000000000060;</bla>
+                                                              ^
diff --git a/result/errors/comment1.xml.ent b/result/errors/comment1.xml.ent
new file mode 100644
index 00000000..5a732dd7
--- /dev/null
+++ b/result/errors/comment1.xml.ent
@@ -0,0 +1,6 @@
+./test/errors/comment1.xml:5: parser error : xmlParseComment: invalid xmlChar value 14
+ in p02:  -->
+         ^
+./test/errors/comment1.xml:5: parser error : Start tag expected, '<' not found
+ in p02:  -->
+         ^
diff --git a/result/errors/content1.xml.ent b/result/errors/content1.xml.ent
new file mode 100644
index 00000000..9fcd6033
--- /dev/null
+++ b/result/errors/content1.xml.ent
@@ -0,0 +1,16 @@
+./test/errors/content1.xml:7: parser error : ContentDecl : ',' '|' or ')' expected
+<!ELEMENT aElement (a |b * >
+                         ^
+./test/errors/content1.xml:7: parser error : expected '>'
+<!ELEMENT aElement (a |b * >
+                         ^
+./test/errors/content1.xml:7: parser error : internal error: xmlParseInternalSubset: error detected in Markup declaration
+
+<!ELEMENT aElement (a |b * >
+                         ^
+./test/errors/content1.xml:7: parser error : DOCTYPE improperly terminated
+<!ELEMENT aElement (a |b * >
+                         ^
+./test/errors/content1.xml:7: parser error : Start tag expected, '<' not found
+<!ELEMENT aElement (a |b * >
+                         ^
diff --git a/result/errors/extparsedent.xml.ent b/result/errors/extparsedent.xml.ent
new file mode 100644
index 00000000..2cce1761
--- /dev/null
+++ b/result/errors/extparsedent.xml.ent
@@ -0,0 +1 @@
+I/O warning : failed to load external entity "/etc/doesnotexist"
diff --git a/result/errors/name.xml.ent b/result/errors/name.xml.ent
new file mode 100644
index 00000000..4dbfc52f
--- /dev/null
+++ b/result/errors/name.xml.ent
@@ -0,0 +1,3 @@
+./test/errors/name.xml:2: parser error : Couldn't find end of Start Tag foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo line 1
+
+^
diff --git a/result/errors/name2.xml.ent b/result/errors/name2.xml.ent
new file mode 100644
index 00000000..8acef792
--- /dev/null
+++ b/result/errors/name2.xml.ent
@@ -0,0 +1,9 @@
+./test/errors/name2.xml:2: parser error : Specification mandates value for attribute foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
+
+^
+./test/errors/name2.xml:2: parser error : attributes construct error
+
+^
+./test/errors/name2.xml:2: parser error : Couldn't find end of Start Tag foo line 1
+
+^
diff --git a/result/errors/rec_ext_ent.xml b/result/errors/rec_ext_ent.xml
new file mode 100644
index 00000000..6a196cb5
--- /dev/null
+++ b/result/errors/rec_ext_ent.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0"?>
+<!DOCTYPE doc [
+<!ENTITY e SYSTEM "rec_ext.ent">
+]>
+<doc>&e; &e; &e; &e;</doc>
diff --git a/result/errors/rec_ext_ent.xml.ent b/result/errors/rec_ext_ent.xml.ent
new file mode 100644
index 00000000..30dd2854
--- /dev/null
+++ b/result/errors/rec_ext_ent.xml.ent
@@ -0,0 +1,243 @@
+test/errors/rec_ext.ent:1: parser error : Detected an entity reference loop
+<ent>&e; &e; &e; &e;</ent>
+        ^
+test/errors/rec_ext.ent:2: parser error : chunk is not well balanced
+
+^
+test/errors/rec_ext.ent:1: parser error : Entity 'e' failed to parse
+<ent>&e; &e; &e; &e;</ent>
+        ^
+test/errors/rec_ext.ent:2: parser error : chunk is not well balanced
+
+^
+test/errors/rec_ext.ent:1: parser error : Entity 'e' failed to parse
+<ent>&e; &e; &e; &e;</ent>
+        ^
+test/errors/rec_ext.ent:2: parser error : chunk is not well balanced
+
+^
+test/errors/rec_ext.ent:1: parser error : Entity 'e' failed to parse
+<ent>&e; &e; &e; &e;</ent>
+        ^
+test/errors/rec_ext.ent:2: parser error : chunk is not well balanced
+
+^
+test/errors/rec_ext.ent:1: parser error : Entity 'e' failed to parse
+<ent>&e; &e; &e; &e;</ent>
+        ^
+test/errors/rec_ext.ent:2: parser error : chunk is not well balanced
+
+^
+test/errors/rec_ext.ent:1: parser error : Entity 'e' failed to parse
+<ent>&e; &e; &e; &e;</ent>
+        ^
+test/errors/rec_ext.ent:2: parser error : chunk is not well balanced
+
+^
+test/errors/rec_ext.ent:1: parser error : Entity 'e' failed to parse
+<ent>&e; &e; &e; &e;</ent>
+        ^
+test/errors/rec_ext.ent:2: parser error : chunk is not well balanced
+
+^
+test/errors/rec_ext.ent:1: parser error : Entity 'e' failed to parse
+<ent>&e; &e; &e; &e;</ent>
+        ^
+test/errors/rec_ext.ent:2: parser error : chunk is not well balanced
+
+^
+test/errors/rec_ext.ent:1: parser error : Entity 'e' failed to parse
+<ent>&e; &e; &e; &e;</ent>
+        ^
+test/errors/rec_ext.ent:2: parser error : chunk is not well balanced
+
+^
+test/errors/rec_ext.ent:1: parser error : Entity 'e' failed to parse
+<ent>&e; &e; &e; &e;</ent>
+        ^
+test/errors/rec_ext.ent:2: parser error : chunk is not well balanced
+
+^
+test/errors/rec_ext.ent:1: parser error : Entity 'e' failed to parse
+<ent>&e; &e; &e; &e;</ent>
+        ^
+test/errors/rec_ext.ent:2: parser error : chunk is not well balanced
+
+^
+test/errors/rec_ext.ent:1: parser error : Entity 'e' failed to parse
+<ent>&e; &e; &e; &e;</ent>
+        ^
+test/errors/rec_ext.ent:2: parser error : chunk is not well balanced
+
+^
+test/errors/rec_ext.ent:1: parser error : Entity 'e' failed to parse
+<ent>&e; &e; &e; &e;</ent>
+        ^
+test/errors/rec_ext.ent:2: parser error : chunk is not well balanced
+
+^
+test/errors/rec_ext.ent:1: parser error : Entity 'e' failed to parse
+<ent>&e; &e; &e; &e;</ent>
+        ^
+test/errors/rec_ext.ent:2: parser error : chunk is not well balanced
+
+^
+test/errors/rec_ext.ent:1: parser error : Entity 'e' failed to parse
+<ent>&e; &e; &e; &e;</ent>
+        ^
+test/errors/rec_ext.ent:2: parser error : chunk is not well balanced
+
+^
+test/errors/rec_ext.ent:1: parser error : Entity 'e' failed to parse
+<ent>&e; &e; &e; &e;</ent>
+        ^
+test/errors/rec_ext.ent:2: parser error : chunk is not well balanced
+
+^
+test/errors/rec_ext.ent:1: parser error : Entity 'e' failed to parse
+<ent>&e; &e; &e; &e;</ent>
+        ^
+test/errors/rec_ext.ent:2: parser error : chunk is not well balanced
+
+^
+test/errors/rec_ext.ent:1: parser error : Entity 'e' failed to parse
+<ent>&e; &e; &e; &e;</ent>
+        ^
+test/errors/rec_ext.ent:2: parser error : chunk is not well balanced
+
+^
+test/errors/rec_ext.ent:1: parser error : Entity 'e' failed to parse
+<ent>&e; &e; &e; &e;</ent>
+        ^
+test/errors/rec_ext.ent:2: parser error : chunk is not well balanced
+
+^
+test/errors/rec_ext.ent:1: parser error : Entity 'e' failed to parse
+<ent>&e; &e; &e; &e;</ent>
+        ^
+test/errors/rec_ext.ent:2: parser error : chunk is not well balanced
+
+^
+test/errors/rec_ext.ent:1: parser error : Entity 'e' failed to parse
+<ent>&e; &e; &e; &e;</ent>
+        ^
+test/errors/rec_ext.ent:2: parser error : chunk is not well balanced
+
+^
+test/errors/rec_ext.ent:1: parser error : Entity 'e' failed to parse
+<ent>&e; &e; &e; &e;</ent>
+        ^
+test/errors/rec_ext.ent:2: parser error : chunk is not well balanced
+
+^
+test/errors/rec_ext.ent:1: parser error : Entity 'e' failed to parse
+<ent>&e; &e; &e; &e;</ent>
+        ^
+test/errors/rec_ext.ent:2: parser error : chunk is not well balanced
+
+^
+test/errors/rec_ext.ent:1: parser error : Entity 'e' failed to parse
+<ent>&e; &e; &e; &e;</ent>
+        ^
+test/errors/rec_ext.ent:2: parser error : chunk is not well balanced
+
+^
+test/errors/rec_ext.ent:1: parser error : Entity 'e' failed to parse
+<ent>&e; &e; &e; &e;</ent>
+        ^
+test/errors/rec_ext.ent:2: parser error : chunk is not well balanced
+
+^
+test/errors/rec_ext.ent:1: parser error : Entity 'e' failed to parse
+<ent>&e; &e; &e; &e;</ent>
+        ^
+test/errors/rec_ext.ent:2: parser error : chunk is not well balanced
+
+^
+test/errors/rec_ext.ent:1: parser error : Entity 'e' failed to parse
+<ent>&e; &e; &e; &e;</ent>
+        ^
+test/errors/rec_ext.ent:2: parser error : chunk is not well balanced
+
+^
+test/errors/rec_ext.ent:1: parser error : Entity 'e' failed to parse
+<ent>&e; &e; &e; &e;</ent>
+        ^
+test/errors/rec_ext.ent:2: parser error : chunk is not well balanced
+
+^
+test/errors/rec_ext.ent:1: parser error : Entity 'e' failed to parse
+<ent>&e; &e; &e; &e;</ent>
+        ^
+test/errors/rec_ext.ent:2: parser error : chunk is not well balanced
+
+^
+test/errors/rec_ext.ent:1: parser error : Detected an entity reference loop
+<ent>&e; &e; &e; &e;</ent>
+        ^
+test/errors/rec_ext.ent:2: parser error : chunk is not well balanced
+
+^
+test/errors/rec_ext.ent:1: parser error : Detected an entity reference loop
+<ent>&e; &e; &e; &e;</ent>
+        ^
+test/errors/rec_ext.ent:2: parser error : chunk is not well balanced
+
+^
+test/errors/rec_ext.ent:1: parser error : Detected an entity reference loop
+<ent>&e; &e; &e; &e;</ent>
+        ^
+test/errors/rec_ext.ent:2: parser error : chunk is not well balanced
+
+^
+test/errors/rec_ext.ent:1: parser error : Detected an entity reference loop
+<ent>&e; &e; &e; &e;</ent>
+        ^
+test/errors/rec_ext.ent:2: parser error : chunk is not well balanced
+
+^
+test/errors/rec_ext.ent:1: parser error : Detected an entity reference loop
+<ent>&e; &e; &e; &e;</ent>
+        ^
+test/errors/rec_ext.ent:2: parser error : chunk is not well balanced
+
+^
+test/errors/rec_ext.ent:1: parser error : Detected an entity reference loop
+<ent>&e; &e; &e; &e;</ent>
+        ^
+test/errors/rec_ext.ent:2: parser error : chunk is not well balanced
+
+^
+test/errors/rec_ext.ent:1: parser error : Detected an entity reference loop
+<ent>&e; &e; &e; &e;</ent>
+        ^
+test/errors/rec_ext.ent:2: parser error : chunk is not well balanced
+
+^
+test/errors/rec_ext.ent:1: parser error : Detected an entity reference loop
+<ent>&e; &e; &e; &e;</ent>
+        ^
+test/errors/rec_ext.ent:2: parser error : chunk is not well balanced
+
+^
+test/errors/rec_ext.ent:1: parser error : Detected an entity reference loop
+<ent>&e; &e; &e; &e;</ent>
+        ^
+test/errors/rec_ext.ent:2: parser error : chunk is not well balanced
+
+^
+test/errors/rec_ext.ent:1: parser error : Detected an entity reference loop
+<ent>&e; &e; &e; &e;</ent>
+        ^
+test/errors/rec_ext.ent:2: parser error : chunk is not well balanced
+
+^
+test/errors/rec_ext.ent:1: parser error : Detected an entity reference loop
+<ent>&e; &e; &e; &e;</ent>
+        ^
+test/errors/rec_ext.ent:2: parser error : chunk is not well balanced
+
+^
+./test/errors/rec_ext_ent.xml:4: parser error : Entity 'e' failed to parse
+<doc>&e; &e; &e; &e;</doc>
+        ^
diff --git a/result/errors/rec_ext_ent.xml.err b/result/errors/rec_ext_ent.xml.err
new file mode 100644
index 00000000..e69de29b
diff --git a/result/errors/rec_ext_ent.xml.str b/result/errors/rec_ext_ent.xml.str
new file mode 100644
index 00000000..e69de29b
diff --git a/result/noent/ent2.sax2 b/result/noent/ent2.sax2
index 88c6aa6b..d17f2ffe 100644
--- a/result/noent/ent2.sax2
+++ b/result/noent/ent2.sax2
@@ -17,13 +17,6 @@ SAX.characters(my title, 8)
 SAX.endElementNs(title, NULL, NULL)
 SAX.characters(
 , 1)
-SAX.ignorableWhitespace(
-, 1)
-SAX.startElementNs(title, NULL, NULL, 0, 0, 0)
-SAX.characters(my title, 8)
-SAX.endElementNs(title, NULL, NULL)
-SAX.characters(
-, 1)
 SAX.characters(
   This text is about XML, the, 31)
 SAX.getEntity(xml)
diff --git a/result/regexp/bug757711 b/result/regexp/bug757711
new file mode 100644
index 00000000..0991e4e2
--- /dev/null
+++ b/result/regexp/bug757711
@@ -0,0 +1,2 @@
+Regexp: [;^((-
+   failed to compile
diff --git a/result/regexp/bug757711.err b/result/regexp/bug757711.err
new file mode 100644
index 00000000..f1cae806
--- /dev/null
+++ b/result/regexp/bug757711.err
@@ -0,0 +1,2 @@
+regexp error : failed to compile: Expecting the end of a char range
+regexp error : failed to compile: xmlFAParseCharClass: ']' expected
diff --git a/result/regexp/bug783015 b/result/regexp/bug783015
new file mode 100644
index 00000000..653f6f09
--- /dev/null
+++ b/result/regexp/bug783015
@@ -0,0 +1,4 @@
+Regexp: .{2147483647}
+input: Fail
+Regexp: .{2147483648}
+   failed to compile
diff --git a/result/regexp/bug783015.err b/result/regexp/bug783015.err
new file mode 100644
index 00000000..a00edc98
--- /dev/null
+++ b/result/regexp/bug783015.err
@@ -0,0 +1 @@
+regexp error : failed to compile: Improper quantifier
diff --git a/runtest.c b/runtest.c
index ffa98d04..0f178cb0 100644
--- a/runtest.c
+++ b/runtest.c
@@ -105,6 +105,7 @@ struct testDesc {
 };
 
 static int update_results = 0;
+static char* temp_directory = NULL;
 static int checkTestFile(const char *filename);
 
 #if defined(_WIN32) && !defined(__CYGWIN__)
@@ -1699,7 +1700,7 @@ saxParseTest(const char *filename, const char *result,
     char *temp;
 
     nb_tests++;
-    temp = resultFilename(filename, "", ".res");
+    temp = resultFilename(filename, temp_directory, ".res");
     if (temp == NULL) {
         fprintf(stderr, "out of memory\n");
         fatalError();
@@ -1818,7 +1819,7 @@ oldParseTest(const char *filename, const char *result,
 #endif
     if (doc == NULL)
         return(1);
-    temp = resultFilename(filename, "", ".res");
+    temp = resultFilename(filename, temp_directory, ".res");
     if (temp == NULL) {
         fprintf(stderr, "out of memory\n");
         fatalError();
@@ -2030,7 +2031,7 @@ noentParseTest(const char *filename, const char *result,
     doc = xmlReadFile(filename, NULL, options);
     if (doc == NULL)
         return(1);
-    temp = resultFilename(filename, "", ".res");
+    temp = resultFilename(filename, temp_directory, ".res");
     if (temp == NULL) {
         fprintf(stderr, "Out of memory\n");
         fatalError();
@@ -2107,16 +2108,16 @@ errParseTest(const char *filename, const char *result, const char *err,
 	    xmlDocDumpMemory(doc, (xmlChar **) &base, &size);
 	}
 	res = compareFileMem(result, base, size);
-	if (res != 0) {
-	    fprintf(stderr, "Result for %s failed in %s\n", filename, result);
-	    return(-1);
-	}
     }
     if (doc != NULL) {
 	if (base != NULL)
 	    xmlFree((char *)base);
 	xmlFreeDoc(doc);
     }
+    if (res != 0) {
+        fprintf(stderr, "Result for %s failed in %s\n", filename, result);
+        return(-1);
+    }
     if (err != NULL) {
 	res = compareFileMem(err, testErrors, testErrorsSize);
 	if (res != 0) {
@@ -2177,7 +2178,7 @@ streamProcessTest(const char *filename, const char *result, const char *err,
 
     nb_tests++;
     if (result != NULL) {
-	temp = resultFilename(filename, "", ".res");
+	temp = resultFilename(filename, temp_directory, ".res");
 	if (temp == NULL) {
 	    fprintf(stderr, "Out of memory\n");
 	    fatalError();
@@ -2406,7 +2407,7 @@ xpathCommonTest(const char *filename, const char *result,
     int len, ret = 0;
     char *temp;
 
-    temp = resultFilename(filename, "", ".res");
+    temp = resultFilename(filename, temp_directory, ".res");
     if (temp == NULL) {
         fprintf(stderr, "Out of memory\n");
         fatalError();
@@ -2605,7 +2606,7 @@ xmlidDocTest(const char *filename,
 	return(-1);
     }
 
-    temp = resultFilename(filename, "", ".res");
+    temp = resultFilename(filename, temp_directory, ".res");
     if (temp == NULL) {
         fprintf(stderr, "Out of memory\n");
         fatalError();
@@ -2703,7 +2704,7 @@ uriCommonTest(const char *filename,
     char str[1024];
     int res = 0, i, ret;
 
-    temp = resultFilename(filename, "", ".res");
+    temp = resultFilename(filename, temp_directory, ".res");
     if (temp == NULL) {
         fprintf(stderr, "Out of memory\n");
         fatalError();
@@ -3007,7 +3008,7 @@ schemasOneTest(const char *sch,
 	return(-1);
     }
 
-    temp = resultFilename(result, "", ".res");
+    temp = resultFilename(result, temp_directory, ".res");
     if (temp == NULL) {
         fprintf(stderr, "Out of memory\n");
         fatalError();
@@ -3178,7 +3179,7 @@ rngOneTest(const char *sch,
 	return(-1);
     }
 
-    temp = resultFilename(result, "", ".res");
+    temp = resultFilename(result, temp_directory, ".res");
     if (temp == NULL) {
         fprintf(stderr, "Out of memory\n");
         fatalError();
@@ -3528,7 +3529,7 @@ patternTest(const char *filename,
         fprintf(stderr, "Failed to open %s\n", filename);
 	return(-1);
     }
-    temp = resultFilename(filename, "", ".res");
+    temp = resultFilename(filename, temp_directory, ".res");
     if (temp == NULL) {
         fprintf(stderr, "Out of memory\n");
         fatalError();
@@ -4248,6 +4249,9 @@ testDesc testDescriptions[] = {
     { "Error cases regression tests",
       errParseTest, "./test/errors/*.xml", "result/errors/", "", ".err",
       0 },
+    { "Error cases regression tests with entity substitution",
+      errParseTest, "./test/errors/*.xml", "result/errors/", NULL, ".ent",
+      XML_PARSE_NOENT },
     { "Error cases regression tests (old 1.0)",
       errParseTest, "./test/errors10/*.xml", "result/errors10/", "", ".err",
       XML_PARSE_OLD10 },
@@ -4562,6 +4566,8 @@ main(int argc ATTRIBUTE_UNUSED, char **argv ATTRIBUTE_UNUSED) {
 	    update_results = 1;
         else if (!strcmp(argv[a], "-quiet"))
 	    tests_quiet = 1;
+        else if (!strcmp(argv[a], "--out"))
+	    temp_directory = argv[++a];
 	else {
 	    for (i = 0; testDescriptions[i].func != NULL; i++) {
 	        if (strstr(testDescriptions[i].desc, argv[a])) {
diff --git a/runxmlconf.c b/runxmlconf.c
index 70f61017..8a37aa8f 100644
--- a/runxmlconf.c
+++ b/runxmlconf.c
@@ -507,7 +507,7 @@ xmlconfInfo(void) {
     fprintf(stderr, "  you need to fetch and extract the\n");
     fprintf(stderr, "  latest XML Conformance Test Suites\n");
     fprintf(stderr, "  http://www.w3.org/XML/Test/xmlts20080827.tar.gz\n");
-    fprintf(stderr, "  see http://www.w3.org/XML/Test/ for informations\n");
+    fprintf(stderr, "  see http://www.w3.org/XML/Test/ for information\n");
 }
 
 static int
diff --git a/schematron.c b/schematron.c
index 258ce409..ddbb069b 100644
--- a/schematron.c
+++ b/schematron.c
@@ -220,7 +220,7 @@ struct _xmlSchematronParserCtxt {
 /**
  * xmlSchematronPErrMemory:
  * @node: a context node
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle an out of memory condition
  */
@@ -268,7 +268,7 @@ xmlSchematronPErr(xmlSchematronParserCtxtPtr ctxt, xmlNodePtr node, int error,
 /**
  * xmlSchematronVTypeErrMemory:
  * @node: a context node
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle an out of memory condition
  */
diff --git a/test/HTML/chunked_attr.html b/test/HTML/chunked_attr.html
new file mode 100644
index 00000000..84d81796
--- /dev/null
+++ b/test/HTML/chunked_attr.html
@@ -0,0 +1,53 @@
+<html>
+<!--
+This tests internal state tracking of the push parser and assumes a chunk
+size of 4096 (or a divisor of 4096) and an initial chunk of size 4.
+Make sure that the first '<' in the attribute value ends up near
+offset 4100.
+-->
+<body>
+<p>
+Filler bytes follow:
+
+      100 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      200 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      300 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      400 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      500 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      600 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      700 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      800 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      900 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+     1000 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      100 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      200 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      300 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      400 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      500 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      600 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      700 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      800 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      900 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+     2000 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      100 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      200 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      300 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      400 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      500 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      600 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      700 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+      800 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
+xxx
+</p>
+<div
+  fill1="123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789"
+  onmouseover="x<b>text</b>x"
+  fill2="123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789"
+  fill3="123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789"
+  fill4="123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789"
+  fill5="123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789"
+  fill6="123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789"
+>
+</div>
+</body>
+</html>
diff --git a/test/XInclude/docs/fallback3.xml b/test/XInclude/docs/fallback3.xml
new file mode 100644
index 00000000..0c8b6c9e
--- /dev/null
+++ b/test/XInclude/docs/fallback3.xml
@@ -0,0 +1,9 @@
+<a>
+    <xi:include href="../ents/something.xml" xmlns:xi="http://www.w3.org/2001/XInclude">
+        <xi:fallback>
+            <xi:include href="c.xml">
+                <xi:fallback>There is no c.xml ... </xi:fallback>
+            </xi:include>
+        </xi:fallback>
+    </xi:include>
+</a>
diff --git a/test/XInclude/docs/fallback4.xml b/test/XInclude/docs/fallback4.xml
new file mode 100644
index 00000000..b500a635
--- /dev/null
+++ b/test/XInclude/docs/fallback4.xml
@@ -0,0 +1,7 @@
+<a>
+    <xi:include href="c.xml" xmlns:xi="http://www.w3.org/2001/XInclude">
+        <xi:fallback>
+            <xi:include href="../ents/something.xml"/>
+        </xi:fallback>
+    </xi:include>
+</a>
diff --git a/test/XInclude/docs/fallback5.xml b/test/XInclude/docs/fallback5.xml
new file mode 100644
index 00000000..d3ad4246
--- /dev/null
+++ b/test/XInclude/docs/fallback5.xml
@@ -0,0 +1,83 @@
+<a>
+ <xi:include href="a01.xml" xmlns:xi="http://www.w3.org/2001/XInclude">
+  <xi:fallback>
+   <elem/>
+   <xi:include href="a02.xml">
+    <xi:fallback>
+     <elem/>
+     <xi:include href="a03.xml">
+      <xi:fallback>
+       <elem/>
+       <xi:include href="a04.xml">
+        <xi:fallback>
+         <elem/>
+         <xi:include href="a05.xml">
+          <xi:fallback>
+           <elem/>
+           <xi:include href="a06.xml">
+            <xi:fallback>
+             <elem/>
+             <xi:include href="a07.xml">
+              <xi:fallback>
+               <elem/>
+               <xi:include href="a08.xml">
+                <xi:fallback>
+                 <elem/>
+                 <xi:include href="a09.xml">
+                  <xi:fallback>
+                   <elem/>
+                   <xi:include href="a10.xml">
+                    <xi:fallback>
+                     <elem/>
+                     <xi:include href="a11.xml">
+                      <xi:fallback>
+                       <elem/>
+                       <xi:include href="a12.xml">
+                        <xi:fallback>
+                         <elem/>
+                         <xi:include href="a13.xml">
+                          <xi:fallback>
+                           <elem/>
+                           <xi:include href="a14.xml">
+                            <xi:fallback>
+                             <elem/>
+                             <xi:include href="a15.xml">
+                              <xi:fallback>
+                               <elem/>
+                               <xi:include href="a16.xml">
+                                <xi:fallback>
+                                 <elem/>
+                                </xi:fallback>
+                               </xi:include>
+                              </xi:fallback>
+                             </xi:include>
+                            </xi:fallback>
+                           </xi:include>
+                          </xi:fallback>
+                         </xi:include>
+                        </xi:fallback>
+                       </xi:include>
+                      </xi:fallback>
+                     </xi:include>
+                    </xi:fallback>
+                   </xi:include>
+                  </xi:fallback>
+                 </xi:include>
+                </xi:fallback>
+               </xi:include>
+              </xi:fallback>
+             </xi:include>
+            </xi:fallback>
+           </xi:include>
+          </xi:fallback>
+         </xi:include>
+        </xi:fallback>
+       </xi:include>
+      </xi:fallback>
+     </xi:include>
+    </xi:fallback>
+   </xi:include>
+  </xi:fallback>
+ </xi:include>
+</a>
+
diff --git a/test/XInclude/docs/fallback6.xml b/test/XInclude/docs/fallback6.xml
new file mode 100644
index 00000000..fd00a03f
--- /dev/null
+++ b/test/XInclude/docs/fallback6.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0"?>
+<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="b.xml">
+    <xi:fallback><xi:include href="c.xml">
+        <xi:fallback/>
+    </xi:include></xi:fallback>
+</xi:include>
diff --git a/test/XInclude/docs/ns1.xml b/test/XInclude/docs/ns1.xml
new file mode 100644
index 00000000..7523f4a9
--- /dev/null
+++ b/test/XInclude/docs/ns1.xml
@@ -0,0 +1,12 @@
+<?xml version="1.0"?>
+<doc xmlns:xi="http://www.w3.org/2001/XInclude">
+    <xi:include href="#a"/>
+    <elem xmlns:ns="urn:foo">
+        <ns:elem xml:id="a"/>
+    </elem>
+    <xi:include href="b.xml">
+        <xi:fallback xmlns:ns="urn:bar">
+            <ns:elem/>
+        </xi:fallback>
+    </xi:include>
+</doc>
diff --git a/test/errors/rec_ext.ent b/test/errors/rec_ext.ent
new file mode 100644
index 00000000..345f836f
--- /dev/null
+++ b/test/errors/rec_ext.ent
@@ -0,0 +1 @@
+<ent>&e; &e; &e; &e;</ent>
diff --git a/test/errors/rec_ext_ent.xml b/test/errors/rec_ext_ent.xml
new file mode 100644
index 00000000..b4e7e749
--- /dev/null
+++ b/test/errors/rec_ext_ent.xml
@@ -0,0 +1,4 @@
+<!DOCTYPE doc [
+  <!ENTITY e SYSTEM "rec_ext.ent">
+]>
+<doc>&e; &e; &e; &e;</doc>
diff --git a/test/regexp/bug757711 b/test/regexp/bug757711
new file mode 100644
index 00000000..29098354
--- /dev/null
+++ b/test/regexp/bug757711
@@ -0,0 +1 @@
+=>[;^((-
diff --git a/test/regexp/bug783015 b/test/regexp/bug783015
new file mode 100644
index 00000000..5c91a0f1
--- /dev/null
+++ b/test/regexp/bug783015
@@ -0,0 +1,4 @@
+# This assumes 32-bit ints.
+=>.{2147483647}
+input
+=>.{2147483648}
diff --git a/testapi.c b/testapi.c
index ff8b470d..8a4e23e3 100644
--- a/testapi.c
+++ b/testapi.c
@@ -13613,7 +13613,7 @@ test_xmlParseBalancedChunkMemory(void) {
     int ret_val;
     xmlDocPtr doc; /* the document the chunk pertains to */
     int n_doc;
-    xmlSAXHandlerPtr sax; /* the SAX handler bloc (possibly NULL) */
+    xmlSAXHandlerPtr sax; /* the SAX handler block (possibly NULL) */
     int n_sax;
     void * user_data; /* The user data returned on SAX callbacks (possibly NULL) */
     int n_user_data;
@@ -13689,7 +13689,7 @@ test_xmlParseBalancedChunkMemoryRecover(void) {
     int ret_val;
     xmlDocPtr doc; /* the document the chunk pertains to */
     int n_doc;
-    xmlSAXHandlerPtr sax; /* the SAX handler bloc (possibly NULL) */
+    xmlSAXHandlerPtr sax; /* the SAX handler block (possibly NULL) */
     int n_sax;
     void * user_data; /* The user data returned on SAX callbacks (possibly NULL) */
     int n_user_data;
@@ -14065,7 +14065,7 @@ test_xmlParseExternalEntity(void) {
     int ret_val;
     xmlDocPtr doc; /* the document the chunk pertains to */
     int n_doc;
-    xmlSAXHandlerPtr sax; /* the SAX handler bloc (possibly NULL) */
+    xmlSAXHandlerPtr sax; /* the SAX handler block (possibly NULL) */
     int n_sax;
     void * user_data; /* The user data returned on SAX callbacks (possibly NULL) */
     int n_user_data;
@@ -16158,7 +16158,7 @@ test_xmlErrMemory(void) {
     int mem_base;
     xmlParserCtxtPtr ctxt; /* an XML parser context */
     int n_ctxt;
-    char * extra; /* extra informations */
+    char * extra; /* extra information */
     int n_extra;
 
     for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
diff --git a/threads.c b/threads.c
index 72df9ba9..503d2bfb 100644
--- a/threads.c
+++ b/threads.c
@@ -885,8 +885,6 @@ xmlInitThreads(void)
         }
     }
 #endif /* XML_PTHREAD_WEAK */
-#elif defined(HAVE_WIN32_THREADS) && !defined(HAVE_COMPILER_TLS) && (!defined(LIBXML_STATIC) || defined(LIBXML_STATIC_FOR_DLL))
-    InitializeCriticalSection(&cleanup_helpers_cs);
 #endif
 }
 
@@ -958,6 +956,9 @@ xmlOnceInit(void)
     if (!run_once.done) {
         if (InterlockedIncrement(&run_once.control) == 1) {
 #if !defined(HAVE_COMPILER_TLS)
+#if !defined(LIBXML_STATIC) || defined(LIBXML_STATIC_FOR_DLL)
+            InitializeCriticalSection(&cleanup_helpers_cs);
+#endif
             globalkey = TlsAlloc();
 #endif
             mainthread = GetCurrentThreadId();
diff --git a/tree.c b/tree.c
index 08b1a500..64572d9f 100644
--- a/tree.c
+++ b/tree.c
@@ -70,7 +70,7 @@ static xmlChar* xmlGetPropNodeValueInternal(const xmlAttr *prop);
  ************************************************************************/
 /**
  * xmlTreeErrMemory:
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle an out of memory condition
  */
@@ -83,7 +83,7 @@ xmlTreeErrMemory(const char *extra)
 /**
  * xmlTreeErr:
  * @code:  the error number
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle an out of memory condition
  */
@@ -1064,7 +1064,7 @@ xmlCreateIntSubset(xmlDocPtr doc, const xmlChar *name,
  * @str:  a string
  *
  * Copy a string using a "dict" dictionary in the current scope,
- * if availabe.
+ * if available.
  */
 #define DICT_COPY(str, cpy) \
     if (str) { \
@@ -1081,7 +1081,7 @@ xmlCreateIntSubset(xmlDocPtr doc, const xmlChar *name,
  * @str:  a string
  *
  * Copy a string using a "dict" dictionary in the current scope,
- * if availabe.
+ * if available.
  */
 #define DICT_CONST_COPY(str, cpy) \
     if (str) { \
@@ -1276,12 +1276,14 @@ xmlStringLenGetNodeList(const xmlDoc *doc, const xmlChar *value, int len) {
     xmlNodePtr ret = NULL, last = NULL;
     xmlNodePtr node;
     xmlChar *val;
-    const xmlChar *cur = value, *end = cur + len;
+    const xmlChar *cur, *end;
     const xmlChar *q;
     xmlEntityPtr ent;
     xmlBufPtr buf;
 
     if (value == NULL) return(NULL);
+    cur = value;
+    end = cur + len;
 
     buf = xmlBufCreateSize(0);
     if (buf == NULL) return(NULL);
@@ -3706,6 +3708,11 @@ xmlFreeNodeList(xmlNodePtr cur) {
 		(cur->type != XML_XINCLUDE_START) &&
 		(cur->type != XML_XINCLUDE_END) &&
 		(cur->type != XML_ENTITY_REF_NODE) &&
+		(cur->type != XML_DOCUMENT_NODE) &&
+#ifdef LIBXML_DOCB_ENABLED
+		(cur->type != XML_DOCB_DOCUMENT_NODE) &&
+#endif
+		(cur->type != XML_HTML_DOCUMENT_NODE) &&
 		(cur->content != (xmlChar *) &(cur->properties))) {
 		DICT_FREE(cur->content)
 	    }
@@ -4066,7 +4073,7 @@ xmlCopyPropInternal(xmlDocPtr doc, xmlNodePtr target, xmlAttrPtr cur) {
       } else {
         /*
          * we have to find something appropriate here since
-         * we cant be sure, that the namespace we found is identified
+         * we can't be sure, that the namespace we found is identified
          * by the prefix
          */
         if (xmlStrEqual(ns->href, cur->ns->href)) {
@@ -7243,7 +7250,7 @@ xmlBufferShrink(xmlBufferPtr buf, unsigned int len) {
         ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL))) {
 	/*
 	 * we just move the content pointer, but also make sure
-	 * the perceived buffer size has shrinked accordingly
+	 * the perceived buffer size has shrunk accordingly
 	 */
         buf->content += len;
 	buf->size -= len;
@@ -7417,12 +7424,17 @@ xmlBufferResize(xmlBufferPtr buf, unsigned int size)
     if (size < buf->size)
         return 1;
 
+    if (size > UINT_MAX - 10) {
+        xmlTreeErrMemory("growing buffer");
+        return 0;
+    }
+
     /* figure out new size */
     switch (buf->alloc){
 	case XML_BUFFER_ALLOC_IO:
 	case XML_BUFFER_ALLOC_DOUBLEIT:
 	    /*take care of empty case*/
-	    newSize = (buf->size ? buf->size*2 : size + 10);
+	    newSize = (buf->size ? buf->size : size + 10);
 	    while (size > newSize) {
 	        if (newSize > UINT_MAX / 2) {
 	            xmlTreeErrMemory("growing buffer");
@@ -7438,7 +7450,7 @@ xmlBufferResize(xmlBufferPtr buf, unsigned int size)
             if (buf->use < BASE_BUFFER_SIZE)
                 newSize = size;
             else {
-                newSize = buf->size * 2;
+                newSize = buf->size;
                 while (size > newSize) {
                     if (newSize > UINT_MAX / 2) {
                         xmlTreeErrMemory("growing buffer");
@@ -7595,7 +7607,7 @@ xmlBufferAddHead(xmlBufferPtr buf, const xmlChar *str, int len) {
 
 	if (start_buf > (unsigned int) len) {
 	    /*
-	     * We can add it in the space previously shrinked
+	     * We can add it in the space previously shrunk
 	     */
 	    buf->content -= len;
             memmove(&buf->content[0], str, len);
diff --git a/trio.c b/trio.c
index f7a0da66..ee270bc6 100644
--- a/trio.c
+++ b/trio.c
@@ -10,7 +10,7 @@
  *
  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
- * MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE AUTHORS AND
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE AUTHORS AND
  * CONTRIBUTORS ACCEPT NO RESPONSIBILITY IN ANY CONCEIVABLE MANNER.
  *
  *************************************************************************
diff --git a/trio.h b/trio.h
index 99d21273..dcf96b63 100644
--- a/trio.h
+++ b/trio.h
@@ -10,7 +10,7 @@
  *
  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
- * MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE AUTHORS AND
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE AUTHORS AND
  * CONTRIBUTORS ACCEPT NO RESPONSIBILITY IN ANY CONCEIVABLE MANNER.
  *
  *************************************************************************
diff --git a/triodef.h b/triodef.h
index 46772ee2..e101f6df 100644
--- a/triodef.h
+++ b/triodef.h
@@ -10,7 +10,7 @@
  *
  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
- * MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE AUTHORS AND
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE AUTHORS AND
  * CONTRIBUTORS ACCEPT NO RESPONSIBILITY IN ANY CONCEIVABLE MANNER.
  *
  ************************************************************************/
diff --git a/trionan.c b/trionan.c
index 530b1c0f..8767a9fe 100644
--- a/trionan.c
+++ b/trionan.c
@@ -10,7 +10,7 @@
  *
  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
- * MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE AUTHORS AND
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE AUTHORS AND
  * CONTRIBUTORS ACCEPT NO RESPONSIBILITY IN ANY CONCEIVABLE MANNER.
  *
  ************************************************************************
@@ -123,8 +123,8 @@ static TRIO_CONST char rcsid[] = "@(#)$Id$";
  * integer, becomes 0x0706050403020100 (we could have used a 64-bit
  * integer value instead of a double, but not all platforms supports
  * that type). The value is automatically encoded with the correct
- * endianess by the compiler, which means that we can support any
- * kind of endianess. The individual bytes are then used as an index
+ * endianness by the compiler, which means that we can support any
+ * kind of endianness. The individual bytes are then used as an index
  * for the IEEE 754 bit-patterns and masks.
  */
 #define TRIO_DOUBLE_INDEX(x) (((unsigned char *)&internalEndianMagic)[7-(x)])
diff --git a/trionan.h b/trionan.h
index be6e718a..eac0e6f1 100644
--- a/trionan.h
+++ b/trionan.h
@@ -10,7 +10,7 @@
  *
  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
- * MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE AUTHORS AND
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE AUTHORS AND
  * CONTRIBUTORS ACCEPT NO RESPONSIBILITY IN ANY CONCEIVABLE MANNER.
  *
  ************************************************************************/
diff --git a/triop.h b/triop.h
index 8462c56f..6d486f86 100644
--- a/triop.h
+++ b/triop.h
@@ -10,7 +10,7 @@
  *
  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
- * MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE AUTHORS AND
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE AUTHORS AND
  * CONTRIBUTORS ACCEPT NO RESPONSIBILITY IN ANY CONCEIVABLE MANNER.
  *
  ************************************************************************
diff --git a/triostr.c b/triostr.c
index 123bbebe..5937a44c 100644
--- a/triostr.c
+++ b/triostr.c
@@ -10,7 +10,7 @@
  *
  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
- * MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE AUTHORS AND
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE AUTHORS AND
  * CONTRIBUTORS ACCEPT NO RESPONSIBILITY IN ANY CONCEIVABLE MANNER.
  *
  ************************************************************************/
diff --git a/triostr.h b/triostr.h
index 27f4ace2..0a0e71ad 100644
--- a/triostr.h
+++ b/triostr.h
@@ -10,7 +10,7 @@
  *
  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
- * MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE AUTHORS AND
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE AUTHORS AND
  * CONTRIBUTORS ACCEPT NO RESPONSIBILITY IN ANY CONCEIVABLE MANNER.
  *
  ************************************************************************/
diff --git a/uri.c b/uri.c
index 05d81e57..8204825f 100644
--- a/uri.c
+++ b/uri.c
@@ -11,6 +11,7 @@
 #define IN_LIBXML
 #include "libxml.h"
 
+#include <limits.h>
 #include <string.h>
 
 #include <libxml/xmlmemory.h>
@@ -329,9 +330,14 @@ xmlParse3986Port(xmlURIPtr uri, const char **str)
 
     if (ISA_DIGIT(cur)) {
 	while (ISA_DIGIT(cur)) {
-	    port = port * 10 + (*cur - '0');
-            if (port > 99999999)
-                port = 99999999;
+            int digit = *cur - '0';
+
+            if (port > INT_MAX / 10)
+                return(1);
+            port *= 10;
+            if (port > INT_MAX - digit)
+                return(1);
+	    port += digit;
 
 	    cur++;
 	}
@@ -348,7 +354,7 @@ xmlParse3986Port(xmlURIPtr uri, const char **str)
  * @uri:  pointer to an URI structure
  * @str:  the string to analyze
  *
- * Parse an user informations part and fills in the appropriate fields
+ * Parse an user information part and fills in the appropriate fields
  * of the @uri structure
  *
  * userinfo      = *( unreserved / pct-encoded / sub-delims / ":" )
@@ -1748,11 +1754,6 @@ xmlURIEscape(const xmlChar * str)
     xmlURIPtr uri;
     int ret2;
 
-#define NULLCHK(p) if(!p) { \
-         xmlURIErrMemory("escaping URI value\n"); \
-         xmlFreeURI(uri); \
-         return NULL; } \
-
     if (str == NULL)
         return (NULL);
 
@@ -1774,6 +1775,12 @@ xmlURIEscape(const xmlChar * str)
 
     ret = NULL;
 
+#define NULLCHK(p) if(!p) { \
+         xmlURIErrMemory("escaping URI value\n"); \
+         xmlFreeURI(uri); \
+         xmlFree(ret); \
+         return NULL; } \
+
     if (uri->scheme) {
         segment = xmlURIEscapeStr(BAD_CAST uri->scheme, BAD_CAST "+-.");
         NULLCHK(segment)
@@ -1794,7 +1801,7 @@ xmlURIEscape(const xmlChar * str)
     if (uri->user) {
         segment = xmlURIEscapeStr(BAD_CAST uri->user, BAD_CAST ";:&=+$,");
         NULLCHK(segment)
-		ret = xmlStrcat(ret,BAD_CAST "//");
+        ret = xmlStrcat(ret,BAD_CAST "//");
         ret = xmlStrcat(ret, segment);
         ret = xmlStrcat(ret, BAD_CAST "@");
         xmlFree(segment);
@@ -1803,8 +1810,8 @@ xmlURIEscape(const xmlChar * str)
     if (uri->server) {
         segment = xmlURIEscapeStr(BAD_CAST uri->server, BAD_CAST "/?;:@");
         NULLCHK(segment)
-		if (uri->user == NULL)
-		ret = xmlStrcat(ret, BAD_CAST "//");
+        if (uri->user == NULL)
+            ret = xmlStrcat(ret, BAD_CAST "//");
         ret = xmlStrcat(ret, segment);
         xmlFree(segment);
     }
diff --git a/valid.c b/valid.c
index 07963e74..5ee391c0 100644
--- a/valid.c
+++ b/valid.c
@@ -50,7 +50,7 @@ xmlValidateAttributeValueInternal(xmlDocPtr doc, xmlAttributeType type,
 /**
  * xmlVErrMemory:
  * @ctxt:  an XML validation parser context
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle an out of memory error
  */
@@ -89,7 +89,7 @@ xmlVErrMemory(xmlValidCtxtPtr ctxt, const char *extra)
  * xmlErrValid:
  * @ctxt:  an XML validation parser context
  * @error:  the error number
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle a validation error
  */
@@ -131,11 +131,11 @@ xmlErrValid(xmlValidCtxtPtr ctxt, xmlParserErrors error,
  * @ctxt:  an XML validation parser context
  * @node:  the node raising the error
  * @error:  the error number
- * @str1:  extra informations
- * @str2:  extra informations
- * @str3:  extra informations
+ * @str1:  extra information
+ * @str2:  extra information
+ * @str3:  extra information
  *
- * Handle a validation error, provide contextual informations
+ * Handle a validation error, provide contextual information
  */
 static void LIBXML_ATTR_FORMAT(4,0)
 xmlErrValidNode(xmlValidCtxtPtr ctxt,
@@ -174,11 +174,11 @@ xmlErrValidNode(xmlValidCtxtPtr ctxt,
  * @ctxt:  an XML validation parser context
  * @node:  the node raising the error
  * @error:  the error number
- * @str1:  extra informations
- * @int2:  extra informations
- * @str3:  extra informations
+ * @str1:  extra information
+ * @int2:  extra information
+ * @str3:  extra information
  *
- * Handle a validation error, provide contextual informations
+ * Handle a validation error, provide contextual information
  */
 static void LIBXML_ATTR_FORMAT(4,0)
 xmlErrValidNodeNr(xmlValidCtxtPtr ctxt,
@@ -1174,7 +1174,7 @@ xmlFreeElementContent(xmlElementContentPtr cur) {
  * @buf:  An XML buffer
  * @cur:  An element table
  *
- * Dump the occurence operator of an element.
+ * Dump the occurrence operator of an element.
  */
 static void
 xmlDumpElementOccur(xmlBufferPtr buf, xmlElementContentPtr cur) {
@@ -5434,7 +5434,7 @@ fail:
     } else if (ret == -2) {
 	/*
 	 * An entities reference appeared at this level.
-	 * Buid a minimal representation of this node content
+	 * Build a minimal representation of this node content
 	 * sufficient to run the validation process on it
 	 */
 	DEBUG_VALID_MSG("Found an entity reference, linearizing");
@@ -5919,28 +5919,27 @@ xmlValidatePushCData(xmlValidCtxtPtr ctxt, const xmlChar *data, int len) {
 		    break;
 		case XML_ELEMENT_TYPE_MIXED:
 		    break;
-		case XML_ELEMENT_TYPE_ELEMENT:
-		    if (len > 0) {
-			int i;
-
-			for (i = 0;i < len;i++) {
-			    if (!IS_BLANK_CH(data[i])) {
-				xmlErrValidNode(ctxt, state->node,
-						XML_DTD_CONTENT_MODEL,
-	   "Element %s content does not follow the DTD, Text not allowed\n",
-				       state->node->name, NULL, NULL);
-				ret = 0;
-				goto done;
-			    }
-			}
-			/*
-			 * TODO:
-			 * VC: Standalone Document Declaration
-			 *  element types with element content, if white space
-			 *  occurs directly within any instance of those types.
-			 */
-		    }
-		    break;
+		case XML_ELEMENT_TYPE_ELEMENT: {
+                    int i;
+
+                    for (i = 0;i < len;i++) {
+                        if (!IS_BLANK_CH(data[i])) {
+                            xmlErrValidNode(ctxt, state->node,
+                                            XML_DTD_CONTENT_MODEL,
+       "Element %s content does not follow the DTD, Text not allowed\n",
+                                   state->node->name, NULL, NULL);
+                            ret = 0;
+                            goto done;
+                        }
+                    }
+                    /*
+                     * TODO:
+                     * VC: Standalone Document Declaration
+                     *  element types with element content, if white space
+                     *  occurs directly within any instance of those types.
+                     */
+                    break;
+                }
 	    }
 	}
     }
diff --git a/win32/Makefile.msvc b/win32/Makefile.msvc
index f6a0182d..725b0ca1 100644
--- a/win32/Makefile.msvc
+++ b/win32/Makefile.msvc
@@ -106,6 +106,11 @@ CFLAGS = $(CFLAGS) /D "NDEBUG" /O2
 LDFLAGS = $(LDFLAGS)
 !endif
 
+# append CFLAGS etc. passed on command line
+CPPFLAGS = $(CPPFLAGS) $(EXTRA_CPPFLAGS)
+CFLAGS = $(CFLAGS) $(EXTRA_CFLAGS)
+LDFLAGS = $(LDFLAGS) $(EXTRA_LDFLAGS)
+
 # Libxml object files.
 XML_OBJS = $(XML_INTDIR)\buf.obj\
 	$(XML_INTDIR)\c14n.obj\
diff --git a/win32/Readme.txt b/win32/Readme.txt
index 6b3edddb..d02070e2 100644
--- a/win32/Readme.txt
+++ b/win32/Readme.txt
@@ -23,7 +23,7 @@ CONTENTS
    2.1 GNU C/C++, Mingw Edition
    2.2 Borland C++ Builder
        2.2.1 Building with iconv support
-	   2.2.2 Compatability problems with MSVC (and probably CYGWIN)
+	   2.2.2 Compatibility problems with MSVC (and probably CYGWIN)
 	   2.2.3 Other caveats
 
 
@@ -188,7 +188,7 @@ define EILSEQ=2 in Makefile.bcb. The value "2" is the value for ENOFILE (file
 not found). This should not have any disastrous side effects beyond possibly
 displaying a misleading error message in certain situations.
 
-2.2.2 Compatability problems with MSVC (and probably CYGWIN)
+2.2.2 Compatibility problems with MSVC (and probably CYGWIN)
 
 A libxml2 DLL generated by BCB is callable from MSVC programs, but there is a
 minor problem with the names of the symbols exported from the library. The
diff --git a/win32/VC10/README.vc10 b/win32/VC10/README.vc10
index 4805bdc8..d33430b5 100644
--- a/win32/VC10/README.vc10
+++ b/win32/VC10/README.vc10
@@ -3,13 +3,13 @@ README file for VC10 project files for libxml2
 ----------------------------------------------
 
 to clarify: This is not the readme file for the whole libxml2 project. 
-Rather, it's a readme for the VC10 project files, attached to the libxml2 proejct.
+Rather, it's a readme for the VC10 project files, attached to the libxml2 project.
 
 Quick Start
 -----------
 
 1) To use, load the libxml2.sln solution file into visual studio
-2) check and correct paths for dependent "iconv" project which most certaily 
+2) check and correct paths for dependent "iconv" project which most certainly 
 are wrong on your environment.
 3) Compile all projects
 
diff --git a/win32/configure.js b/win32/configure.js
index e8c13ee0..cec64c53 100644
--- a/win32/configure.js
+++ b/win32/configure.js
@@ -165,9 +165,9 @@ function usage()
 	txt += "              installed (" + buildLibPrefix + ")\n";
 	txt += "  sodir:      Directory where shared libraries should be installed\n"; 
 	txt += "              (" + buildSoPrefix + ")\n";
-	txt += "  include:    Additional search path for the compiler, particularily\n";
+	txt += "  include:    Additional search path for the compiler, particularly\n";
 	txt += "              where iconv headers can be found (" + buildInclude + ")\n";
-	txt += "  lib:        Additional search path for the linker, particularily\n";
+	txt += "  lib:        Additional search path for the linker, particularly\n";
 	txt += "              where iconv library can be found (" + buildLib + ")\n";
 	WScript.Echo(txt);
 }
@@ -208,18 +208,18 @@ function discoverVersion()
 	while (cf.AtEndOfStream != true) {
 		ln = cf.ReadLine();
 		s = new String(ln);
-		if (s.search(/^LIBXML_MAJOR_VERSION=/) != -1) {
-			vf.WriteLine(s);
-			verMajor = s.substring(s.indexOf("=") + 1, s.length)
-		} else if(s.search(/^LIBXML_MINOR_VERSION=/) != -1) {
-			vf.WriteLine(s);
-			verMinor = s.substring(s.indexOf("=") + 1, s.length)
-		} else if(s.search(/^LIBXML_MICRO_VERSION=/) != -1) {
-			vf.WriteLine(s);
-			verMicro = s.substring(s.indexOf("=") + 1, s.length)
+		if (m = s.match(/^m4_define\(\[MAJOR_VERSION\], (\w+)\)/)) {
+			vf.WriteLine("LIBXML_MAJOR_VERSION=" + m[1]);
+			verMajor = m[1];
+		} else if(m = s.match(/^m4_define\(\[MINOR_VERSION\], (\w+)\)/)) {
+			vf.WriteLine("LIBXML_MINOR_VERSION=" + m[1]);
+			verMinor = m[1];
+		} else if(m = s.match(/^m4_define\(\[MICRO_VERSION\], (\w+)\)/)) {
+			vf.WriteLine("LIBXML_MICRO_VERSION=" + m[1]);
+			verMicro = m[1];
 		} else if(s.search(/^LIBXML_MICRO_VERSION_SUFFIX=/) != -1) {
 			vf.WriteLine(s);
-			verMicroSuffix = s.substring(s.indexOf("=") + 1, s.length)
+			verMicroSuffix = s.substring(s.indexOf("=") + 1, s.length);
 		}
 	}
 	cf.Close();
@@ -280,7 +280,7 @@ function discoverVersion()
 		vf.WriteLine("DYNRUNTIME=" + (dynruntime? "1" : "0"));
 	}
 	vf.Close();
-	versionFile = "rcVersion.h"
+	versionFile = "rcVersion.h";
 	vf = fso.CreateTextFile(versionFile, true);
 	vf.WriteLine("/*");
 	vf.WriteLine("  " + versionFile);
@@ -291,7 +291,7 @@ function discoverVersion()
 	vf.WriteLine("#define LIBXML_MINOR_VERSION " + verMinor);
 	vf.WriteLine("#define LIBXML_MICRO_VERSION " + verMicro);
 	vf.WriteLine("#define LIBXML_DOTTED_VERSION " + "\"" + verMajor + "." + verMinor + "." + verMicro + "\"");
-	vf.Close()
+	vf.Close();
 }
 
 /* Configures libxml. This one will generate xmlversion.h from xmlversion.h.in
@@ -430,7 +430,7 @@ function genReadme(bname, ver, file)
 	f.WriteLine("platform.");
 	f.WriteBlankLines(1);
 	f.WriteLine("  The files in this package do not require any special installation");
-	f.WriteLine("steps. Extract the contents of the archive whereever you wish and");
+	f.WriteLine("steps. Extract the contents of the archive wherever you wish and");
 	f.WriteLine("make sure that your tools which use " + bname + " can find it.");
 	f.WriteBlankLines(1);
 	f.WriteLine("  For example, if you want to run the supplied utilities from the command");
@@ -544,8 +544,6 @@ for (i = 0; (i < WScript.Arguments.length) && (error == 0); i++) {
 			buildStatic = strToBool(arg.substring(opt.length + 1, arg.length));
 		else if (opt == "prefix")
 			buildPrefix = arg.substring(opt.length + 1, arg.length);
-		else if (opt == "incdir")
-			buildIncPrefix = arg.substring(opt.length + 1, arg.length);
 		else if (opt == "bindir")
 			buildBinPrefix = arg.substring(opt.length + 1, arg.length);
 		else if (opt == "libdir")
diff --git a/xinclude.c b/xinclude.c
index ba850fa5..1636caff 100644
--- a/xinclude.c
+++ b/xinclude.c
@@ -59,7 +59,7 @@ struct _xmlXIncludeRef {
     xmlNodePtr            inc; /* the included copy */
     int                   xml; /* xml or txt */
     int                 count; /* how many refs use that specific doc */
-    xmlXPathObjectPtr    xptr; /* the xpointer if needed */
+    int	             fallback; /* fallback was loaded */
     int		      emptyFb; /* flag to show fallback empty */
 };
 
@@ -72,7 +72,7 @@ struct _xmlXIncludeCtxt {
 
     int                 txtNr; /* number of unparsed documents */
     int                txtMax; /* size of unparsed documents tab */
-    xmlNodePtr        *txtTab; /* array of unparsed text nodes */
+    xmlChar *         *txtTab; /* array of unparsed text strings */
     xmlURL         *txturlTab; /* array of unparsed text URLs */
 
     xmlChar *             url; /* the current URL processed */
@@ -86,10 +86,13 @@ struct _xmlXIncludeCtxt {
     xmlChar *		 base; /* the current xml:base */
 
     void            *_private; /* application data */
+
+    unsigned long    incTotal; /* total number of processed inclusions */
 };
 
 static int
-xmlXIncludeDoProcess(xmlXIncludeCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr tree);
+xmlXIncludeDoProcess(xmlXIncludeCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr tree,
+                     int skipRoot);
 
 
 /************************************************************************
@@ -207,8 +210,6 @@ xmlXIncludeFreeRef(xmlXIncludeRefPtr ref) {
 	xmlFree(ref->URI);
     if (ref->fragment != NULL)
 	xmlFree(ref->fragment);
-    if (ref->xptr != NULL)
-	xmlXPathFreeObject(ref->xptr);
     xmlFree(ref);
 }
 
@@ -392,18 +393,22 @@ xmlXIncludeFreeContext(xmlXIncludeCtxtPtr ctxt) {
 	if (ctxt->incTab[i] != NULL)
 	    xmlXIncludeFreeRef(ctxt->incTab[i]);
     }
+    if (ctxt->incTab != NULL)
+	xmlFree(ctxt->incTab);
+    if (ctxt->txtTab != NULL) {
+	for (i = 0;i < ctxt->txtNr;i++) {
+	    if (ctxt->txtTab[i] != NULL)
+		xmlFree(ctxt->txtTab[i]);
+	}
+	xmlFree(ctxt->txtTab);
+    }
     if (ctxt->txturlTab != NULL) {
 	for (i = 0;i < ctxt->txtNr;i++) {
 	    if (ctxt->txturlTab[i] != NULL)
 		xmlFree(ctxt->txturlTab[i]);
 	}
-    }
-    if (ctxt->incTab != NULL)
-	xmlFree(ctxt->incTab);
-    if (ctxt->txtTab != NULL)
-	xmlFree(ctxt->txtTab);
-    if (ctxt->txturlTab != NULL)
 	xmlFree(ctxt->txturlTab);
+    }
     if (ctxt->base != NULL) {
         xmlFree(ctxt->base);
     }
@@ -626,8 +631,8 @@ xmlXIncludeAddNode(xmlXIncludeCtxtPtr ctxt, xmlNodePtr cur) {
 	xmlXIncludeErr(ctxt, cur, XML_XINCLUDE_RECURSION,
 	               "detected a local recursion with no xpointer in %s\n",
 		       URL);
-	if (fragment != NULL)
-	    xmlFree(fragment);
+        xmlFree(URL);
+        xmlFree(fragment);
 	return(-1);
     }
 
@@ -639,12 +644,15 @@ xmlXIncludeAddNode(xmlXIncludeCtxtPtr ctxt, xmlNodePtr cur) {
 	    if (xmlStrEqual(URL, ctxt->urlTab[i])) {
 		xmlXIncludeErr(ctxt, cur, XML_XINCLUDE_RECURSION,
 		               "detected a recursion in %s\n", URL);
+                xmlFree(URL);
+                xmlFree(fragment);
 		return(-1);
 	    }
 	}
     }
 
     ref = xmlXIncludeNewRef(ctxt, URL, cur);
+    xmlFree(URL);
     if (ref == NULL) {
 	return(-1);
     }
@@ -652,7 +660,6 @@ xmlXIncludeAddNode(xmlXIncludeCtxtPtr ctxt, xmlNodePtr cur) {
     ref->doc = NULL;
     ref->xml = xml;
     ref->count = 1;
-    xmlFree(URL);
     return(0);
 }
 
@@ -729,7 +736,9 @@ xmlXIncludeRecurseDoc(xmlXIncludeCtxtPtr ctxt, xmlDocPtr doc,
 	 * (bug 132597)
 	 */
 	newctxt->parseFlags = ctxt->parseFlags;
-	xmlXIncludeDoProcess(newctxt, doc, xmlDocGetRootElement(doc));
+        newctxt->incTotal = ctxt->incTotal;
+	xmlXIncludeDoProcess(newctxt, doc, xmlDocGetRootElement(doc), 0);
+        ctxt->incTotal = newctxt->incTotal;
 	for (i = 0;i < ctxt->incNr;i++) {
 	    newctxt->incTab[i]->count--;
 	    newctxt->incTab[i] = NULL;
@@ -759,13 +768,14 @@ xmlXIncludeRecurseDoc(xmlXIncludeCtxtPtr ctxt, xmlDocPtr doc,
  * Add a new text node to the list
  */
 static void
-xmlXIncludeAddTxt(xmlXIncludeCtxtPtr ctxt, xmlNodePtr txt, const xmlURL url) {
+xmlXIncludeAddTxt(xmlXIncludeCtxtPtr ctxt, const xmlChar *txt,
+                  const xmlURL url) {
 #ifdef DEBUG_XINCLUDE
     xmlGenericError(xmlGenericErrorContext, "Adding text %s\n", url);
 #endif
     if (ctxt->txtMax == 0) {
 	ctxt->txtMax = 4;
-        ctxt->txtTab = (xmlNodePtr *) xmlMalloc(ctxt->txtMax *
+        ctxt->txtTab = (xmlChar **) xmlMalloc(ctxt->txtMax *
 		                          sizeof(ctxt->txtTab[0]));
         if (ctxt->txtTab == NULL) {
 	    xmlXIncludeErrMemory(ctxt, NULL, "processing text");
@@ -780,7 +790,7 @@ xmlXIncludeAddTxt(xmlXIncludeCtxtPtr ctxt, xmlNodePtr txt, const xmlURL url) {
     }
     if (ctxt->txtNr >= ctxt->txtMax) {
 	ctxt->txtMax *= 2;
-        ctxt->txtTab = (xmlNodePtr *) xmlRealloc(ctxt->txtTab,
+        ctxt->txtTab = (xmlChar **) xmlRealloc(ctxt->txtTab,
 	             ctxt->txtMax * sizeof(ctxt->txtTab[0]));
         if (ctxt->txtTab == NULL) {
 	    xmlXIncludeErrMemory(ctxt, NULL, "processing text");
@@ -793,7 +803,7 @@ xmlXIncludeAddTxt(xmlXIncludeCtxtPtr ctxt, xmlNodePtr txt, const xmlURL url) {
 	    return;
 	}
     }
-    ctxt->txtTab[ctxt->txtNr] = txt;
+    ctxt->txtTab[ctxt->txtNr] = xmlStrdup(txt);
     ctxt->txturlTab[ctxt->txtNr] = xmlStrdup(url);
     ctxt->txtNr++;
 }
@@ -1071,7 +1081,7 @@ xmlXIncludeCopyRange(xmlXIncludeCtxtPtr ctxt, xmlDocPtr target,
 		case XML_ELEMENT_DECL:
 		case XML_ATTRIBUTE_DECL:
 		case XML_ENTITY_NODE:
-		    /* Do not copy DTD informations */
+		    /* Do not copy DTD information */
 		    break;
 		case XML_ENTITY_DECL:
 		    /* handle crossing entities -> stack needed */
@@ -1459,7 +1469,7 @@ xmlXIncludeLoadDoc(xmlXIncludeCtxtPtr ctxt, const xmlChar *url, int nr) {
      */
     if ((URL[0] == 0) || (URL[0] == '#') ||
 	((ctxt->doc != NULL) && (xmlStrEqual(URL, ctxt->doc->URL)))) {
-	doc = NULL;
+	doc = ctxt->doc;
         goto loaded;
     }
 
@@ -1551,15 +1561,8 @@ loaded:
 	/*
 	 * Add the top children list as the replacement copy.
 	 */
-	if (doc == NULL)
-	{
-	    /* Hopefully a DTD declaration won't be copied from
-	     * the same document */
-	    ctxt->incTab[nr]->inc = xmlCopyNodeList(ctxt->doc->children);
-	} else {
-	    ctxt->incTab[nr]->inc = xmlXIncludeCopyNodeList(ctxt, ctxt->doc,
-		                                       doc, doc->children);
-	}
+	ctxt->incTab[nr]->inc = xmlXIncludeCopyNodeList(ctxt, ctxt->doc,
+		                                        doc, doc->children);
     }
 #ifdef LIBXML_XPTR_ENABLED
     else {
@@ -1571,12 +1574,7 @@ loaded:
 	xmlXPathContextPtr xptrctxt;
 	xmlNodeSetPtr set;
 
-	if (doc == NULL) {
-	    xptrctxt = xmlXPtrNewContext(ctxt->doc, ctxt->incTab[nr]->ref,
-		                         NULL);
-	} else {
-	    xptrctxt = xmlXPtrNewContext(doc, NULL, NULL);
-	}
+	xptrctxt = xmlXPtrNewContext(doc, NULL, NULL);
 	if (xptrctxt == NULL) {
 	    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,
 	                   XML_XINCLUDE_XPTR_FAILED,
@@ -1608,6 +1606,7 @@ loaded:
 		               XML_XINCLUDE_XPTR_RESULT,
 			       "XPointer is not a range: #%s\n",
 			       fragment);
+                xmlXPathFreeObject(xptr);
 		xmlXPathFreeContext(xptrctxt);
 		xmlFree(URL);
 		xmlFree(fragment);
@@ -1615,6 +1614,7 @@ loaded:
 	    case XPATH_NODESET:
 	        if ((xptr->nodesetval == NULL) ||
 		    (xptr->nodesetval->nodeNr <= 0)) {
+                    xmlXPathFreeObject(xptr);
 		    xmlXPathFreeContext(xptrctxt);
 		    xmlFree(URL);
 		    xmlFree(fragment);
@@ -1678,14 +1678,9 @@ loaded:
 		}
 	    }
 	}
-	if (doc == NULL) {
-	    ctxt->incTab[nr]->xptr = xptr;
-	    ctxt->incTab[nr]->inc = NULL;
-	} else {
-	    ctxt->incTab[nr]->inc =
-		xmlXIncludeCopyXPointer(ctxt, ctxt->doc, doc, xptr);
-	    xmlXPathFreeObject(xptr);
-	}
+        ctxt->incTab[nr]->inc =
+            xmlXIncludeCopyXPointer(ctxt, ctxt->doc, doc, xptr);
+        xmlXPathFreeObject(xptr);
 	xmlXPathFreeContext(xptrctxt);
 	xmlFree(fragment);
     }
@@ -1855,7 +1850,7 @@ xmlXIncludeLoadTxt(xmlXIncludeCtxtPtr ctxt, const xmlChar *url, int nr) {
      */
     for (i = 0; i < ctxt->txtNr; i++) {
 	if (xmlStrEqual(URL, ctxt->txturlTab[i])) {
-	    node = xmlCopyNode(ctxt->txtTab[i], 1);
+            node = xmlNewText(ctxt->txtTab[i]);
 	    goto loaded;
 	}
     }
@@ -1945,7 +1940,7 @@ xinclude_multibyte_fallback:
 	xmlBufShrink(buf->buffer, len);
     }
     xmlFreeParserCtxt(pctxt);
-    xmlXIncludeAddTxt(ctxt, node, URL);
+    xmlXIncludeAddTxt(ctxt, node->content, URL);
     xmlFreeInputStream(inputStream);
 
 loaded:
@@ -1988,19 +1983,23 @@ xmlXIncludeLoadFallback(xmlXIncludeCtxtPtr ctxt, xmlNodePtr fallback, int nr) {
 	newctxt->_private = ctxt->_private;
 	newctxt->base = xmlStrdup(ctxt->base);	/* Inherit the base from the existing context */
 	xmlXIncludeSetFlags(newctxt, ctxt->parseFlags);
-	ret = xmlXIncludeDoProcess(newctxt, ctxt->doc, fallback->children);
+        newctxt->incTotal = ctxt->incTotal;
+        if (xmlXIncludeDoProcess(newctxt, ctxt->doc, fallback, 1) < 0)
+            ret = -1;
+        ctxt->incTotal = newctxt->incTotal;
 	if (ctxt->nbErrors > oldNbErrors)
 	    ret = -1;
-	else if (ret > 0)
-	    ret = 0;	/* xmlXIncludeDoProcess can return +ve number */
 	xmlXIncludeFreeContext(newctxt);
 
 	ctxt->incTab[nr]->inc = xmlDocCopyNodeList(ctxt->doc,
 	                                           fallback->children);
+        if (ctxt->incTab[nr]->inc == NULL)
+            ctxt->incTab[nr]->emptyFb = 1;
     } else {
         ctxt->incTab[nr]->inc = NULL;
 	ctxt->incTab[nr]->emptyFb = 1;	/* flag empty callback */
     }
+    ctxt->incTab[nr]->fallback = 1;
     return(ret);
 }
 
@@ -2156,8 +2155,7 @@ xmlXIncludeLoadNode(xmlXIncludeCtxtPtr ctxt, int nr) {
 		((xmlStrEqual(children->ns->href, XINCLUDE_NS)) ||
 		 (xmlStrEqual(children->ns->href, XINCLUDE_OLD_NS)))) {
 		ret = xmlXIncludeLoadFallback(ctxt, children, nr);
-		if (ret == 0)
-		    break;
+		break;
 	    }
 	    children = children->next;
 	}
@@ -2204,19 +2202,9 @@ xmlXIncludeIncludeNode(xmlXIncludeCtxtPtr ctxt, int nr) {
     if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL))
 	return(-1);
 
-    /*
-     * If we stored an XPointer a late computation may be needed
-     */
-    if ((ctxt->incTab[nr]->inc == NULL) &&
-	(ctxt->incTab[nr]->xptr != NULL)) {
-	ctxt->incTab[nr]->inc =
-	    xmlXIncludeCopyXPointer(ctxt, ctxt->doc, ctxt->doc,
-		                    ctxt->incTab[nr]->xptr);
-	xmlXPathFreeObject(ctxt->incTab[nr]->xptr);
-	ctxt->incTab[nr]->xptr = NULL;
-    }
     list = ctxt->incTab[nr]->inc;
     ctxt->incTab[nr]->inc = NULL;
+    ctxt->incTab[nr]->emptyFb = 0;
 
     /*
      * Check against the risk of generating a multi-rooted document
@@ -2236,6 +2224,7 @@ xmlXIncludeIncludeNode(xmlXIncludeCtxtPtr ctxt, int nr) {
 	                   XML_XINCLUDE_MULTIPLE_ROOT,
 		       "XInclude error: would result in multiple root nodes\n",
 			   NULL);
+            xmlFreeNodeList(list);
 	    return(-1);
 	}
     }
@@ -2253,16 +2242,27 @@ xmlXIncludeIncludeNode(xmlXIncludeCtxtPtr ctxt, int nr) {
 	xmlUnlinkNode(cur);
 	xmlFreeNode(cur);
     } else {
+        xmlNodePtr child, next;
+
 	/*
 	 * Change the current node as an XInclude start one, and add an
 	 * XInclude end one
 	 */
+        if (ctxt->incTab[nr]->fallback)
+            xmlUnsetProp(cur, BAD_CAST "href");
 	cur->type = XML_XINCLUDE_START;
+        /* Remove fallback children */
+        for (child = cur->children; child != NULL; child = next) {
+            next = child->next;
+            xmlUnlinkNode(child);
+            xmlFreeNode(child);
+        }
 	end = xmlNewDocNode(cur->doc, cur->ns, cur->name, NULL);
 	if (end == NULL) {
 	    xmlXIncludeErr(ctxt, ctxt->incTab[nr]->ref,
 	                   XML_XINCLUDE_BUILD_FAILED,
 			   "failed to build node\n", NULL);
+            xmlFreeNodeList(list);
 	    return(-1);
 	}
 	end->type = XML_XINCLUDE_END;
@@ -2364,6 +2364,7 @@ xmlXIncludeTestNode(xmlXIncludeCtxtPtr ctxt, xmlNodePtr node) {
  * @ctxt: the XInclude processing context
  * @doc: an XML document
  * @tree: the top of the tree to process
+ * @skipRoot: don't process the root node of the tree
  *
  * Implement the XInclude substitution on the XML document @doc
  *
@@ -2371,13 +2372,16 @@ xmlXIncludeTestNode(xmlXIncludeCtxtPtr ctxt, xmlNodePtr node) {
  *    or the number of substitutions done.
  */
 static int
-xmlXIncludeDoProcess(xmlXIncludeCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr tree) {
+xmlXIncludeDoProcess(xmlXIncludeCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr tree,
+                     int skipRoot) {
     xmlNodePtr cur;
     int ret = 0;
     int i, start;
 
     if ((doc == NULL) || (tree == NULL) || (tree->type == XML_NAMESPACE_DECL))
 	return(-1);
+    if ((skipRoot) && (tree->children == NULL))
+        return(-1);
     if (ctxt == NULL)
 	return(-1);
 
@@ -2388,41 +2392,60 @@ xmlXIncludeDoProcess(xmlXIncludeCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr tree) {
     }
     start = ctxt->incNr;
 
+    /*
+     * TODO: The phases must run separately for recursive inclusions.
+     *
+     * - Phase 1 should start with top-level XInclude nodes, load documents,
+     *   execute XPointer expressions, then process only the result nodes
+     *   (not whole document, see bug #324081) and only for phase 1
+     *   recursively. We will need a backreference from xmlNodes to
+     *   xmlIncludeRefs to detect references that were already visited.
+     *   This can also be used for proper cycle detection, see bug #344240.
+     *
+     * - Phase 2 should visit all top-level XInclude nodes and expand
+     *   possible subreferences in the replacement recursively.
+     *
+     * - Phase 3 should finally replace the top-level XInclude nodes.
+     *   It could also be run together with phase 2.
+     */
+
     /*
      * First phase: lookup the elements in the document
      */
-    cur = tree;
-    if (xmlXIncludeTestNode(ctxt, cur) == 1)
-	xmlXIncludePreProcessNode(ctxt, cur);
-    while ((cur != NULL) && (cur != tree->parent)) {
+    if (skipRoot)
+        cur = tree->children;
+    else
+        cur = tree;
+    do {
 	/* TODO: need to work on entities -> stack */
-	if ((cur->children != NULL) &&
-	    (cur->children->type != XML_ENTITY_DECL) &&
-	    (cur->children->type != XML_XINCLUDE_START) &&
-	    (cur->children->type != XML_XINCLUDE_END)) {
-	    cur = cur->children;
-	    if (xmlXIncludeTestNode(ctxt, cur))
-		xmlXIncludePreProcessNode(ctxt, cur);
-	} else if (cur->next != NULL) {
-	    cur = cur->next;
-	    if (xmlXIncludeTestNode(ctxt, cur))
-		xmlXIncludePreProcessNode(ctxt, cur);
-	} else {
-	    if (cur == tree)
-	        break;
-	    do {
-		cur = cur->parent;
-		if ((cur == NULL) || (cur == tree->parent))
-		    break; /* do */
-		if (cur->next != NULL) {
-		    cur = cur->next;
-		    if (xmlXIncludeTestNode(ctxt, cur))
-			xmlXIncludePreProcessNode(ctxt, cur);
-		    break; /* do */
-		}
-	    } while (cur != NULL);
-	}
-    }
+        if (xmlXIncludeTestNode(ctxt, cur) == 1) {
+#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
+            /*
+             * Avoid superlinear expansion by limiting the total number
+             * of replacements.
+             */
+            if (ctxt->incTotal >= 20)
+                return(-1);
+#endif
+            ctxt->incTotal++;
+            xmlXIncludePreProcessNode(ctxt, cur);
+        } else if ((cur->children != NULL) &&
+                   (cur->children->type != XML_ENTITY_DECL) &&
+                   (cur->children->type != XML_XINCLUDE_START) &&
+                   (cur->children->type != XML_XINCLUDE_END)) {
+            cur = cur->children;
+            continue;
+        }
+        do {
+            if (cur == tree)
+                break;
+            if (cur->next != NULL) {
+                cur = cur->next;
+                break;
+            }
+            cur = cur->parent;
+        } while (cur != NULL);
+    } while ((cur != NULL) && (cur != tree));
 
     /*
      * Second Phase : collect the infosets fragments
@@ -2445,8 +2468,7 @@ xmlXIncludeDoProcess(xmlXIncludeCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr tree) {
      */
     for (i = ctxt->incBase;i < ctxt->incNr; i++) {
 	if ((ctxt->incTab[i]->inc != NULL) ||
-		(ctxt->incTab[i]->xptr != NULL) ||
-		(ctxt->incTab[i]->emptyFb != 0))	/* (empty fallback) */
+	    (ctxt->incTab[i]->emptyFb != 0))	/* (empty fallback) */
 	    xmlXIncludeIncludeNode(ctxt, i);
     }
 
@@ -2500,7 +2522,7 @@ xmlXIncludeProcessTreeFlagsData(xmlNodePtr tree, int flags, void *data) {
     ctxt->_private = data;
     ctxt->base = xmlStrdup((xmlChar *)tree->doc->URL);
     xmlXIncludeSetFlags(ctxt, flags);
-    ret = xmlXIncludeDoProcess(ctxt, tree->doc, tree);
+    ret = xmlXIncludeDoProcess(ctxt, tree->doc, tree, 0);
     if ((ret >= 0) && (ctxt->nbErrors > 0))
         ret = -1;
 
@@ -2584,7 +2606,7 @@ xmlXIncludeProcessTreeFlags(xmlNodePtr tree, int flags) {
 	return(-1);
     ctxt->base = xmlNodeGetBase(tree->doc, tree);
     xmlXIncludeSetFlags(ctxt, flags);
-    ret = xmlXIncludeDoProcess(ctxt, tree->doc, tree);
+    ret = xmlXIncludeDoProcess(ctxt, tree->doc, tree, 0);
     if ((ret >= 0) && (ctxt->nbErrors > 0))
 	ret = -1;
 
@@ -2612,7 +2634,7 @@ xmlXIncludeProcessTree(xmlNodePtr tree) {
  * @node: a node in an XML document
  *
  * Implement the XInclude substitution for the given subtree reusing
- * the informations and data coming from the given context.
+ * the information and data coming from the given context.
  *
  * Returns 0 if no substitution were done, -1 if some processing failed
  *    or the number of substitutions done.
@@ -2624,7 +2646,7 @@ xmlXIncludeProcessNode(xmlXIncludeCtxtPtr ctxt, xmlNodePtr node) {
     if ((node == NULL) || (node->type == XML_NAMESPACE_DECL) ||
         (node->doc == NULL) || (ctxt == NULL))
 	return(-1);
-    ret = xmlXIncludeDoProcess(ctxt, node->doc, node);
+    ret = xmlXIncludeDoProcess(ctxt, node->doc, node, 0);
     if ((ret >= 0) && (ctxt->nbErrors > 0))
 	ret = -1;
     return(ret);
diff --git a/xml2-config.in b/xml2-config.in
index cb4aa613..5863ffa0 100644
--- a/xml2-config.in
+++ b/xml2-config.in
@@ -4,6 +4,8 @@ prefix=@prefix@
 exec_prefix=@exec_prefix@
 includedir=@includedir@
 libdir=@libdir@
+cflags=
+libs=
 
 usage()
 {
@@ -95,14 +97,13 @@ while test $# -gt 0; do
         ;;
 
     *)
-	usage
-	exit 1
+	usage 1
 	;;
     esac
     shift
 done
 
-if test "$cflags" -o "$libs"; then
+if test -n "$cflags$libs"; then
     echo $cflags $libs
 fi
 
diff --git a/xmlIO.c b/xmlIO.c
index 752d5e0a..57312b97 100644
--- a/xmlIO.c
+++ b/xmlIO.c
@@ -224,7 +224,7 @@ __xmlIOWin32UTF8ToWChar(const char *u8String)
 
 /**
  * xmlIOErrMemory:
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle an out of memory condition
  */
@@ -238,7 +238,7 @@ xmlIOErrMemory(const char *extra)
  * __xmlIOErr:
  * @code:  the error number
  * @
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle an I/O error
  */
@@ -416,7 +416,7 @@ __xmlIOErr(int domain, int code, const char *extra)
 /**
  * xmlIOErr:
  * @code:  the error number
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle an I/O error
  */
@@ -429,7 +429,7 @@ xmlIOErr(int code, const char *extra)
 /**
  * __xmlLoaderErr:
  * @ctx: the parser context
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle a resource access error
  */
@@ -560,6 +560,33 @@ xmlCleanupOutputCallbacks(void)
     xmlOutputCallbackNr = 0;
     xmlOutputCallbackInitialized = 0;
 }
+
+/**
+ * xmlPopOutputCallbacks:
+ *
+ * Remove the top output callbacks from the output stack. This includes the
+ * compiled-in I/O.
+ *
+ * Returns the number of output callback registered or -1 in case of error.
+ */
+int
+xmlPopOutputCallbacks(void)
+{
+    if (!xmlOutputCallbackInitialized)
+        return(-1);
+
+    if (xmlOutputCallbackNr <= 0)
+        return(-1);
+
+    xmlOutputCallbackNr--;
+    xmlOutputCallbackTable[xmlOutputCallbackNr].matchcallback = NULL;
+    xmlOutputCallbackTable[xmlOutputCallbackNr].opencallback = NULL;
+    xmlOutputCallbackTable[xmlOutputCallbackNr].writecallback = NULL;
+    xmlOutputCallbackTable[xmlOutputCallbackNr].closecallback = NULL;
+
+    return(xmlOutputCallbackNr);
+}
+
 #endif /* LIBXML_OUTPUT_ENABLED */
 
 /************************************************************************
@@ -3374,18 +3401,12 @@ xmlOutputBufferWrite(xmlOutputBufferPtr out, int len, const char *buf) {
 		out->error = XML_IO_ENCODER;
 		return(-1);
 	    }
-            if (out->writecallback)
-	        nbchars = xmlBufUse(out->conv);
-            else
-                nbchars = ret;
+            nbchars = ret >= 0 ? ret : 0;
 	} else {
 	    ret = xmlBufAdd(out->buffer, (const xmlChar *) buf, chunk);
 	    if (ret != 0)
 	        return(-1);
-            if (out->writecallback)
-	        nbchars = xmlBufUse(out->buffer);
-            else
-                nbchars = chunk;
+            nbchars = chunk;
 	}
 	buf += chunk;
 	len -= chunk;
@@ -3572,19 +3593,13 @@ xmlOutputBufferWriteEscape(xmlOutputBufferPtr out, const xmlChar *str,
 		out->error = XML_IO_ENCODER;
 		return(-1);
 	    }
-            if (out->writecallback)
-	        nbchars = xmlBufUse(out->conv);
-            else
-                nbchars = ret;
+            nbchars = ret >= 0 ? ret : 0;
 	} else {
 	    ret = escaping(xmlBufEnd(out->buffer), &chunk, str, &cons);
 	    if ((ret < 0) || (chunk == 0)) /* chunk==0 => nothing done */
 	        return(-1);
             xmlBufAddLen(out->buffer, chunk);
-            if (out->writecallback)
-	        nbchars = xmlBufUse(out->buffer);
-            else
-                nbchars = chunk;
+            nbchars = chunk;
 	}
 	str += cons;
 	len -= cons;
diff --git a/xmlcatalog.c b/xmlcatalog.c
index c02b97f6..3f0e1b9c 100644
--- a/xmlcatalog.c
+++ b/xmlcatalog.c
@@ -325,7 +325,7 @@ Usage : %s [options] catalogfile entities...\n\
 \t         used with --add or --del, it saves the catalog changes\n\
 \t         and with --sgml it automatically updates the super catalog\n\
 \t--no-super-update: do not update the SGML super catalog\n\
-\t-v --verbose : provide debug informations\n");
+\t-v --verbose : provide debug information\n");
 }
 int main(int argc, char **argv) {
     int i;
diff --git a/xmllint.c b/xmllint.c
index 735d951d..4469bf0a 100644
--- a/xmllint.c
+++ b/xmllint.c
@@ -528,6 +528,12 @@ static void
 xmlHTMLEncodeSend(void) {
     char *result;
 
+    /*
+     * xmlEncodeEntitiesReentrant assumes valid UTF-8, but the buffer might
+     * end with a truncated UTF-8 sequence. This is a hack to at least avoid
+     * an out-of-bounds read.
+     */
+    memset(&buffer[sizeof(buffer)-4], 0, 4);
     result = (char *) xmlEncodeEntitiesReentrant(NULL, BAD_CAST buffer);
     if (result) {
 	xmlGenericError(xmlGenericErrorContext, "%s", result);
@@ -540,7 +546,7 @@ xmlHTMLEncodeSend(void) {
  * xmlHTMLPrintFileInfo:
  * @input:  an xmlParserInputPtr input
  *
- * Displays the associated file and line informations for the current input
+ * Displays the associated file and line information for the current input
  */
 
 static void
@@ -2182,13 +2188,17 @@ static void parseAndPrintFile(char *filename, xmlParserCtxtPtr rectxt) {
     else if ((html) && (push)) {
         FILE *f;
 
+        if ((filename[0] == '-') && (filename[1] == 0)) {
+            f = stdin;
+        } else {
 #if defined(_WIN32) || defined (__DJGPP__) && !defined (__CYGWIN__)
-	f = fopen(filename, "rb");
+	    f = fopen(filename, "rb");
 #elif defined(__OS400__)
-	f = fopen(filename, "rb");
+	    f = fopen(filename, "rb");
 #else
-	f = fopen(filename, "r");
+	    f = fopen(filename, "r");
 #endif
+        }
         if (f != NULL) {
             int res;
             char chars[4096];
@@ -2277,7 +2287,7 @@ static void parseAndPrintFile(char *filename, xmlParserCtxtPtr rectxt) {
 		    doc = ctxt->myDoc;
 		    ret = ctxt->wellFormed;
 		    xmlFreeParserCtxt(ctxt);
-		    if (!ret) {
+		    if ((!ret) && (!recovery)) {
 			xmlFreeDoc(doc);
 			doc = NULL;
 		    }
diff --git a/xmlmemory.c b/xmlmemory.c
index 6f16c4b3..c51f49ae 100644
--- a/xmlmemory.c
+++ b/xmlmemory.c
@@ -75,7 +75,7 @@ void xmlMallocBreakpoint(void);
 #endif
 
 /*
- * Each of the blocks allocated begin with a header containing informations
+ * Each of the blocks allocated begin with a header containing information
  */
 
 #define MEMTAG 0x5aa5
diff --git a/xmlreader.c b/xmlreader.c
index f3891e43..72e40b03 100644
--- a/xmlreader.c
+++ b/xmlreader.c
@@ -48,6 +48,13 @@
 
 #define MAX_ERR_MSG_SIZE 64000
 
+#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
+/* Keeping free objects can hide memory errors. */
+#define MAX_FREE_NODES 1
+#else
+#define MAX_FREE_NODES 100
+#endif
+
 /*
  * The following VA_COPY was coded following an example in
  * the Samba project.  It may not be sufficient for some
@@ -278,6 +285,59 @@ xmlTextReaderRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {
     return(0);
 }
 
+/**
+ * xmlTextReaderWalkRemoveRef:
+ * @data:  Contents of current link
+ * @user:  Value supplied by the user
+ *
+ * Returns 0 to abort the walk or 1 to continue
+ */
+static int
+xmlTextReaderWalkRemoveRef(const void *data, void *user)
+{
+    xmlRefPtr ref = (xmlRefPtr)data;
+    xmlAttrPtr attr = (xmlAttrPtr)user;
+
+    if (ref->attr == attr) { /* Matched: remove and terminate walk */
+        ref->name = xmlStrdup(attr->name);
+        ref->attr = NULL;
+        return 0;
+    }
+    return 1;
+}
+
+/**
+ * xmlTextReaderRemoveRef:
+ * @doc:  the document
+ * @attr:  the attribute
+ *
+ * Remove the given attribute from the Ref table maintained internally.
+ *
+ * Returns -1 if the lookup failed and 0 otherwise
+ */
+static int
+xmlTextReaderRemoveRef(xmlDocPtr doc, xmlAttrPtr attr) {
+    xmlListPtr ref_list;
+    xmlRefTablePtr table;
+    xmlChar *ID;
+
+    if (doc == NULL) return(-1);
+    if (attr == NULL) return(-1);
+    table = (xmlRefTablePtr) doc->refs;
+    if (table == NULL)
+        return(-1);
+
+    ID = xmlNodeListGetString(doc, attr->children, 1);
+    if (ID == NULL)
+        return(-1);
+    ref_list = xmlHashLookup(table, ID);
+    xmlFree(ID);
+    if(ref_list == NULL)
+        return (-1);
+    xmlListWalk(ref_list, xmlTextReaderWalkRemoveRef, attr);
+    return(0);
+}
+
 /**
  * xmlTextReaderFreeProp:
  * @reader:  the xmlTextReaderPtr used
@@ -299,18 +359,20 @@ xmlTextReaderFreeProp(xmlTextReaderPtr reader, xmlAttrPtr cur) {
 	xmlDeregisterNodeDefaultValue((xmlNodePtr) cur);
 
     /* Check for ID removal -> leading to invalid references ! */
-    if ((cur->parent != NULL) && (cur->parent->doc != NULL) &&
-	((cur->parent->doc->intSubset != NULL) ||
-	 (cur->parent->doc->extSubset != NULL))) {
+    if ((cur->parent != NULL) && (cur->parent->doc != NULL)) {
         if (xmlIsID(cur->parent->doc, cur->parent, cur))
 	    xmlTextReaderRemoveID(cur->parent->doc, cur);
+	if (((cur->parent->doc->intSubset != NULL) ||
+	     (cur->parent->doc->extSubset != NULL)) &&
+            (xmlIsRef(cur->parent->doc, cur->parent, cur)))
+            xmlTextReaderRemoveRef(cur->parent->doc, cur);
     }
     if (cur->children != NULL)
         xmlTextReaderFreeNodeList(reader, cur->children);
 
     DICT_FREE(cur->name);
     if ((reader != NULL) && (reader->ctxt != NULL) &&
-        (reader->ctxt->freeAttrsNr < 100)) {
+        (reader->ctxt->freeAttrsNr < MAX_FREE_NODES)) {
         cur->next = reader->ctxt->freeAttrs;
 	reader->ctxt->freeAttrs = cur;
 	reader->ctxt->freeAttrsNr++;
@@ -411,7 +473,7 @@ xmlTextReaderFreeNodeList(xmlTextReaderPtr reader, xmlNodePtr cur) {
 	    if (((cur->type == XML_ELEMENT_NODE) ||
 		 (cur->type == XML_TEXT_NODE)) &&
 	        (reader != NULL) && (reader->ctxt != NULL) &&
-		(reader->ctxt->freeElemsNr < 100)) {
+		(reader->ctxt->freeElemsNr < MAX_FREE_NODES)) {
 	        cur->next = reader->ctxt->freeElems;
 		reader->ctxt->freeElems = cur;
 		reader->ctxt->freeElemsNr++;
@@ -499,7 +561,7 @@ xmlTextReaderFreeNode(xmlTextReaderPtr reader, xmlNodePtr cur) {
     if (((cur->type == XML_ELEMENT_NODE) ||
 	 (cur->type == XML_TEXT_NODE)) &&
 	(reader != NULL) && (reader->ctxt != NULL) &&
-	(reader->ctxt->freeElemsNr < 100)) {
+	(reader->ctxt->freeElemsNr < MAX_FREE_NODES)) {
 	cur->next = reader->ctxt->freeElems;
 	reader->ctxt->freeElems = cur;
 	reader->ctxt->freeElemsNr++;
@@ -1106,20 +1168,9 @@ static void
 xmlTextReaderValidateEntity(xmlTextReaderPtr reader) {
     xmlNodePtr oldnode = reader->node;
     xmlNodePtr node = reader->node;
-    xmlParserCtxtPtr ctxt = reader->ctxt;
 
     do {
 	if (node->type == XML_ENTITY_REF_NODE) {
-	    /*
-	     * Case where the underlying tree is not available, lookup the entity
-	     * and walk it.
-	     */
-	    if ((node->children == NULL) && (ctxt->sax != NULL) &&
-		(ctxt->sax->getEntity != NULL)) {
-		node->children = (xmlNodePtr)
-		    ctxt->sax->getEntity(ctxt, node->name);
-	    }
-
 	    if ((node->children != NULL) &&
 		(node->children->type == XML_ENTITY_DECL) &&
 		(node->children->children != NULL)) {
@@ -1447,6 +1498,8 @@ get_next_node:
             (reader->node->prev->type != XML_DTD_NODE)) {
 	    xmlNodePtr tmp = reader->node->prev;
 	    if ((tmp->extra & NODE_IS_PRESERVED) == 0) {
+                if (oldnode == tmp)
+                    oldnode = NULL;
 		xmlUnlinkNode(tmp);
 		xmlTextReaderFreeNode(reader, tmp);
 	    }
@@ -1532,7 +1585,8 @@ node_found:
     /*
      * Handle XInclude if asked for
      */
-    if ((reader->xinclude) && (reader->node != NULL) &&
+    if ((reader->xinclude) && (reader->in_xinclude == 0) &&
+        (reader->node != NULL) &&
 	(reader->node->type == XML_ELEMENT_NODE) &&
 	(reader->node->ns != NULL) &&
 	((xmlStrEqual(reader->node->ns->href, XINCLUDE_NS)) ||
@@ -1564,16 +1618,6 @@ node_found:
     if ((reader->node != NULL) &&
 	(reader->node->type == XML_ENTITY_REF_NODE) &&
 	(reader->ctxt != NULL) && (reader->ctxt->replaceEntities == 1)) {
-	/*
-	 * Case where the underlying tree is not available, lookup the entity
-	 * and walk it.
-	 */
-	if ((reader->node->children == NULL) && (reader->ctxt->sax != NULL) &&
-	    (reader->ctxt->sax->getEntity != NULL)) {
-	    reader->node->children = (xmlNodePtr)
-		reader->ctxt->sax->getEntity(reader->ctxt, reader->node->name);
-	}
-
 	if ((reader->node->children != NULL) &&
 	    (reader->node->children->type == XML_ENTITY_DECL) &&
 	    (reader->node->children->children != NULL)) {
@@ -2281,14 +2325,18 @@ xmlFreeTextReader(xmlTextReaderPtr reader) {
     if (reader->ctxt != NULL) {
         if (reader->dict == reader->ctxt->dict)
 	    reader->dict = NULL;
+#ifdef LIBXML_VALID_ENABLED
 	if ((reader->ctxt->vctxt.vstateTab != NULL) &&
 	    (reader->ctxt->vctxt.vstateMax > 0)){
+#ifdef LIBXML_REGEXP_ENABLED
             while (reader->ctxt->vctxt.vstateNr > 0)
                 xmlValidatePopElement(&reader->ctxt->vctxt, NULL, NULL, NULL);
+#endif /* LIBXML_REGEXP_ENABLED */
 	    xmlFree(reader->ctxt->vctxt.vstateTab);
 	    reader->ctxt->vctxt.vstateTab = NULL;
 	    reader->ctxt->vctxt.vstateMax = 0;
 	}
+#endif /* LIBXML_VALID_ENABLED */
 	if (reader->ctxt->myDoc != NULL) {
 	    if (reader->preserve == 0)
 		xmlTextReaderFreeDoc(reader, reader->ctxt->myDoc);
@@ -2971,7 +3019,7 @@ xmlTextReaderConstEncoding(xmlTextReaderPtr reader) {
 
 /************************************************************************
  *									*
- *			Acces API to the current node			*
+ *			Access API to the current node			*
  *									*
  ************************************************************************/
 /**
@@ -3786,7 +3834,7 @@ xmlTextReaderConstString(xmlTextReaderPtr reader, const xmlChar *str) {
  *
  * The value indicating whether to normalize white space and attribute values.
  * Since attribute value and end of line normalizations are a MUST in the XML
- * specification only the value true is accepted. The broken bahaviour of
+ * specification only the value true is accepted. The broken behaviour of
  * accepting out of range character entities like &#0; is of course not
  * supported either.
  *
@@ -3848,16 +3896,20 @@ xmlTextReaderSetParserProp(xmlTextReaderPtr reader, int prop, int value) {
 	    return(0);
         case XML_PARSER_VALIDATE:
 	    if (value != 0) {
+                ctxt->options |= XML_PARSE_DTDVALID;
 		ctxt->validate = 1;
 		reader->validate = XML_TEXTREADER_VALIDATE_DTD;
 	    } else {
+                ctxt->options &= ~XML_PARSE_DTDVALID;
 		ctxt->validate = 0;
 	    }
 	    return(0);
         case XML_PARSER_SUBST_ENTITIES:
 	    if (value != 0) {
+                ctxt->options |= XML_PARSE_NOENT;
 		ctxt->replaceEntities = 1;
 	    } else {
+                ctxt->options &= ~XML_PARSE_NOENT;
 		ctxt->replaceEntities = 0;
 	    }
 	    return(0);
diff --git a/xmlregexp.c b/xmlregexp.c
index c119ff1f..40dabb20 100644
--- a/xmlregexp.c
+++ b/xmlregexp.c
@@ -26,6 +26,9 @@
 #ifdef HAVE_LIMITS_H
 #include <limits.h>
 #endif
+#ifdef HAVE_STDINT_H
+#include <stdint.h>
+#endif
 
 #include <libxml/tree.h>
 #include <libxml/parserInternals.h>
@@ -36,6 +39,9 @@
 #ifndef INT_MAX
 #define INT_MAX 123456789 /* easy to flag and big enough for our needs */
 #endif
+#ifndef SIZE_MAX
+#define SIZE_MAX ((size_t) -1)
+#endif
 
 /* #define DEBUG_REGEXP_GRAPH */
 /* #define DEBUG_REGEXP_EXEC */
@@ -267,6 +273,8 @@ struct _xmlAutomata {
     int determinist;
     int negs;
     int flags;
+
+    int depth;
 };
 
 struct _xmlRegexp {
@@ -418,6 +426,32 @@ xmlRegexpErrCompile(xmlRegParserCtxtPtr ctxt, const char *extra)
  ************************************************************************/
 
 static int xmlFAComputesDeterminism(xmlRegParserCtxtPtr ctxt);
+
+/**
+ * xmlRegCalloc2:
+ * @dim1:  size of first dimension
+ * @dim2:  size of second dimension
+ * @elemSize:  size of element
+ *
+ * Allocate a two-dimensional array and set all elements to zero.
+ *
+ * Returns the new array or NULL in case of error.
+ */
+static void*
+xmlRegCalloc2(size_t dim1, size_t dim2, size_t elemSize) {
+    size_t totalSize;
+    void *ret;
+
+    /* Check for overflow */
+    if (dim1 > SIZE_MAX / dim2 / elemSize)
+        return (NULL);
+    totalSize = dim1 * dim2 * elemSize;
+    ret = xmlMalloc(totalSize);
+    if (ret != NULL)
+        memset(ret, 0, totalSize);
+    return (ret);
+}
+
 /**
  * xmlRegEpxFromParse:
  * @ctxt:  the parser context used to build it
@@ -540,8 +574,8 @@ xmlRegEpxFromParse(xmlRegParserCtxtPtr ctxt) {
 #ifdef DEBUG_COMPACTION
 	printf("Final: %d atoms\n", nbatoms);
 #endif
-	transitions = (int *) xmlMalloc((nbstates + 1) *
-	                                (nbatoms + 1) * sizeof(int));
+	transitions = (int *) xmlRegCalloc2(nbstates + 1, nbatoms + 1,
+                                            sizeof(int));
 	if (transitions == NULL) {
 	    xmlFree(stateRemap);
 	    xmlFree(stringRemap);
@@ -551,7 +585,6 @@ xmlRegEpxFromParse(xmlRegParserCtxtPtr ctxt) {
 	    xmlFree(ret);
 	    return(NULL);
 	}
-	memset(transitions, 0, (nbstates + 1) * (nbatoms + 1) * sizeof(int));
 
 	/*
 	 * Allocate the transition table. The first entry for each
@@ -577,12 +610,9 @@ xmlRegEpxFromParse(xmlRegParserCtxtPtr ctxt) {
 		    continue;
                 atomno = stringRemap[trans->atom->no];
 		if ((trans->atom->data != NULL) && (transdata == NULL)) {
-		    transdata = (void **) xmlMalloc(nbstates * nbatoms *
-			                            sizeof(void *));
-		    if (transdata != NULL)
-			memset(transdata, 0,
-			       nbstates * nbatoms * sizeof(void *));
-		    else {
+		    transdata = (void **) xmlRegCalloc2(nbstates, nbatoms,
+			                                sizeof(void *));
+		    if (transdata == NULL) {
 			xmlRegexpErrMemory(ctxt, "compiling regexp");
 			break;
 		    }
@@ -2628,7 +2658,6 @@ xmlFARecurseDeterminism(xmlRegParserCtxtPtr ctxt, xmlRegStatePtr state,
 	    state->markd = XML_REGEXP_MARK_VISITED;
 	    res = xmlFARecurseDeterminism(ctxt, ctxt->states[t1->to],
 		                           to, atom);
-	    state->markd = 0;
 	    if (res == 0) {
 	        ret = 0;
 		/* t1->nd = 1; */
@@ -2646,6 +2675,30 @@ xmlFARecurseDeterminism(xmlRegParserCtxtPtr ctxt, xmlRegStatePtr state,
     return(ret);
 }
 
+/**
+ * xmlFAFinishRecurseDeterminism:
+ * @ctxt:  a regexp parser context
+ *
+ * Reset flags after checking determinism.
+ */
+static void
+xmlFAFinishRecurseDeterminism(xmlRegParserCtxtPtr ctxt, xmlRegStatePtr state) {
+    int transnr, nbTrans;
+
+    if (state == NULL)
+	return;
+    if (state->markd != XML_REGEXP_MARK_VISITED)
+	return;
+    state->markd = 0;
+
+    nbTrans = state->nbTrans;
+    for (transnr = 0; transnr < nbTrans; transnr++) {
+	xmlRegTransPtr t1 = &state->trans[transnr];
+	if ((t1->atom == NULL) && (t1->to >= 0))
+	    xmlFAFinishRecurseDeterminism(ctxt, ctxt->states[t1->to]);
+    }
+}
+
 /**
  * xmlFAComputesDeterminism:
  * @ctxt:  a regexp parser context
@@ -2759,6 +2812,7 @@ xmlFAComputesDeterminism(xmlRegParserCtxtPtr ctxt) {
 		     */
 		    ret = xmlFARecurseDeterminism(ctxt, ctxt->states[t1->to],
 						   t2->to, t2->atom);
+                    xmlFAFinishRecurseDeterminism(ctxt, ctxt->states[t1->to]);
 		    /* don't shortcut the computation so all non deterministic
 		       transition get marked down
 		    if (ret == 0)
@@ -4221,7 +4275,7 @@ xmlRegExecPushString2(xmlRegExecCtxtPtr exec, const xmlChar *value,
  * @values: pointer to the array of acceptable values
  * @terminal: return value if this was a terminal state
  *
- * Extract informations from the regexp execution, internal routine to
+ * Extract information from the regexp execution, internal routine to
  * implement xmlRegExecNextValues() and xmlRegExecErrInfo()
  *
  * Returns: 0 in case of success or -1 in case of error.
@@ -4380,7 +4434,7 @@ xmlRegExecGetValues(xmlRegExecCtxtPtr exec, int err,
  * @values: pointer to the array of acceptable values
  * @terminal: return value if this was a terminal state
  *
- * Extract informations from the regexp execution,
+ * Extract information from the regexp execution,
  * the parameter @values must point to an array of @nbval string pointers
  * on return nbval will contain the number of possible strings in that
  * state and the @values array will be updated with them. The string values
@@ -4404,7 +4458,7 @@ xmlRegExecNextValues(xmlRegExecCtxtPtr exec, int *nbval, int *nbneg,
  * @values: pointer to the array of acceptable values
  * @terminal: return value if this was a terminal state
  *
- * Extract error informations from the regexp execution, the parameter
+ * Extract error information from the regexp execution, the parameter
  * @string will be updated with the value pushed and not accepted,
  * the parameter @values must point to an array of @nbval string pointers
  * on return nbval will contain the number of possible strings in that
@@ -5101,7 +5155,7 @@ xmlFAParsePosCharGroup(xmlRegParserCtxtPtr ctxt) {
 	} else {
 	    xmlFAParseCharRange(ctxt);
 	}
-    } while ((CUR != ']') && (CUR != '^') && (CUR != '-') &&
+    } while ((CUR != ']') && (CUR != '-') &&
              (CUR != 0) && (ctxt->error == 0));
 }
 
@@ -5116,34 +5170,31 @@ xmlFAParsePosCharGroup(xmlRegParserCtxtPtr ctxt) {
  */
 static void
 xmlFAParseCharGroup(xmlRegParserCtxtPtr ctxt) {
-    int n = ctxt->neg;
-    while ((CUR != ']') && (ctxt->error == 0)) {
-	if (CUR == '^') {
-	    int neg = ctxt->neg;
+    int neg = ctxt->neg;
 
-	    NEXT;
-	    ctxt->neg = !ctxt->neg;
-	    xmlFAParsePosCharGroup(ctxt);
-	    ctxt->neg = neg;
-	} else if ((CUR == '-') && (NXT(1) == '[')) {
-	    int neg = ctxt->neg;
-	    ctxt->neg = 2;
+    if (CUR == '^') {
+	NEXT;
+	ctxt->neg = !ctxt->neg;
+	xmlFAParsePosCharGroup(ctxt);
+	ctxt->neg = neg;
+    }
+    while ((CUR != ']') && (ctxt->error == 0)) {
+	if ((CUR == '-') && (NXT(1) == '[')) {
 	    NEXT;	/* eat the '-' */
 	    NEXT;	/* eat the '[' */
+	    ctxt->neg = 2;
 	    xmlFAParseCharGroup(ctxt);
+	    ctxt->neg = neg;
 	    if (CUR == ']') {
 		NEXT;
 	    } else {
 		ERROR("charClassExpr: ']' expected");
-		break;
 	    }
-	    ctxt->neg = neg;
 	    break;
-	} else if (CUR != ']') {
+	} else {
 	    xmlFAParsePosCharGroup(ctxt);
 	}
     }
-    ctxt->neg = n;
 }
 
 /**
@@ -5183,13 +5234,24 @@ static int
 xmlFAParseQuantExact(xmlRegParserCtxtPtr ctxt) {
     int ret = 0;
     int ok = 0;
+    int overflow = 0;
 
     while ((CUR >= '0') && (CUR <= '9')) {
-	ret = ret * 10 + (CUR - '0');
+        if (ret > INT_MAX / 10) {
+            overflow = 1;
+        } else {
+            int digit = CUR - '0';
+
+            ret *= 10;
+            if (ret > INT_MAX - digit)
+                overflow = 1;
+            else
+                ret += digit;
+        }
 	ok = 1;
 	NEXT;
     }
-    if (ok != 1) {
+    if ((ok != 1) || (overflow == 1)) {
 	return(-1);
     }
     return(ret);
@@ -5229,6 +5291,9 @@ xmlFAParseQuantifier(xmlRegParserCtxtPtr ctxt) {
 	cur = xmlFAParseQuantExact(ctxt);
 	if (cur >= 0)
 	    min = cur;
+        else {
+            ERROR("Improper quantifier");
+        }
 	if (CUR == ',') {
 	    NEXT;
 	    if (CUR == '}')
@@ -5288,6 +5353,10 @@ xmlFAParseAtom(xmlRegParserCtxtPtr ctxt) {
 	xmlRegStatePtr start, oldend, start0;
 
 	NEXT;
+        if (ctxt->depth >= 50) {
+	    ERROR("xmlFAParseAtom: maximum nesting depth exceeded");
+            return(-1);
+        }
 	/*
 	 * this extra Epsilon transition is needed if we count with 0 allowed
 	 * unfortunately this can't be known at that point
@@ -5299,7 +5368,9 @@ xmlFAParseAtom(xmlRegParserCtxtPtr ctxt) {
 	oldend = ctxt->end;
 	ctxt->end = NULL;
 	ctxt->atom = NULL;
+        ctxt->depth++;
 	xmlFAParseRegExp(ctxt, 0);
+        ctxt->depth--;
 	if (CUR == ')') {
 	    NEXT;
 	} else {
@@ -6055,7 +6126,7 @@ xmlAutomataNewOnceTrans2(xmlAutomataPtr am, xmlAutomataStatePtr from,
 	return(NULL);
     if (min < 1)
 	return(NULL);
-    if ((max < min) || (max < 1))
+    if (max < min)
 	return(NULL);
     atom = xmlRegNewAtom(am, XML_REGEXP_STRING);
     if (atom == NULL)
@@ -6134,7 +6205,7 @@ xmlAutomataNewOnceTrans(xmlAutomataPtr am, xmlAutomataStatePtr from,
 	return(NULL);
     if (min < 1)
 	return(NULL);
-    if ((max < min) || (max < 1))
+    if (max < min)
 	return(NULL);
     atom = xmlRegNewAtom(am, XML_REGEXP_STRING);
     if (atom == NULL)
diff --git a/xmlsave.c b/xmlsave.c
index fa009153..61a40459 100644
--- a/xmlsave.c
+++ b/xmlsave.c
@@ -100,7 +100,7 @@ struct _xmlSaveCtxt {
  ************************************************************************/
 /**
  * xmlSaveErrMemory:
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle an out of memory condition
  */
@@ -114,7 +114,7 @@ xmlSaveErrMemory(const char *extra)
  * xmlSaveErr:
  * @code:  the error number
  * @node:  the location of the error.
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle an out of memory condition
  */
@@ -590,7 +590,6 @@ static int xmlSaveClearEncoding(xmlSaveCtxtPtr ctxt) {
 static void
 xhtmlNodeDumpOutput(xmlSaveCtxtPtr ctxt, xmlNodePtr cur);
 #endif
-static void xmlNodeListDumpOutput(xmlSaveCtxtPtr ctxt, xmlNodePtr cur);
 static void xmlNodeDumpOutputInternal(xmlSaveCtxtPtr ctxt, xmlNodePtr cur);
 void xmlNsListDumpOutput(xmlOutputBufferPtr buf, xmlNsPtr cur);
 static int xmlDocContentDumpOutput(xmlSaveCtxtPtr ctxt, xmlDocPtr cur);
@@ -705,6 +704,7 @@ xmlNsListDumpOutput(xmlOutputBufferPtr buf, xmlNsPtr cur) {
 static void
 xmlDtdDumpOutput(xmlSaveCtxtPtr ctxt, xmlDtdPtr dtd) {
     xmlOutputBufferPtr buf;
+    xmlNodePtr cur;
     int format, level;
 
     if (dtd == NULL) return;
@@ -742,7 +742,9 @@ xmlDtdDumpOutput(xmlSaveCtxtPtr ctxt, xmlDtdPtr dtd) {
     level = ctxt->level;
     ctxt->format = 0;
     ctxt->level = -1;
-    xmlNodeListDumpOutput(ctxt, dtd->children);
+    for (cur = dtd->children; cur != NULL; cur = cur->next) {
+        xmlNodeDumpOutputInternal(ctxt, cur);
+    }
     ctxt->format = format;
     ctxt->level = level;
     xmlOutputBufferWrite(buf, 2, "]>");
@@ -776,58 +778,9 @@ xmlAttrDumpOutput(xmlSaveCtxtPtr ctxt, xmlAttrPtr cur) {
     xmlOutputBufferWrite(buf, 1, "\"");
 }
 
-/**
- * xmlAttrListDumpOutput:
- * @buf:  the XML buffer output
- * @doc:  the document
- * @cur:  the first attribute pointer
- * @encoding:  an optional encoding string
- *
- * Dump a list of XML attributes
- */
-static void
-xmlAttrListDumpOutput(xmlSaveCtxtPtr ctxt, xmlAttrPtr cur) {
-    if (cur == NULL) return;
-    while (cur != NULL) {
-        xmlAttrDumpOutput(ctxt, cur);
-	cur = cur->next;
-    }
-}
-
-
-
-/**
- * xmlNodeListDumpOutput:
- * @cur:  the first node
- *
- * Dump an XML node list, recursive behaviour, children are printed too.
- */
-static void
-xmlNodeListDumpOutput(xmlSaveCtxtPtr ctxt, xmlNodePtr cur) {
-    xmlOutputBufferPtr buf;
-
-    if (cur == NULL) return;
-    buf = ctxt->buf;
-    while (cur != NULL) {
-	if ((ctxt->format == 1) && (xmlIndentTreeOutput) &&
-	    ((cur->type == XML_ELEMENT_NODE) ||
-	     (cur->type == XML_COMMENT_NODE) ||
-	     (cur->type == XML_PI_NODE)))
-	    xmlOutputBufferWrite(buf, ctxt->indent_size *
-	                         (ctxt->level > ctxt->indent_nr ?
-				  ctxt->indent_nr : ctxt->level),
-				 ctxt->indent);
-        xmlNodeDumpOutputInternal(ctxt, cur);
-	if (ctxt->format == 1) {
-	    xmlOutputBufferWrite(buf, 1, "\n");
-	}
-	cur = cur->next;
-    }
-}
-
 #ifdef LIBXML_HTML_ENABLED
 /**
- * xmlNodeDumpOutputInternal:
+ * htmlNodeDumpOutputInternal:
  * @cur:  the current node
  *
  * Dump an HTML node, recursive behaviour, children are printed too.
@@ -893,57 +846,111 @@ htmlNodeDumpOutputInternal(xmlSaveCtxtPtr ctxt, xmlNodePtr cur) {
  */
 static void
 xmlNodeDumpOutputInternal(xmlSaveCtxtPtr ctxt, xmlNodePtr cur) {
-    int format;
-    xmlNodePtr tmp;
+    int format = ctxt->format;
+    xmlNodePtr tmp, root, unformattedNode = NULL;
+    xmlAttrPtr attr;
     xmlChar *start, *end;
     xmlOutputBufferPtr buf;
 
     if (cur == NULL) return;
     buf = ctxt->buf;
-    if (cur->type == XML_XINCLUDE_START)
-	return;
-    if (cur->type == XML_XINCLUDE_END)
-	return;
-    if ((cur->type == XML_DOCUMENT_NODE) ||
-        (cur->type == XML_HTML_DOCUMENT_NODE)) {
-	xmlDocContentDumpOutput(ctxt, (xmlDocPtr) cur);
-	return;
-    }
-#ifdef LIBXML_HTML_ENABLED
-    if (ctxt->options & XML_SAVE_XHTML) {
-        xhtmlNodeDumpOutput(ctxt, cur);
-        return;
-    }
-    if (((cur->type != XML_NAMESPACE_DECL) && (cur->doc != NULL) &&
-         (cur->doc->type == XML_HTML_DOCUMENT_NODE) &&
-         ((ctxt->options & XML_SAVE_AS_XML) == 0)) ||
-        (ctxt->options & XML_SAVE_AS_HTML)) {
-	htmlNodeDumpOutputInternal(ctxt, cur);
-	return;
-    }
-#endif
-    if (cur->type == XML_DTD_NODE) {
-        xmlDtdDumpOutput(ctxt, (xmlDtdPtr) cur);
-	return;
-    }
-    if (cur->type == XML_DOCUMENT_FRAG_NODE) {
-        xmlNodeListDumpOutput(ctxt, cur->children);
-	return;
-    }
-    if (cur->type == XML_ELEMENT_DECL) {
-        xmlBufDumpElementDecl(buf->buffer, (xmlElementPtr) cur);
-	return;
-    }
-    if (cur->type == XML_ATTRIBUTE_DECL) {
-        xmlBufDumpAttributeDecl(buf->buffer, (xmlAttributePtr) cur);
-	return;
-    }
-    if (cur->type == XML_ENTITY_DECL) {
-        xmlBufDumpEntityDecl(buf->buffer, (xmlEntityPtr) cur);
-	return;
-    }
-    if (cur->type == XML_TEXT_NODE) {
-	if (cur->content != NULL) {
+
+    root = cur;
+    while (1) {
+        switch (cur->type) {
+        case XML_DOCUMENT_NODE:
+        case XML_HTML_DOCUMENT_NODE:
+	    xmlDocContentDumpOutput(ctxt, (xmlDocPtr) cur);
+	    break;
+
+        case XML_DTD_NODE:
+            xmlDtdDumpOutput(ctxt, (xmlDtdPtr) cur);
+            break;
+
+        case XML_DOCUMENT_FRAG_NODE:
+            if (cur->children != NULL) {
+                cur = cur->children;
+                continue;
+            }
+	    break;
+
+        case XML_ELEMENT_DECL:
+            xmlBufDumpElementDecl(buf->buffer, (xmlElementPtr) cur);
+            break;
+
+        case XML_ATTRIBUTE_DECL:
+            xmlBufDumpAttributeDecl(buf->buffer, (xmlAttributePtr) cur);
+            break;
+
+        case XML_ENTITY_DECL:
+            xmlBufDumpEntityDecl(buf->buffer, (xmlEntityPtr) cur);
+            break;
+
+        case XML_ELEMENT_NODE:
+	    if ((cur != root) && (ctxt->format == 1) && (xmlIndentTreeOutput))
+		xmlOutputBufferWrite(buf, ctxt->indent_size *
+				     (ctxt->level > ctxt->indent_nr ?
+				      ctxt->indent_nr : ctxt->level),
+				     ctxt->indent);
+
+            xmlOutputBufferWrite(buf, 1, "<");
+            if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {
+                xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);
+                xmlOutputBufferWrite(buf, 1, ":");
+            }
+            xmlOutputBufferWriteString(buf, (const char *)cur->name);
+            if (cur->nsDef)
+                xmlNsListDumpOutputCtxt(ctxt, cur->nsDef);
+            for (attr = cur->properties; attr != NULL; attr = attr->next)
+                xmlAttrDumpOutput(ctxt, attr);
+
+            if (cur->children == NULL) {
+                if ((ctxt->options & XML_SAVE_NO_EMPTY) == 0) {
+                    if (ctxt->format == 2)
+                        xmlOutputBufferWriteWSNonSig(ctxt, 0);
+                    xmlOutputBufferWrite(buf, 2, "/>");
+                } else {
+                    if (ctxt->format == 2)
+                        xmlOutputBufferWriteWSNonSig(ctxt, 1);
+                    xmlOutputBufferWrite(buf, 3, "></");
+                    if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {
+                        xmlOutputBufferWriteString(buf,
+                                (const char *)cur->ns->prefix);
+                        xmlOutputBufferWrite(buf, 1, ":");
+                    }
+                    xmlOutputBufferWriteString(buf, (const char *)cur->name);
+                    if (ctxt->format == 2)
+                        xmlOutputBufferWriteWSNonSig(ctxt, 0);
+                    xmlOutputBufferWrite(buf, 1, ">");
+                }
+            } else {
+                if (ctxt->format == 1) {
+                    tmp = cur->children;
+                    while (tmp != NULL) {
+                        if ((tmp->type == XML_TEXT_NODE) ||
+                            (tmp->type == XML_CDATA_SECTION_NODE) ||
+                            (tmp->type == XML_ENTITY_REF_NODE)) {
+                            ctxt->format = 0;
+                            unformattedNode = cur;
+                            break;
+                        }
+                        tmp = tmp->next;
+                    }
+                }
+                if (ctxt->format == 2)
+                    xmlOutputBufferWriteWSNonSig(ctxt, 1);
+                xmlOutputBufferWrite(buf, 1, ">");
+                if (ctxt->format == 1) xmlOutputBufferWrite(buf, 1, "\n");
+                if (ctxt->level >= 0) ctxt->level++;
+                cur = cur->children;
+                continue;
+            }
+
+            break;
+
+        case XML_TEXT_NODE:
+	    if (cur->content == NULL)
+                break;
 	    if (cur->name != xmlStringTextNoenc) {
                 xmlOutputBufferWriteEscape(buf, cur->content, ctxt->escape);
 	    } else {
@@ -952,139 +959,140 @@ xmlNodeDumpOutputInternal(xmlSaveCtxtPtr ctxt, xmlNodePtr cur) {
 		 */
 		xmlOutputBufferWriteString(buf, (const char *) cur->content);
 	    }
-	}
+	    break;
 
-	return;
-    }
-    if (cur->type == XML_PI_NODE) {
-	if (cur->content != NULL) {
-	    xmlOutputBufferWrite(buf, 2, "<?");
-	    xmlOutputBufferWriteString(buf, (const char *)cur->name);
-	    if (cur->content != NULL) {
-	        if (ctxt->format == 2)
-	            xmlOutputBufferWriteWSNonSig(ctxt, 0);
-	        else
-	            xmlOutputBufferWrite(buf, 1, " ");
-		xmlOutputBufferWriteString(buf, (const char *)cur->content);
-	    }
-	    xmlOutputBufferWrite(buf, 2, "?>");
-	} else {
-	    xmlOutputBufferWrite(buf, 2, "<?");
-	    xmlOutputBufferWriteString(buf, (const char *)cur->name);
-	    if (ctxt->format == 2)
-	        xmlOutputBufferWriteWSNonSig(ctxt, 0);
-	    xmlOutputBufferWrite(buf, 2, "?>");
-	}
-	return;
-    }
-    if (cur->type == XML_COMMENT_NODE) {
-	if (cur->content != NULL) {
-	    xmlOutputBufferWrite(buf, 4, "<!--");
-	    xmlOutputBufferWriteString(buf, (const char *)cur->content);
-	    xmlOutputBufferWrite(buf, 3, "-->");
-	}
-	return;
-    }
-    if (cur->type == XML_ENTITY_REF_NODE) {
-        xmlOutputBufferWrite(buf, 1, "&");
-	xmlOutputBufferWriteString(buf, (const char *)cur->name);
-        xmlOutputBufferWrite(buf, 1, ";");
-	return;
-    }
-    if (cur->type == XML_CDATA_SECTION_NODE) {
-	if (cur->content == NULL || *cur->content == '\0') {
-	    xmlOutputBufferWrite(buf, 12, "<![CDATA[]]>");
-	} else {
-	    start = end = cur->content;
-	    while (*end != '\0') {
-		if ((*end == ']') && (*(end + 1) == ']') &&
-		    (*(end + 2) == '>')) {
-		    end = end + 2;
-		    xmlOutputBufferWrite(buf, 9, "<![CDATA[");
-		    xmlOutputBufferWrite(buf, end - start, (const char *)start);
-		    xmlOutputBufferWrite(buf, 3, "]]>");
-		    start = end;
-		}
-		end++;
-	    }
-	    if (start != end) {
-		xmlOutputBufferWrite(buf, 9, "<![CDATA[");
-		xmlOutputBufferWriteString(buf, (const char *)start);
-		xmlOutputBufferWrite(buf, 3, "]]>");
-	    }
-	}
-	return;
-    }
-    if (cur->type == XML_ATTRIBUTE_NODE) {
-	xmlAttrDumpOutput(ctxt, (xmlAttrPtr) cur);
-	return;
-    }
-    if (cur->type == XML_NAMESPACE_DECL) {
-	xmlNsDumpOutputCtxt(ctxt, (xmlNsPtr) cur);
-	return;
-    }
+        case XML_PI_NODE:
+	    if ((cur != root) && (ctxt->format == 1) && (xmlIndentTreeOutput))
+		xmlOutputBufferWrite(buf, ctxt->indent_size *
+				     (ctxt->level > ctxt->indent_nr ?
+				      ctxt->indent_nr : ctxt->level),
+				     ctxt->indent);
+
+            if (cur->content != NULL) {
+                xmlOutputBufferWrite(buf, 2, "<?");
+                xmlOutputBufferWriteString(buf, (const char *)cur->name);
+                if (cur->content != NULL) {
+                    if (ctxt->format == 2)
+                        xmlOutputBufferWriteWSNonSig(ctxt, 0);
+                    else
+                        xmlOutputBufferWrite(buf, 1, " ");
+                    xmlOutputBufferWriteString(buf,
+                            (const char *)cur->content);
+                }
+                xmlOutputBufferWrite(buf, 2, "?>");
+            } else {
+                xmlOutputBufferWrite(buf, 2, "<?");
+                xmlOutputBufferWriteString(buf, (const char *)cur->name);
+                if (ctxt->format == 2)
+                    xmlOutputBufferWriteWSNonSig(ctxt, 0);
+                xmlOutputBufferWrite(buf, 2, "?>");
+            }
+            break;
+
+        case XML_COMMENT_NODE:
+	    if ((cur != root) && (ctxt->format == 1) && (xmlIndentTreeOutput))
+		xmlOutputBufferWrite(buf, ctxt->indent_size *
+				     (ctxt->level > ctxt->indent_nr ?
+				      ctxt->indent_nr : ctxt->level),
+				     ctxt->indent);
+
+            if (cur->content != NULL) {
+                xmlOutputBufferWrite(buf, 4, "<!--");
+                xmlOutputBufferWriteString(buf, (const char *)cur->content);
+                xmlOutputBufferWrite(buf, 3, "-->");
+            }
+            break;
+
+        case XML_ENTITY_REF_NODE:
+            xmlOutputBufferWrite(buf, 1, "&");
+            xmlOutputBufferWriteString(buf, (const char *)cur->name);
+            xmlOutputBufferWrite(buf, 1, ";");
+            break;
+
+        case XML_CDATA_SECTION_NODE:
+            if (cur->content == NULL || *cur->content == '\0') {
+                xmlOutputBufferWrite(buf, 12, "<![CDATA[]]>");
+            } else {
+                start = end = cur->content;
+                while (*end != '\0') {
+                    if ((*end == ']') && (*(end + 1) == ']') &&
+                        (*(end + 2) == '>')) {
+                        end = end + 2;
+                        xmlOutputBufferWrite(buf, 9, "<![CDATA[");
+                        xmlOutputBufferWrite(buf, end - start,
+                                (const char *)start);
+                        xmlOutputBufferWrite(buf, 3, "]]>");
+                        start = end;
+                    }
+                    end++;
+                }
+                if (start != end) {
+                    xmlOutputBufferWrite(buf, 9, "<![CDATA[");
+                    xmlOutputBufferWriteString(buf, (const char *)start);
+                    xmlOutputBufferWrite(buf, 3, "]]>");
+                }
+            }
+            break;
 
-    format = ctxt->format;
-    if (format == 1) {
-	tmp = cur->children;
-	while (tmp != NULL) {
-	    if ((tmp->type == XML_TEXT_NODE) ||
-		(tmp->type == XML_CDATA_SECTION_NODE) ||
-		(tmp->type == XML_ENTITY_REF_NODE)) {
-		ctxt->format = 0;
-		break;
-	    }
-	    tmp = tmp->next;
-	}
-    }
-    xmlOutputBufferWrite(buf, 1, "<");
-    if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {
-        xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);
-	xmlOutputBufferWrite(buf, 1, ":");
-    }
+        case XML_ATTRIBUTE_NODE:
+            xmlAttrDumpOutput(ctxt, (xmlAttrPtr) cur);
+            break;
 
-    xmlOutputBufferWriteString(buf, (const char *)cur->name);
-    if (cur->nsDef)
-        xmlNsListDumpOutputCtxt(ctxt, cur->nsDef);
-    if (cur->properties != NULL)
-        xmlAttrListDumpOutput(ctxt, cur->properties);
-
-    if (((cur->type == XML_ELEMENT_NODE) || (cur->content == NULL)) &&
-	(cur->children == NULL) && ((ctxt->options & XML_SAVE_NO_EMPTY) == 0)) {
-        if (ctxt->format == 2)
-            xmlOutputBufferWriteWSNonSig(ctxt, 0);
-        xmlOutputBufferWrite(buf, 2, "/>");
-	ctxt->format = format;
-	return;
-    }
-    if (ctxt->format == 2)
-        xmlOutputBufferWriteWSNonSig(ctxt, 1);
-    xmlOutputBufferWrite(buf, 1, ">");
-    if ((cur->type != XML_ELEMENT_NODE) && (cur->content != NULL)) {
-	xmlOutputBufferWriteEscape(buf, cur->content, ctxt->escape);
-    }
-    if (cur->children != NULL) {
-	if (ctxt->format == 1) xmlOutputBufferWrite(buf, 1, "\n");
-	if (ctxt->level >= 0) ctxt->level++;
-	xmlNodeListDumpOutput(ctxt, cur->children);
-	if (ctxt->level > 0) ctxt->level--;
-	if ((xmlIndentTreeOutput) && (ctxt->format == 1))
-	    xmlOutputBufferWrite(buf, ctxt->indent_size *
-	                         (ctxt->level > ctxt->indent_nr ?
-				  ctxt->indent_nr : ctxt->level),
-				 ctxt->indent);
-    }
-    xmlOutputBufferWrite(buf, 2, "</");
-    if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {
-        xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);
-	xmlOutputBufferWrite(buf, 1, ":");
-    }
+        case XML_NAMESPACE_DECL:
+            xmlNsDumpOutputCtxt(ctxt, (xmlNsPtr) cur);
+            break;
 
-    xmlOutputBufferWriteString(buf, (const char *)cur->name);
-    if (ctxt->format == 2)
-        xmlOutputBufferWriteWSNonSig(ctxt, 0);
-    xmlOutputBufferWrite(buf, 1, ">");
-    ctxt->format = format;
+        default:
+            break;
+        }
+
+        while (1) {
+            if (cur == root)
+                return;
+            if ((ctxt->format == 1) &&
+                (cur->type != XML_XINCLUDE_START) &&
+                (cur->type != XML_XINCLUDE_END))
+                xmlOutputBufferWrite(buf, 1, "\n");
+            if (cur->next != NULL) {
+                cur = cur->next;
+                break;
+            }
+
+            /*
+             * The parent should never be NULL here but we want to handle
+             * corrupted documents gracefully.
+             */
+            if (cur->parent == NULL)
+                return;
+            cur = cur->parent;
+
+            if (cur->type == XML_ELEMENT_NODE) {
+                if (ctxt->level > 0) ctxt->level--;
+                if ((xmlIndentTreeOutput) && (ctxt->format == 1))
+                    xmlOutputBufferWrite(buf, ctxt->indent_size *
+                                         (ctxt->level > ctxt->indent_nr ?
+                                          ctxt->indent_nr : ctxt->level),
+                                         ctxt->indent);
+
+                xmlOutputBufferWrite(buf, 2, "</");
+                if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {
+                    xmlOutputBufferWriteString(buf,
+                            (const char *)cur->ns->prefix);
+                    xmlOutputBufferWrite(buf, 1, ":");
+                }
+
+                xmlOutputBufferWriteString(buf, (const char *)cur->name);
+                if (ctxt->format == 2)
+                    xmlOutputBufferWriteWSNonSig(ctxt, 0);
+                xmlOutputBufferWrite(buf, 1, ">");
+
+                if (cur == unformattedNode) {
+                    ctxt->format = format;
+                    unformattedNode = NULL;
+                }
+            }
+        }
+    }
 }
 
 /**
@@ -1224,7 +1232,9 @@ xmlDocContentDumpOutput(xmlSaveCtxtPtr ctxt, xmlDocPtr cur) {
 		else
 #endif
 		    xmlNodeDumpOutputInternal(ctxt, child);
-		xmlOutputBufferWrite(buf, 1, "\n");
+                if ((child->type != XML_XINCLUDE_START) &&
+                    (child->type != XML_XINCLUDE_END))
+                    xmlOutputBufferWrite(buf, 1, "\n");
 		child = child->next;
 	    }
 	}
@@ -1395,40 +1405,6 @@ xhtmlAttrListDumpOutput(xmlSaveCtxtPtr ctxt, xmlAttrPtr cur) {
     }
 }
 
-/**
- * xhtmlNodeListDumpOutput:
- * @buf:  the XML buffer output
- * @doc:  the XHTML document
- * @cur:  the first node
- * @level: the imbrication level for indenting
- * @format: is formatting allowed
- * @encoding:  an optional encoding string
- *
- * Dump an XML node list, recursive behaviour, children are printed too.
- * Note that @format = 1 provide node indenting only if xmlIndentTreeOutput = 1
- * or xmlKeepBlanksDefault(0) was called
- */
-static void
-xhtmlNodeListDumpOutput(xmlSaveCtxtPtr ctxt, xmlNodePtr cur) {
-    xmlOutputBufferPtr buf;
-
-    if (cur == NULL) return;
-    buf = ctxt->buf;
-    while (cur != NULL) {
-	if ((ctxt->format == 1) && (xmlIndentTreeOutput) &&
-	    (cur->type == XML_ELEMENT_NODE))
-	    xmlOutputBufferWrite(buf, ctxt->indent_size *
-	                         (ctxt->level > ctxt->indent_nr ?
-				  ctxt->indent_nr : ctxt->level),
-				 ctxt->indent);
-        xhtmlNodeDumpOutput(ctxt, cur);
-	if (ctxt->format == 1) {
-	    xmlOutputBufferWrite(buf, 1, "\n");
-	}
-	cur = cur->next;
-    }
-}
-
 /**
  * xhtmlNodeDumpOutput:
  * @buf:  the XML buffer output
@@ -1442,48 +1418,195 @@ xhtmlNodeListDumpOutput(xmlSaveCtxtPtr ctxt, xmlNodePtr cur) {
  */
 static void
 xhtmlNodeDumpOutput(xmlSaveCtxtPtr ctxt, xmlNodePtr cur) {
-    int format, addmeta = 0;
-    xmlNodePtr tmp;
+    int format = ctxt->format, addmeta;
+    xmlNodePtr tmp, root, unformattedNode = NULL;
     xmlChar *start, *end;
-    xmlOutputBufferPtr buf;
+    xmlOutputBufferPtr buf = ctxt->buf;
 
     if (cur == NULL) return;
-    if ((cur->type == XML_DOCUMENT_NODE) ||
-        (cur->type == XML_HTML_DOCUMENT_NODE)) {
-        xmlDocContentDumpOutput(ctxt, (xmlDocPtr) cur);
-	return;
-    }
-    if (cur->type == XML_XINCLUDE_START)
-	return;
-    if (cur->type == XML_XINCLUDE_END)
-	return;
-    if (cur->type == XML_NAMESPACE_DECL) {
-	xmlNsDumpOutputCtxt(ctxt, (xmlNsPtr) cur);
-	return;
-    }
-    if (cur->type == XML_DTD_NODE) {
-        xmlDtdDumpOutput(ctxt, (xmlDtdPtr) cur);
-	return;
-    }
-    if (cur->type == XML_DOCUMENT_FRAG_NODE) {
-        xhtmlNodeListDumpOutput(ctxt, cur->children);
-	return;
-    }
-    buf = ctxt->buf;
-    if (cur->type == XML_ELEMENT_DECL) {
-        xmlBufDumpElementDecl(buf->buffer, (xmlElementPtr) cur);
-	return;
-    }
-    if (cur->type == XML_ATTRIBUTE_DECL) {
-        xmlBufDumpAttributeDecl(buf->buffer, (xmlAttributePtr) cur);
-	return;
-    }
-    if (cur->type == XML_ENTITY_DECL) {
-        xmlBufDumpEntityDecl(buf->buffer, (xmlEntityPtr) cur);
-	return;
-    }
-    if (cur->type == XML_TEXT_NODE) {
-	if (cur->content != NULL) {
+
+    root = cur;
+    while (1) {
+        switch (cur->type) {
+        case XML_DOCUMENT_NODE:
+        case XML_HTML_DOCUMENT_NODE:
+            xmlDocContentDumpOutput(ctxt, (xmlDocPtr) cur);
+	    break;
+
+        case XML_NAMESPACE_DECL:
+	    xmlNsDumpOutputCtxt(ctxt, (xmlNsPtr) cur);
+	    break;
+
+        case XML_DTD_NODE:
+            xmlDtdDumpOutput(ctxt, (xmlDtdPtr) cur);
+	    break;
+
+        case XML_DOCUMENT_FRAG_NODE:
+            if (cur->children) {
+                cur = cur->children;
+                continue;
+            }
+            break;
+
+        case XML_ELEMENT_DECL:
+            xmlBufDumpElementDecl(buf->buffer, (xmlElementPtr) cur);
+	    break;
+
+        case XML_ATTRIBUTE_DECL:
+            xmlBufDumpAttributeDecl(buf->buffer, (xmlAttributePtr) cur);
+	    break;
+
+        case XML_ENTITY_DECL:
+            xmlBufDumpEntityDecl(buf->buffer, (xmlEntityPtr) cur);
+	    break;
+
+        case XML_ELEMENT_NODE:
+            addmeta = 0;
+
+	    if ((cur != root) && (ctxt->format == 1) && (xmlIndentTreeOutput))
+		xmlOutputBufferWrite(buf, ctxt->indent_size *
+				     (ctxt->level > ctxt->indent_nr ?
+				      ctxt->indent_nr : ctxt->level),
+				     ctxt->indent);
+
+            xmlOutputBufferWrite(buf, 1, "<");
+            if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {
+                xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);
+                xmlOutputBufferWrite(buf, 1, ":");
+            }
+
+            xmlOutputBufferWriteString(buf, (const char *)cur->name);
+            if (cur->nsDef)
+                xmlNsListDumpOutputCtxt(ctxt, cur->nsDef);
+            if ((xmlStrEqual(cur->name, BAD_CAST "html") &&
+                (cur->ns == NULL) && (cur->nsDef == NULL))) {
+                /*
+                 * 3.1.1. Strictly Conforming Documents A.3.1.1 3/
+                 */
+                xmlOutputBufferWriteString(buf,
+                        " xmlns=\"http://www.w3.org/1999/xhtml\"");
+            }
+            if (cur->properties != NULL)
+                xhtmlAttrListDumpOutput(ctxt, cur->properties);
+
+            if ((cur->parent != NULL) &&
+                (cur->parent->parent == (xmlNodePtr) cur->doc) &&
+                xmlStrEqual(cur->name, BAD_CAST"head") &&
+                xmlStrEqual(cur->parent->name, BAD_CAST"html")) {
+
+                tmp = cur->children;
+                while (tmp != NULL) {
+                    if (xmlStrEqual(tmp->name, BAD_CAST"meta")) {
+                        xmlChar *httpequiv;
+
+                        httpequiv = xmlGetProp(tmp, BAD_CAST"http-equiv");
+                        if (httpequiv != NULL) {
+                            if (xmlStrcasecmp(httpequiv,
+                                        BAD_CAST"Content-Type") == 0) {
+                                xmlFree(httpequiv);
+                                break;
+                            }
+                            xmlFree(httpequiv);
+                        }
+                    }
+                    tmp = tmp->next;
+                }
+                if (tmp == NULL)
+                    addmeta = 1;
+            }
+
+            if (cur->children == NULL) {
+                if (((cur->ns == NULL) || (cur->ns->prefix == NULL)) &&
+                    ((xhtmlIsEmpty(cur) == 1) && (addmeta == 0))) {
+                    /*
+                     * C.2. Empty Elements
+                     */
+                    xmlOutputBufferWrite(buf, 3, " />");
+                } else {
+                    if (addmeta == 1) {
+                        xmlOutputBufferWrite(buf, 1, ">");
+                        if (ctxt->format == 1) {
+                            xmlOutputBufferWrite(buf, 1, "\n");
+                            if (xmlIndentTreeOutput)
+                                xmlOutputBufferWrite(buf, ctxt->indent_size *
+                                    (ctxt->level + 1 > ctxt->indent_nr ?
+                                    ctxt->indent_nr : ctxt->level + 1),
+                                    ctxt->indent);
+                        }
+                        xmlOutputBufferWriteString(buf,
+                                "<meta http-equiv=\"Content-Type\" "
+                                "content=\"text/html; charset=");
+                        if (ctxt->encoding) {
+                            xmlOutputBufferWriteString(buf,
+                                    (const char *)ctxt->encoding);
+                        } else {
+                            xmlOutputBufferWrite(buf, 5, "UTF-8");
+                        }
+                        xmlOutputBufferWrite(buf, 4, "\" />");
+                        if (ctxt->format == 1)
+                            xmlOutputBufferWrite(buf, 1, "\n");
+                    } else {
+                        xmlOutputBufferWrite(buf, 1, ">");
+                    }
+                    /*
+                     * C.3. Element Minimization and Empty Element Content
+                     */
+                    xmlOutputBufferWrite(buf, 2, "</");
+                    if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {
+                        xmlOutputBufferWriteString(buf,
+                                (const char *)cur->ns->prefix);
+                        xmlOutputBufferWrite(buf, 1, ":");
+                    }
+                    xmlOutputBufferWriteString(buf, (const char *)cur->name);
+                    xmlOutputBufferWrite(buf, 1, ">");
+                }
+            } else {
+                xmlOutputBufferWrite(buf, 1, ">");
+                if (addmeta == 1) {
+                    if (ctxt->format == 1) {
+                        xmlOutputBufferWrite(buf, 1, "\n");
+                        if (xmlIndentTreeOutput)
+                            xmlOutputBufferWrite(buf, ctxt->indent_size *
+                                (ctxt->level + 1 > ctxt->indent_nr ?
+                                ctxt->indent_nr : ctxt->level + 1),
+                                ctxt->indent);
+                    }
+                    xmlOutputBufferWriteString(buf,
+                            "<meta http-equiv=\"Content-Type\" "
+                            "content=\"text/html; charset=");
+                    if (ctxt->encoding) {
+                        xmlOutputBufferWriteString(buf,
+                                (const char *)ctxt->encoding);
+                    } else {
+                        xmlOutputBufferWrite(buf, 5, "UTF-8");
+                    }
+                    xmlOutputBufferWrite(buf, 4, "\" />");
+                }
+
+                if (ctxt->format == 1) {
+                    tmp = cur->children;
+                    while (tmp != NULL) {
+                        if ((tmp->type == XML_TEXT_NODE) ||
+                            (tmp->type == XML_ENTITY_REF_NODE)) {
+                            unformattedNode = cur;
+                            ctxt->format = 0;
+                            break;
+                        }
+                        tmp = tmp->next;
+                    }
+                }
+
+                if (ctxt->format == 1) xmlOutputBufferWrite(buf, 1, "\n");
+                if (ctxt->level >= 0) ctxt->level++;
+                cur = cur->children;
+                continue;
+            }
+
+            break;
+
+        case XML_TEXT_NODE:
+	    if (cur->content == NULL)
+                break;
 	    if ((cur->name == xmlStringText) ||
 		(cur->name != xmlStringTextNoenc)) {
                 xmlOutputBufferWriteEscape(buf, cur->content, ctxt->escape);
@@ -1493,286 +1616,115 @@ xhtmlNodeDumpOutput(xmlSaveCtxtPtr ctxt, xmlNodePtr cur) {
 		 */
 		xmlOutputBufferWriteString(buf, (const char *) cur->content);
 	    }
-	}
-
-	return;
-    }
-    if (cur->type == XML_PI_NODE) {
-	if (cur->content != NULL) {
-	    xmlOutputBufferWrite(buf, 2, "<?");
-	    xmlOutputBufferWriteString(buf, (const char *)cur->name);
-	    if (cur->content != NULL) {
-		xmlOutputBufferWrite(buf, 1, " ");
-		xmlOutputBufferWriteString(buf, (const char *)cur->content);
-	    }
-	    xmlOutputBufferWrite(buf, 2, "?>");
-	} else {
-	    xmlOutputBufferWrite(buf, 2, "<?");
-	    xmlOutputBufferWriteString(buf, (const char *)cur->name);
-	    xmlOutputBufferWrite(buf, 2, "?>");
-	}
-	return;
-    }
-    if (cur->type == XML_COMMENT_NODE) {
-	if (cur->content != NULL) {
-	    xmlOutputBufferWrite(buf, 4, "<!--");
-	    xmlOutputBufferWriteString(buf, (const char *)cur->content);
-	    xmlOutputBufferWrite(buf, 3, "-->");
-	}
-	return;
-    }
-    if (cur->type == XML_ENTITY_REF_NODE) {
-        xmlOutputBufferWrite(buf, 1, "&");
-	xmlOutputBufferWriteString(buf, (const char *)cur->name);
-        xmlOutputBufferWrite(buf, 1, ";");
-	return;
-    }
-    if (cur->type == XML_CDATA_SECTION_NODE) {
-	if (cur->content == NULL || *cur->content == '\0') {
-	    xmlOutputBufferWrite(buf, 12, "<![CDATA[]]>");
-	} else {
-	    start = end = cur->content;
-	    while (*end != '\0') {
-		if (*end == ']' && *(end + 1) == ']' && *(end + 2) == '>') {
-		    end = end + 2;
-		    xmlOutputBufferWrite(buf, 9, "<![CDATA[");
-		    xmlOutputBufferWrite(buf, end - start, (const char *)start);
-		    xmlOutputBufferWrite(buf, 3, "]]>");
-		    start = end;
-		}
-		end++;
-	    }
-	    if (start != end) {
-		xmlOutputBufferWrite(buf, 9, "<![CDATA[");
-		xmlOutputBufferWriteString(buf, (const char *)start);
-		xmlOutputBufferWrite(buf, 3, "]]>");
-	    }
-	}
-	return;
-    }
-    if (cur->type == XML_ATTRIBUTE_NODE) {
-        xmlAttrDumpOutput(ctxt, (xmlAttrPtr) cur);
-	return;
-    }
+	    break;
 
-    format = ctxt->format;
-    if (format == 1) {
-	tmp = cur->children;
-	while (tmp != NULL) {
-	    if ((tmp->type == XML_TEXT_NODE) ||
-		(tmp->type == XML_ENTITY_REF_NODE)) {
-		format = 0;
-		break;
-	    }
-	    tmp = tmp->next;
-	}
-    }
-    xmlOutputBufferWrite(buf, 1, "<");
-    if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {
-        xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);
-	xmlOutputBufferWrite(buf, 1, ":");
-    }
+        case XML_PI_NODE:
+            if (cur->content != NULL) {
+                xmlOutputBufferWrite(buf, 2, "<?");
+                xmlOutputBufferWriteString(buf, (const char *)cur->name);
+                if (cur->content != NULL) {
+                    xmlOutputBufferWrite(buf, 1, " ");
+                    xmlOutputBufferWriteString(buf,
+                            (const char *)cur->content);
+                }
+                xmlOutputBufferWrite(buf, 2, "?>");
+            } else {
+                xmlOutputBufferWrite(buf, 2, "<?");
+                xmlOutputBufferWriteString(buf, (const char *)cur->name);
+                xmlOutputBufferWrite(buf, 2, "?>");
+            }
+            break;
 
-    xmlOutputBufferWriteString(buf, (const char *)cur->name);
-    if (cur->nsDef)
-        xmlNsListDumpOutputCtxt(ctxt, cur->nsDef);
-    if ((xmlStrEqual(cur->name, BAD_CAST "html") &&
-	(cur->ns == NULL) && (cur->nsDef == NULL))) {
-	/*
-	 * 3.1.1. Strictly Conforming Documents A.3.1.1 3/
-	 */
-	xmlOutputBufferWriteString(buf,
-		" xmlns=\"http://www.w3.org/1999/xhtml\"");
-    }
-    if (cur->properties != NULL)
-        xhtmlAttrListDumpOutput(ctxt, cur->properties);
-
-    if ((cur->type == XML_ELEMENT_NODE) &&
-        (cur->parent != NULL) &&
-        (cur->parent->parent == (xmlNodePtr) cur->doc) &&
-        xmlStrEqual(cur->name, BAD_CAST"head") &&
-        xmlStrEqual(cur->parent->name, BAD_CAST"html")) {
-
-        tmp = cur->children;
-        while (tmp != NULL) {
-            if (xmlStrEqual(tmp->name, BAD_CAST"meta")) {
-                xmlChar *httpequiv;
-
-                httpequiv = xmlGetProp(tmp, BAD_CAST"http-equiv");
-                if (httpequiv != NULL) {
-                    if (xmlStrcasecmp(httpequiv, BAD_CAST"Content-Type") == 0) {
-                        xmlFree(httpequiv);
-                        break;
+        case XML_COMMENT_NODE:
+            if (cur->content != NULL) {
+                xmlOutputBufferWrite(buf, 4, "<!--");
+                xmlOutputBufferWriteString(buf, (const char *)cur->content);
+                xmlOutputBufferWrite(buf, 3, "-->");
+            }
+            break;
+
+        case XML_ENTITY_REF_NODE:
+            xmlOutputBufferWrite(buf, 1, "&");
+            xmlOutputBufferWriteString(buf, (const char *)cur->name);
+            xmlOutputBufferWrite(buf, 1, ";");
+            break;
+
+        case XML_CDATA_SECTION_NODE:
+            if (cur->content == NULL || *cur->content == '\0') {
+                xmlOutputBufferWrite(buf, 12, "<![CDATA[]]>");
+            } else {
+                start = end = cur->content;
+                while (*end != '\0') {
+                    if (*end == ']' && *(end + 1) == ']' &&
+                        *(end + 2) == '>') {
+                        end = end + 2;
+                        xmlOutputBufferWrite(buf, 9, "<![CDATA[");
+                        xmlOutputBufferWrite(buf, end - start,
+                                (const char *)start);
+                        xmlOutputBufferWrite(buf, 3, "]]>");
+                        start = end;
                     }
-                    xmlFree(httpequiv);
+                    end++;
+                }
+                if (start != end) {
+                    xmlOutputBufferWrite(buf, 9, "<![CDATA[");
+                    xmlOutputBufferWriteString(buf, (const char *)start);
+                    xmlOutputBufferWrite(buf, 3, "]]>");
                 }
             }
-            tmp = tmp->next;
+            break;
+
+        case XML_ATTRIBUTE_NODE:
+            xmlAttrDumpOutput(ctxt, (xmlAttrPtr) cur);
+	    break;
+
+        default:
+            break;
         }
-        if (tmp == NULL)
-            addmeta = 1;
-    }
 
-    if ((cur->type == XML_ELEMENT_NODE) && (cur->children == NULL)) {
-	if (((cur->ns == NULL) || (cur->ns->prefix == NULL)) &&
-	    ((xhtmlIsEmpty(cur) == 1) && (addmeta == 0))) {
-	    /*
-	     * C.2. Empty Elements
-	     */
-	    xmlOutputBufferWrite(buf, 3, " />");
-	} else {
-		if (addmeta == 1) {
-			xmlOutputBufferWrite(buf, 1, ">");
-			if (ctxt->format == 1) {
-				xmlOutputBufferWrite(buf, 1, "\n");
-				if (xmlIndentTreeOutput)
-					xmlOutputBufferWrite(buf, ctxt->indent_size *
-					(ctxt->level + 1 > ctxt->indent_nr ?
-					ctxt->indent_nr : ctxt->level + 1), ctxt->indent);
-			}
-			xmlOutputBufferWriteString(buf,
-				"<meta http-equiv=\"Content-Type\" content=\"text/html; charset=");
-			if (ctxt->encoding) {
-				xmlOutputBufferWriteString(buf, (const char *)ctxt->encoding);
-			} else {
-				xmlOutputBufferWrite(buf, 5, "UTF-8");
-			}
-			xmlOutputBufferWrite(buf, 4, "\" />");
-			if (ctxt->format == 1)
-				xmlOutputBufferWrite(buf, 1, "\n");
-		} else {
-			xmlOutputBufferWrite(buf, 1, ">");
-		}
-	    /*
-	     * C.3. Element Minimization and Empty Element Content
-	     */
-	    xmlOutputBufferWrite(buf, 2, "</");
-	    if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {
-		xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);
-		xmlOutputBufferWrite(buf, 1, ":");
-	    }
-	    xmlOutputBufferWriteString(buf, (const char *)cur->name);
-	    xmlOutputBufferWrite(buf, 1, ">");
-	}
-	return;
-    }
-    xmlOutputBufferWrite(buf, 1, ">");
-	if (addmeta == 1) {
-		if (ctxt->format == 1) {
-			xmlOutputBufferWrite(buf, 1, "\n");
-			if (xmlIndentTreeOutput)
-				xmlOutputBufferWrite(buf, ctxt->indent_size *
-				(ctxt->level + 1 > ctxt->indent_nr ?
-				ctxt->indent_nr : ctxt->level + 1), ctxt->indent);
-		}
-		xmlOutputBufferWriteString(buf,
-			"<meta http-equiv=\"Content-Type\" content=\"text/html; charset=");
-		if (ctxt->encoding) {
-			xmlOutputBufferWriteString(buf, (const char *)ctxt->encoding);
-		} else {
-			xmlOutputBufferWrite(buf, 5, "UTF-8");
-		}
-		xmlOutputBufferWrite(buf, 4, "\" />");
-	}
-    if ((cur->type != XML_ELEMENT_NODE) && (cur->content != NULL)) {
-	xmlOutputBufferWriteEscape(buf, cur->content, ctxt->escape);
-    }
+        while (1) {
+            if (cur == root)
+                return;
+            if (ctxt->format == 1)
+                xmlOutputBufferWrite(buf, 1, "\n");
+            if (cur->next != NULL) {
+                cur = cur->next;
+                break;
+            }
 
-#if 0
-    /*
-    * This was removed due to problems with HTML processors.
-    * See bug #345147.
-    */
-    /*
-     * 4.8. Script and Style elements
-     */
-    if ((cur->type == XML_ELEMENT_NODE) &&
-	((xmlStrEqual(cur->name, BAD_CAST "script")) ||
-	 (xmlStrEqual(cur->name, BAD_CAST "style"))) &&
-	((cur->ns == NULL) ||
-	 (xmlStrEqual(cur->ns->href, XHTML_NS_NAME)))) {
-	xmlNodePtr child = cur->children;
-
-	while (child != NULL) {
-	    if (child->type == XML_TEXT_NODE) {
-		if ((xmlStrchr(child->content, '<') == NULL) &&
-		    (xmlStrchr(child->content, '&') == NULL) &&
-		    (xmlStrstr(child->content, BAD_CAST "]]>") == NULL)) {
-		    /* Nothing to escape, so just output as is... */
-		    /* FIXME: Should we do something about "--" also? */
-		    int level = ctxt->level;
-		    int indent = ctxt->format;
-
-		    ctxt->level = 0;
-		    ctxt->format = 0;
-		    xmlOutputBufferWriteString(buf, (const char *) child->content);
-		    /* (We cannot use xhtmlNodeDumpOutput() here because
-		     * we wish to leave '>' unescaped!) */
-		    ctxt->level = level;
-		    ctxt->format = indent;
-		} else {
-		    /* We must use a CDATA section.  Unfortunately,
-		     * this will break CSS and JavaScript when read by
-		     * a browser in HTML4-compliant mode. :-( */
-		    start = end = child->content;
-		    while (*end != '\0') {
-			if (*end == ']' &&
-			    *(end + 1) == ']' &&
-			    *(end + 2) == '>') {
-			    end = end + 2;
-			    xmlOutputBufferWrite(buf, 9, "<![CDATA[");
-			    xmlOutputBufferWrite(buf, end - start,
-						 (const char *)start);
-			    xmlOutputBufferWrite(buf, 3, "]]>");
-			    start = end;
-			}
-			end++;
-		    }
-		    if (start != end) {
-			xmlOutputBufferWrite(buf, 9, "<![CDATA[");
-			xmlOutputBufferWrite(buf, end - start,
-			                     (const char *)start);
-			xmlOutputBufferWrite(buf, 3, "]]>");
-		    }
-		}
-	    } else {
-		int level = ctxt->level;
-		int indent = ctxt->format;
+            /*
+             * The parent should never be NULL here but we want to handle
+             * corrupted documents gracefully.
+             */
+            if (cur->parent == NULL)
+                return;
+            cur = cur->parent;
+
+            if (cur->type == XML_ELEMENT_NODE) {
+                if (ctxt->level > 0) ctxt->level--;
+                if ((xmlIndentTreeOutput) && (ctxt->format == 1))
+                    xmlOutputBufferWrite(buf, ctxt->indent_size *
+                                         (ctxt->level > ctxt->indent_nr ?
+                                          ctxt->indent_nr : ctxt->level),
+                                         ctxt->indent);
+
+                xmlOutputBufferWrite(buf, 2, "</");
+                if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {
+                    xmlOutputBufferWriteString(buf,
+                            (const char *)cur->ns->prefix);
+                    xmlOutputBufferWrite(buf, 1, ":");
+                }
 
-		ctxt->level = 0;
-		ctxt->format = 0;
-		xhtmlNodeDumpOutput(ctxt, child);
-		ctxt->level = level;
-		ctxt->format = indent;
-	    }
-	    child = child->next;
-	}
-    }
-#endif
+                xmlOutputBufferWriteString(buf, (const char *)cur->name);
+                xmlOutputBufferWrite(buf, 1, ">");
 
-    if (cur->children != NULL) {
-	int indent = ctxt->format;
-
-	if (format == 1) xmlOutputBufferWrite(buf, 1, "\n");
-	if (ctxt->level >= 0) ctxt->level++;
-	ctxt->format = format;
-	xhtmlNodeListDumpOutput(ctxt, cur->children);
-	if (ctxt->level > 0) ctxt->level--;
-	ctxt->format = indent;
-	if ((xmlIndentTreeOutput) && (format == 1))
-	    xmlOutputBufferWrite(buf, ctxt->indent_size *
-	                         (ctxt->level > ctxt->indent_nr ?
-				  ctxt->indent_nr : ctxt->level),
-				 ctxt->indent);
-    }
-    xmlOutputBufferWrite(buf, 2, "</");
-    if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {
-        xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);
-	xmlOutputBufferWrite(buf, 1, ":");
+                if (cur == unformattedNode) {
+                    ctxt->format = format;
+                    unformattedNode = NULL;
+                }
+            }
+        }
     }
-
-    xmlOutputBufferWriteString(buf, (const char *)cur->name);
-    xmlOutputBufferWrite(buf, 1, ">");
 }
 #endif
 
@@ -1802,6 +1754,7 @@ xmlSaveToFd(int fd, const char *encoding, int options)
     if (ret == NULL) return(NULL);
     ret->buf = xmlOutputBufferCreateFd(fd, ret->handler);
     if (ret->buf == NULL) {
+        xmlCharEncCloseFunc(ret->handler);
 	xmlFreeSaveCtxt(ret);
 	return(NULL);
     }
@@ -1831,6 +1784,7 @@ xmlSaveToFilename(const char *filename, const char *encoding, int options)
     ret->buf = xmlOutputBufferCreateFilename(filename, ret->handler,
                                              compression);
     if (ret->buf == NULL) {
+        xmlCharEncCloseFunc(ret->handler);
 	xmlFreeSaveCtxt(ret);
 	return(NULL);
     }
@@ -1853,28 +1807,15 @@ xmlSaveCtxtPtr
 xmlSaveToBuffer(xmlBufferPtr buffer, const char *encoding, int options)
 {
     xmlSaveCtxtPtr ret;
-    xmlOutputBufferPtr out_buff;
-    xmlCharEncodingHandlerPtr handler;
 
     ret = xmlNewSaveCtxt(encoding, options);
     if (ret == NULL) return(NULL);
-
-    if (encoding != NULL) {
-        handler = xmlFindCharEncodingHandler(encoding);
-        if (handler == NULL) {
-            xmlFree(ret);
-            return(NULL);
-        }
-    } else
-        handler = NULL;
-    out_buff = xmlOutputBufferCreateBuffer(buffer, handler);
-    if (out_buff == NULL) {
-        xmlFree(ret);
-        if (handler) xmlCharEncCloseFunc(handler);
-        return(NULL);
+    ret->buf = xmlOutputBufferCreateBuffer(buffer, ret->handler);
+    if (ret->buf == NULL) {
+        xmlCharEncCloseFunc(ret->handler);
+	xmlFreeSaveCtxt(ret);
+	return(NULL);
     }
-
-    ret->buf = out_buff;
     return(ret);
 }
 
@@ -1902,6 +1843,7 @@ xmlSaveToIO(xmlOutputWriteCallback iowrite,
     if (ret == NULL) return(NULL);
     ret->buf = xmlOutputBufferCreateIO(iowrite, ioclose, ioctx, ret->handler);
     if (ret->buf == NULL) {
+        xmlCharEncCloseFunc(ret->handler);
 	xmlFreeSaveCtxt(ret);
 	return(NULL);
     }
@@ -1942,12 +1884,25 @@ xmlSaveDoc(xmlSaveCtxtPtr ctxt, xmlDocPtr doc)
  * Returns the number of byte written or -1 in case of error
  */
 long
-xmlSaveTree(xmlSaveCtxtPtr ctxt, xmlNodePtr node)
+xmlSaveTree(xmlSaveCtxtPtr ctxt, xmlNodePtr cur)
 {
     long ret = 0;
 
-    if ((ctxt == NULL) || (node == NULL)) return(-1);
-    xmlNodeDumpOutputInternal(ctxt, node);
+    if ((ctxt == NULL) || (cur == NULL)) return(-1);
+#ifdef LIBXML_HTML_ENABLED
+    if (ctxt->options & XML_SAVE_XHTML) {
+        xhtmlNodeDumpOutput(ctxt, cur);
+        return(ret);
+    }
+    if (((cur->type != XML_NAMESPACE_DECL) && (cur->doc != NULL) &&
+         (cur->doc->type == XML_HTML_DOCUMENT_NODE) &&
+         ((ctxt->options & XML_SAVE_AS_XML) == 0)) ||
+        (ctxt->options & XML_SAVE_AS_HTML)) {
+	htmlNodeDumpOutputInternal(ctxt, cur);
+	return(ret);
+    }
+#endif
+    xmlNodeDumpOutputInternal(ctxt, cur);
     return(ret);
 }
 
@@ -2197,7 +2152,7 @@ xmlNodeDump(xmlBufferPtr buf, xmlDocPtr doc, xmlNodePtr cur, int level,
             int format)
 {
     xmlBufPtr buffer;
-    int ret;
+    size_t ret;
 
     if ((buf == NULL) || (cur == NULL))
         return(-1);
diff --git a/xmlschemas.c b/xmlschemas.c
index d19de6df..c455b4a3 100644
--- a/xmlschemas.c
+++ b/xmlschemas.c
@@ -860,6 +860,7 @@ struct _xmlSchemaIDCMatcher {
     int sizeKeySeqs;
     xmlSchemaItemListPtr targets; /* list of target-node
                                      (xmlSchemaPSVIIDCNodePtr) entries */
+    xmlHashTablePtr htab;
 };
 
 /*
@@ -1002,11 +1003,11 @@ struct _xmlSchemaValidCtxt {
     int xsiAssemble;
 
     int depth;
-    xmlSchemaNodeInfoPtr *elemInfos; /* array of element informations */
+    xmlSchemaNodeInfoPtr *elemInfos; /* array of element information */
     int sizeElemInfos;
     xmlSchemaNodeInfoPtr inode; /* the current element information */
 
-    xmlSchemaIDCAugPtr aidcs; /* a list of augmented IDC informations */
+    xmlSchemaIDCAugPtr aidcs; /* a list of augmented IDC information */
 
     xmlSchemaIDCStateObjPtr xpathStates; /* first active state object. */
     xmlSchemaIDCStateObjPtr xpathStatePool; /* first stored state object. */
@@ -1055,6 +1056,18 @@ struct _xmlSchemaSubstGroup {
     xmlSchemaItemListPtr members;
 };
 
+/**
+ * xmlIDCHashEntry:
+ *
+ * an entry in hash tables to quickly look up keys/uniques
+ */
+typedef struct _xmlIDCHashEntry xmlIDCHashEntry;
+typedef xmlIDCHashEntry *xmlIDCHashEntryPtr;
+struct _xmlIDCHashEntry {
+    xmlIDCHashEntryPtr next; /* next item with same hash */
+    int index;               /* index into associated item list */
+};
+
 /************************************************************************
  *									*
  *			Some predeclarations				*
@@ -1478,6 +1491,7 @@ xmlSchemaWildcardPCToString(int pc)
  * @val: the precomputed value
  * @retValue: the returned value
  * @ws: the whitespace type of the value
+ * @for_hash: non-zero if this is supposed to generate a string for hashing
  *
  * Get a the canonical representation of the value.
  * The caller has to free the returned retValue.
@@ -1486,9 +1500,10 @@ xmlSchemaWildcardPCToString(int pc)
  *         API errors or if the value type is not supported yet.
  */
 static int
-xmlSchemaGetCanonValueWhtspExt(xmlSchemaValPtr val,
-			       xmlSchemaWhitespaceValueType ws,
-			       xmlChar **retValue)
+xmlSchemaGetCanonValueWhtspExt_1(xmlSchemaValPtr val,
+			         xmlSchemaWhitespaceValueType ws,
+			         xmlChar **retValue,
+				 int for_hash)
 {
     int list;
     xmlSchemaValType valType;
@@ -1522,6 +1537,20 @@ xmlSchemaGetCanonValueWhtspExt(xmlSchemaValPtr val,
 			xmlFree((xmlChar *) value2);
 		    goto internal_error;
 		}
+		if (for_hash && valType == XML_SCHEMAS_DECIMAL) {
+		    /* We can mostly use the canonical value for hashing,
+		       except in the case of decimal.  There the canonical
+		       representation requires a trailing '.0' even for
+		       non-fractional numbers, but for the derived integer
+		       types it forbids any decimal point.  Nevertheless they
+		       compare equal if the value is equal.  We need to generate
+		       the same hash value for this to work, and it's easiest
+		       to just cut off the useless '.0' suffix for the
+		       decimal type.  */
+		    int len = xmlStrlen(value2);
+		    if (len > 2 && value2[len-1] == '0' && value2[len-2] == '.')
+		      ((xmlChar*)value2)[len-2] = 0;
+		}
 		value = value2;
 	}
 	if (*retValue == NULL)
@@ -1548,6 +1577,22 @@ internal_error:
     return (-1);
 }
 
+static int
+xmlSchemaGetCanonValueWhtspExt(xmlSchemaValPtr val,
+			       xmlSchemaWhitespaceValueType ws,
+			       xmlChar **retValue)
+{
+    return xmlSchemaGetCanonValueWhtspExt_1(val, ws, retValue, 0);
+}
+
+static int
+xmlSchemaGetCanonValueHash(xmlSchemaValPtr val,
+			   xmlChar **retValue)
+{
+    return xmlSchemaGetCanonValueWhtspExt_1(val, XML_SCHEMA_WHITESPACE_COLLAPSE,
+					    retValue, 1);
+}
+
 /**
  * xmlSchemaFormatItemForReport:
  * @buf: the string buffer
@@ -1873,7 +1918,7 @@ xmlSchemaPSimpleErr(const char *msg)
 /**
  * xmlSchemaPErrMemory:
  * @node: a context node
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle an out of memory condition
  */
@@ -1995,7 +2040,7 @@ xmlSchemaPErrExt(xmlSchemaParserCtxtPtr ctxt, xmlNodePtr node, int error,
 /**
  * xmlSchemaVTypeErrMemory:
  * @node: a context node
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle an out of memory condition
  */
@@ -6031,7 +6076,7 @@ xmlSchemaPValAttrID(xmlSchemaParserCtxtPtr ctxt,
 /**
  * xmlGetMaxOccurs:
  * @ctxt:  a schema validation context
- * @node:  a subtree containing XML Schema informations
+ * @node:  a subtree containing XML Schema information
  *
  * Get the maxOccurs property
  *
@@ -6074,7 +6119,16 @@ xmlGetMaxOccurs(xmlSchemaParserCtxtPtr ctxt, xmlNodePtr node,
 	return (def);
     }
     while ((*cur >= '0') && (*cur <= '9')) {
-        ret = ret * 10 + (*cur - '0');
+        if (ret > INT_MAX / 10) {
+            ret = INT_MAX;
+        } else {
+            int digit = *cur - '0';
+            ret *= 10;
+            if (ret > INT_MAX - digit)
+                ret = INT_MAX;
+            else
+                ret += digit;
+        }
         cur++;
     }
     while (IS_BLANK_CH(*cur))
@@ -6096,7 +6150,7 @@ xmlGetMaxOccurs(xmlSchemaParserCtxtPtr ctxt, xmlNodePtr node,
 /**
  * xmlGetMinOccurs:
  * @ctxt:  a schema validation context
- * @node:  a subtree containing XML Schema informations
+ * @node:  a subtree containing XML Schema information
  *
  * Get the minOccurs property
  *
@@ -6126,7 +6180,16 @@ xmlGetMinOccurs(xmlSchemaParserCtxtPtr ctxt, xmlNodePtr node,
         return (def);
     }
     while ((*cur >= '0') && (*cur <= '9')) {
-        ret = ret * 10 + (*cur - '0');
+        if (ret > INT_MAX / 10) {
+            ret = INT_MAX;
+        } else {
+            int digit = *cur - '0';
+            ret *= 10;
+            if (ret > INT_MAX - digit)
+                ret = INT_MAX;
+            else
+                ret += digit;
+        }
         cur++;
     }
     while (IS_BLANK_CH(*cur))
@@ -6193,7 +6256,7 @@ xmlSchemaPGetBoolNodeValue(xmlSchemaParserCtxtPtr ctxt,
 /**
  * xmlGetBooleanProp:
  * @ctxt:  a schema validation context
- * @node:  a subtree containing XML Schema informations
+ * @node:  a subtree containing XML Schema information
  * @name:  the attribute name
  * @def:  the default value
  *
@@ -6481,7 +6544,7 @@ xmlSchemaCheckReference(xmlSchemaParserCtxtPtr pctxt,
  * xmlSchemaParseLocalAttributes:
  * @ctxt:  a schema validation context
  * @schema:  the schema being built
- * @node:  a subtree containing XML Schema informations
+ * @node:  a subtree containing XML Schema information
  * @type:  the hosting type where the attributes will be anchored
  *
  * Parses attribute uses and attribute declarations and
@@ -6523,7 +6586,7 @@ xmlSchemaParseLocalAttributes(xmlSchemaParserCtxtPtr ctxt, xmlSchemaPtr schema,
  * xmlSchemaParseAnnotation:
  * @ctxt:  a schema validation context
  * @schema:  the schema being built
- * @node:  a subtree containing XML Schema informations
+ * @node:  a subtree containing XML Schema information
  *
  * parse a XML schema Attribute declaration
  * *WARNING* this interface is highly subject to change
@@ -6643,7 +6706,7 @@ xmlSchemaParseAnnotation(xmlSchemaParserCtxtPtr ctxt, xmlNodePtr node, int neede
  * xmlSchemaParseFacet:
  * @ctxt:  a schema validation context
  * @schema:  the schema being built
- * @node:  a subtree containing XML Schema informations
+ * @node:  a subtree containing XML Schema information
  *
  * parse a XML schema Facet declaration
  * *WARNING* this interface is highly subject to change
@@ -6734,7 +6797,7 @@ xmlSchemaParseFacet(xmlSchemaParserCtxtPtr ctxt, xmlSchemaPtr schema,
  * xmlSchemaParseWildcardNs:
  * @ctxt:  a schema parser context
  * @wildc:  the wildcard, already created
- * @node:  a subtree containing XML Schema informations
+ * @node:  a subtree containing XML Schema information
  *
  * Parses the attribute "processContents" and "namespace"
  * of a xsd:anyAttribute and xsd:any.
@@ -6901,7 +6964,7 @@ xmlSchemaPCheckParticleCorrect_2(xmlSchemaParserCtxtPtr ctxt,
  * xmlSchemaParseAny:
  * @ctxt:  a schema validation context
  * @schema:  the schema being built
- * @node:  a subtree containing XML Schema informations
+ * @node:  a subtree containing XML Schema information
  *
  * Parsea a XML schema <any> element. A particle and wildcard
  * will be created (except if minOccurs==maxOccurs==0, in this case
@@ -6996,7 +7059,7 @@ xmlSchemaParseAny(xmlSchemaParserCtxtPtr ctxt, xmlSchemaPtr schema,
  * xmlSchemaParseNotation:
  * @ctxt:  a schema validation context
  * @schema:  the schema being built
- * @node:  a subtree containing XML Schema informations
+ * @node:  a subtree containing XML Schema information
  *
  * parse a XML schema Notation declaration
  *
@@ -7043,7 +7106,7 @@ xmlSchemaParseNotation(xmlSchemaParserCtxtPtr ctxt, xmlSchemaPtr schema,
  * xmlSchemaParseAnyAttribute:
  * @ctxt:  a schema validation context
  * @schema:  the schema being built
- * @node:  a subtree containing XML Schema informations
+ * @node:  a subtree containing XML Schema information
  *
  * parse a XML schema AnyAttribute declaration
  * *WARNING* this interface is highly subject to change
@@ -7113,7 +7176,7 @@ xmlSchemaParseAnyAttribute(xmlSchemaParserCtxtPtr ctxt,
  * xmlSchemaParseAttribute:
  * @ctxt:  a schema validation context
  * @schema:  the schema being built
- * @node:  a subtree containing XML Schema informations
+ * @node:  a subtree containing XML Schema information
  *
  * parse a XML schema Attribute declaration
  * *WARNING* this interface is highly subject to change
@@ -7656,7 +7719,7 @@ xmlSchemaParseGlobalAttribute(xmlSchemaParserCtxtPtr pctxt,
  * xmlSchemaParseAttributeGroupRef:
  * @ctxt:  a schema validation context
  * @schema:  the schema being built
- * @node:  a subtree containing XML Schema informations
+ * @node:  a subtree containing XML Schema information
  *
  * Parse an attribute group definition reference.
  * Note that a reference to an attribute group does not
@@ -7789,7 +7852,7 @@ xmlSchemaParseAttributeGroupRef(xmlSchemaParserCtxtPtr pctxt,
  * xmlSchemaParseAttributeGroupDefinition:
  * @pctxt:  a schema validation context
  * @schema:  the schema being built
- * @node:  a subtree containing XML Schema informations
+ * @node:  a subtree containing XML Schema information
  *
  * parse a XML schema Attribute Group declaration
  * *WARNING* this interface is highly subject to change
@@ -8220,7 +8283,7 @@ xmlSchemaAddAnnotation(xmlSchemaAnnotItemPtr annItem,
  * xmlSchemaParseIDCSelectorAndField:
  * @ctxt:  a schema validation context
  * @schema:  the schema being built
- * @node:  a subtree containing XML Schema informations
+ * @node:  a subtree containing XML Schema information
  *
  * Parses a XML Schema identity-constraint definition's
  * <selector> and <field> elements.
@@ -8318,7 +8381,7 @@ xmlSchemaParseIDCSelectorAndField(xmlSchemaParserCtxtPtr ctxt,
  * xmlSchemaParseIDC:
  * @ctxt:  a schema validation context
  * @schema:  the schema being built
- * @node:  a subtree containing XML Schema informations
+ * @node:  a subtree containing XML Schema information
  *
  * Parses a XML Schema identity-constraint definition.
  *
@@ -8465,7 +8528,7 @@ xmlSchemaParseIDC(xmlSchemaParserCtxtPtr ctxt,
  * xmlSchemaParseElement:
  * @ctxt:  a schema validation context
  * @schema:  the schema being built
- * @node:  a subtree containing XML Schema informations
+ * @node:  a subtree containing XML Schema information
  * @topLevel: indicates if this is global declaration
  *
  * Parses a XML schema element declaration.
@@ -8864,7 +8927,7 @@ return_null:
  * xmlSchemaParseUnion:
  * @ctxt:  a schema validation context
  * @schema:  the schema being built
- * @node:  a subtree containing XML Schema informations
+ * @node:  a subtree containing XML Schema information
  *
  * parse a XML schema Union definition
  * *WARNING* this interface is highly subject to change
@@ -9033,7 +9096,7 @@ xmlSchemaParseUnion(xmlSchemaParserCtxtPtr ctxt, xmlSchemaPtr schema,
  * xmlSchemaParseList:
  * @ctxt:  a schema validation context
  * @schema:  the schema being built
- * @node:  a subtree containing XML Schema informations
+ * @node:  a subtree containing XML Schema information
  *
  * parse a XML schema List definition
  * *WARNING* this interface is highly subject to change
@@ -9144,7 +9207,7 @@ xmlSchemaParseList(xmlSchemaParserCtxtPtr ctxt, xmlSchemaPtr schema,
  * xmlSchemaParseSimpleType:
  * @ctxt:  a schema validation context
  * @schema:  the schema being built
- * @node:  a subtree containing XML Schema informations
+ * @node:  a subtree containing XML Schema information
  *
  * parse a XML schema Simple Type definition
  * *WARNING* this interface is highly subject to change
@@ -9455,7 +9518,7 @@ xmlSchemaParseModelGroupDefRef(xmlSchemaParserCtxtPtr ctxt,
  * xmlSchemaParseModelGroupDefinition:
  * @ctxt:  a schema validation context
  * @schema:  the schema being built
- * @node:  a subtree containing XML Schema informations
+ * @node:  a subtree containing XML Schema information
  *
  * Parses a XML schema model group definition.
  *
@@ -10293,7 +10356,7 @@ xmlSchemaBuildAbsoluteURI(xmlDictPtr dict, const xmlChar* location,
  * xmlSchemaAddSchemaDoc:
  * @pctxt:  a schema validation context
  * @schema:  the schema being built
- * @node:  a subtree containing XML Schema informations
+ * @node:  a subtree containing XML Schema information
  *
  * Parse an included (and to-be-redefined) XML schema document.
  *
@@ -10717,7 +10780,7 @@ exit_failure:
  * xmlSchemaParseImport:
  * @ctxt:  a schema validation context
  * @schema:  the schema being built
- * @node:  a subtree containing XML Schema informations
+ * @node:  a subtree containing XML Schema information
  *
  * parse a XML schema Import definition
  * *WARNING* this interface is highly subject to change
@@ -11209,7 +11272,7 @@ xmlSchemaParseInclude(xmlSchemaParserCtxtPtr pctxt, xmlSchemaPtr schema,
  * xmlSchemaParseModelGroup:
  * @ctxt:  a schema validation context
  * @schema:  the schema being built
- * @node:  a subtree containing XML Schema informations
+ * @node:  a subtree containing XML Schema information
  * @type: the "compositor" type
  * @particleNeeded: if a a model group with a particle
  *
@@ -11489,7 +11552,7 @@ xmlSchemaParseModelGroup(xmlSchemaParserCtxtPtr ctxt, xmlSchemaPtr schema,
  * xmlSchemaParseRestriction:
  * @ctxt:  a schema validation context
  * @schema:  the schema being built
- * @node:  a subtree containing XML Schema informations
+ * @node:  a subtree containing XML Schema information
  *
  * parse a XML schema Restriction definition
  * *WARNING* this interface is highly subject to change
@@ -11792,7 +11855,7 @@ xmlSchemaParseRestriction(xmlSchemaParserCtxtPtr ctxt, xmlSchemaPtr schema,
  * xmlSchemaParseExtension:
  * @ctxt:  a schema validation context
  * @schema:  the schema being built
- * @node:  a subtree containing XML Schema informations
+ * @node:  a subtree containing XML Schema information
  *
  * Parses an <extension>, which is found inside a
  * <simpleContent> or <complexContent>.
@@ -11928,7 +11991,7 @@ xmlSchemaParseExtension(xmlSchemaParserCtxtPtr ctxt, xmlSchemaPtr schema,
  * xmlSchemaParseSimpleContent:
  * @ctxt:  a schema validation context
  * @schema:  the schema being built
- * @node:  a subtree containing XML Schema informations
+ * @node:  a subtree containing XML Schema information
  *
  * parse a XML schema SimpleContent definition
  * *WARNING* this interface is highly subject to change
@@ -12018,7 +12081,7 @@ xmlSchemaParseSimpleContent(xmlSchemaParserCtxtPtr ctxt,
  * xmlSchemaParseComplexContent:
  * @ctxt:  a schema validation context
  * @schema:  the schema being built
- * @node:  a subtree containing XML Schema informations
+ * @node:  a subtree containing XML Schema information
  *
  * parse a XML schema ComplexContent definition
  * *WARNING* this interface is highly subject to change
@@ -12113,7 +12176,7 @@ xmlSchemaParseComplexContent(xmlSchemaParserCtxtPtr ctxt,
  * xmlSchemaParseComplexType:
  * @ctxt:  a schema validation context
  * @schema:  the schema being built
- * @node:  a subtree containing XML Schema informations
+ * @node:  a subtree containing XML Schema information
  *
  * parse a XML schema Complex Type definition
  * *WARNING* this interface is highly subject to change
@@ -14938,7 +15001,7 @@ xmlSchemaCheckTypeDefCircularInternal(xmlSchemaParserCtxtPtr pctxt,
     }
     if (ancestor->flags & XML_SCHEMAS_TYPE_MARKED) {
 	/*
-	* Avoid inifinite recursion on circular types not yet checked.
+	* Avoid infinite recursion on circular types not yet checked.
 	*/
 	return (0);
     }
@@ -20961,7 +21024,7 @@ xmlSchemaFixupComponents(xmlSchemaParserCtxtPtr pctxt,
 		break;
 	    case XML_SCHEMA_EXTRA_ATTR_USE_PROHIB:
 		/*
-		* Handle attribue prohibition which had a
+		* Handle attribute prohibition which had a
 		* "ref" attribute.
 		*/
 		xmlSchemaResolveAttrUseProhibReferences(
@@ -22293,6 +22356,17 @@ xmlSchemaIDCFreeIDCTable(xmlSchemaPSVIIDCBindingPtr bind)
     }
 }
 
+static void
+xmlFreeIDCHashEntry (void *payload, const xmlChar *name ATTRIBUTE_UNUSED)
+{
+    xmlIDCHashEntryPtr e = payload, n;
+    while (e) {
+	n = e->next;
+	xmlFree(e);
+	e = n;
+    }
+}
+
 /**
  * xmlSchemaIDCFreeMatcherList:
  * @matcher: the first IDC matcher in the list
@@ -22331,6 +22405,8 @@ xmlSchemaIDCFreeMatcherList(xmlSchemaIDCMatcherPtr matcher)
 	    }
 	    xmlSchemaItemListFree(matcher->targets);
 	}
+	if (matcher->htab != NULL)
+	  xmlHashFree(matcher->htab, xmlFreeIDCHashEntry);
 	xmlFree(matcher);
 	matcher = next;
     }
@@ -22381,6 +22457,10 @@ xmlSchemaIDCReleaseMatcherList(xmlSchemaValidCtxtPtr vctxt,
 	    xmlSchemaItemListFree(matcher->targets);
 	    matcher->targets = NULL;
 	}
+	if (matcher->htab != NULL) {
+	    xmlHashFree(matcher->htab, xmlFreeIDCHashEntry);
+	    matcher->htab = NULL;
+	}
 	matcher->next = NULL;
 	/*
 	* Cache the matcher.
@@ -22615,10 +22695,10 @@ next_sto:
 }
 
 static const xmlChar *
-xmlSchemaFormatIDCKeySequence(xmlSchemaValidCtxtPtr vctxt,
-			      xmlChar **buf,
-			      xmlSchemaPSVIIDCKeyPtr *seq,
-			      int count)
+xmlSchemaFormatIDCKeySequence_1(xmlSchemaValidCtxtPtr vctxt,
+				xmlChar **buf,
+				xmlSchemaPSVIIDCKeyPtr *seq,
+				int count, int for_hash)
 {
     int i, res;
     xmlChar *value = NULL;
@@ -22626,9 +22706,13 @@ xmlSchemaFormatIDCKeySequence(xmlSchemaValidCtxtPtr vctxt,
     *buf = xmlStrdup(BAD_CAST "[");
     for (i = 0; i < count; i++) {
 	*buf = xmlStrcat(*buf, BAD_CAST "'");
-	res = xmlSchemaGetCanonValueWhtspExt(seq[i]->val,
-	    xmlSchemaGetWhiteSpaceFacetValue(seq[i]->type),
-	    &value);
+	if (!for_hash)
+	    res = xmlSchemaGetCanonValueWhtspExt(seq[i]->val,
+		    xmlSchemaGetWhiteSpaceFacetValue(seq[i]->type),
+		    &value);
+	else {
+	    res = xmlSchemaGetCanonValueHash(seq[i]->val, &value);
+	}
 	if (res == 0)
 	    *buf = xmlStrcat(*buf, BAD_CAST value);
 	else {
@@ -22650,6 +22734,24 @@ xmlSchemaFormatIDCKeySequence(xmlSchemaValidCtxtPtr vctxt,
     return (BAD_CAST *buf);
 }
 
+static const xmlChar *
+xmlSchemaFormatIDCKeySequence(xmlSchemaValidCtxtPtr vctxt,
+			      xmlChar **buf,
+			      xmlSchemaPSVIIDCKeyPtr *seq,
+			      int count)
+{
+    return xmlSchemaFormatIDCKeySequence_1(vctxt, buf, seq, count, 0);
+}
+
+static const xmlChar *
+xmlSchemaHashKeySequence(xmlSchemaValidCtxtPtr vctxt,
+			 xmlChar **buf,
+			 xmlSchemaPSVIIDCKeyPtr *seq,
+			 int count)
+{
+    return xmlSchemaFormatIDCKeySequence_1(vctxt, buf, seq, count, 1);
+}
+
 /**
  * xmlSchemaXPathPop:
  * @vctxt: the WXS validation context
@@ -23011,15 +23113,25 @@ create_key:
 	    if ((idc->type != XML_SCHEMA_TYPE_IDC_KEYREF) &&
 		(targets->nbItems != 0)) {
 		xmlSchemaPSVIIDCKeyPtr ckey, bkey, *bkeySeq;
+		xmlIDCHashEntryPtr e;
 
-		i = 0;
 		res = 0;
+
+		if (!matcher->htab)
+		    e = NULL;
+		else {
+		    xmlChar *value = NULL;
+		    xmlSchemaHashKeySequence(vctxt, &value, *keySeq, nbKeys);
+		    e = xmlHashLookup(matcher->htab, value);
+		    FREE_AND_NULL(value);
+		}
+
 		/*
 		* Compare the key-sequences, key by key.
 		*/
-		do {
+		for (;e; e = e->next) {
 		    bkeySeq =
-			((xmlSchemaPSVIIDCNodePtr) targets->items[i])->keys;
+			((xmlSchemaPSVIIDCNodePtr) targets->items[e->index])->keys;
 		    for (j = 0; j < nbKeys; j++) {
 			ckey = (*keySeq)[j];
 			bkey = bkeySeq[j];
@@ -23040,9 +23152,8 @@ create_key:
 			*/
 			break;
 		    }
-		    i++;
-		} while (i < targets->nbItems);
-		if (i != targets->nbItems) {
+		}
+		if (e) {
 		    xmlChar *str = NULL, *strB = NULL;
 		    /*
 		    * TODO: Try to report the key-sequence.
@@ -23120,6 +23231,24 @@ create_key:
 		}
 		return (-1);
 	    }
+	    if (idc->type != XML_SCHEMA_TYPE_IDC_KEYREF) {
+		xmlChar *value = NULL;
+		xmlIDCHashEntryPtr r, e;
+		if (!matcher->htab)
+		  matcher->htab = xmlHashCreate(4);
+		xmlSchemaHashKeySequence(vctxt, &value, ntItem->keys, nbKeys);
+		e = xmlMalloc(sizeof *e);
+		e->index = targets->nbItems - 1;
+		r = xmlHashLookup(matcher->htab, value);
+		if (r) {
+		    e->next = r->next;
+		    r->next = e;
+		} else {
+		    e->next = NULL;
+		    xmlHashAddEntry(matcher->htab, value, e);
+		}
+		FREE_AND_NULL(value);
+	    }
 
 	    goto selector_leave;
 selector_key_error:
@@ -23376,6 +23505,10 @@ xmlSchemaIDCFillNodeTables(xmlSchemaValidCtxtPtr vctxt,
 	    matcher->targets->items = NULL;
 	    matcher->targets->sizeItems = 0;
 	    matcher->targets->nbItems = 0;
+	    if (matcher->htab) {
+		xmlHashFree(matcher->htab, xmlFreeIDCHashEntry);
+		matcher->htab = NULL;
+	    }
 	} else {
 	    /*
 	    * Compare the key-sequences and add to the IDC node-table.
@@ -23823,6 +23956,7 @@ xmlSchemaCheckCVCIDCKeyRef(xmlSchemaValidCtxtPtr vctxt)
 	    int i, j, k, res, nbFields, hasDupls;
 	    xmlSchemaPSVIIDCKeyPtr *refKeys, *keys;
 	    xmlSchemaPSVIIDCNodePtr refNode = NULL;
+	    xmlHashTablePtr table = NULL;
 
 	    nbFields = matcher->aidc->def->nbFields;
 
@@ -23840,26 +23974,52 @@ xmlSchemaCheckCVCIDCKeyRef(xmlSchemaValidCtxtPtr vctxt)
 	    /*
 	    * Search for a matching key-sequences.
 	    */
+	    if (bind) {
+		table = xmlHashCreate(bind->nbNodes * 2);
+		for (j = 0; j < bind->nbNodes; j++) {
+		    xmlChar *value;
+		    xmlIDCHashEntryPtr r, e;
+		    keys = bind->nodeTable[j]->keys;
+		    xmlSchemaHashKeySequence(vctxt, &value, keys, nbFields);
+		    e = xmlMalloc(sizeof *e);
+		    e->index = j;
+		    r = xmlHashLookup(table, value);
+		    if (r) {
+			e->next = r->next;
+			r->next = e;
+		    } else {
+			e->next = NULL;
+			xmlHashAddEntry(table, value, e);
+		    }
+		    FREE_AND_NULL(value);
+		}
+	    }
 	    for (i = 0; i < matcher->targets->nbItems; i++) {
 		res = 0;
 		refNode = matcher->targets->items[i];
 		if (bind != NULL) {
+		    xmlChar *value;
+		    xmlIDCHashEntryPtr e;
 		    refKeys = refNode->keys;
-		    for (j = 0; j < bind->nbNodes; j++) {
-			keys = bind->nodeTable[j]->keys;
+		    xmlSchemaHashKeySequence(vctxt, &value, refKeys, nbFields);
+		    e = xmlHashLookup(table, value);
+		    FREE_AND_NULL(value);
+		    res = 0;
+		    for (;e; e = e->next) {
+			keys = bind->nodeTable[e->index]->keys;
 			for (k = 0; k < nbFields; k++) {
 			    res = xmlSchemaAreValuesEqual(keys[k]->val,
-				refKeys[k]->val);
+							  refKeys[k]->val);
 			    if (res == 0)
-				break;
+			        break;
 			    else if (res == -1) {
 				return (-1);
 			    }
 			}
 			if (res == 1) {
 			    /*
-			    * Match found.
-			    */
+			     * Match found.
+			     */
 			    break;
 			}
 		    }
@@ -23914,6 +24074,9 @@ xmlSchemaCheckCVCIDCKeyRef(xmlSchemaValidCtxtPtr vctxt)
 		    FREE_AND_NULL(strB);
 		}
 	    }
+	    if (table) {
+		xmlHashFree(table, xmlFreeIDCHashEntry);
+	    }
 	}
 	matcher = matcher->next;
     }
@@ -24184,7 +24347,7 @@ xmlSchemaValidateFacets(xmlSchemaAbstractCtxtPtr actxt,
 			unsigned long length,
 			int fireErrors)
 {
-    int ret, error = 0;
+    int ret, error = 0, found;
 
     xmlSchemaTypePtr tmpType;
     xmlSchemaFacetLinkPtr facetLink;
@@ -24308,103 +24471,98 @@ WXS_IS_LIST:
     }
 
 pattern_and_enum:
-    if (error >= 0) {
-	int found = 0;
-	/*
-	* Process enumerations. Facet values are in the value space
-	* of the defining type's base type. This seems to be a bug in the
-	* XML Schema 1.0 spec. Use the whitespace type of the base type.
-	* Only the first set of enumerations in the ancestor-or-self axis
-	* is used for validation.
-	*/
-	ret = 0;
-	tmpType = type;
-	do {
-	    for (facet = tmpType->facets; facet != NULL; facet = facet->next) {
-		if (facet->type != XML_SCHEMA_FACET_ENUMERATION)
-		    continue;
-		found = 1;
-		ret = xmlSchemaAreValuesEqual(facet->val, val);
-		if (ret == 1)
-		    break;
-		else if (ret < 0) {
-		    AERROR_INT("xmlSchemaValidateFacets",
-			"validating against an enumeration facet");
-		    return (-1);
-		}
-	    }
-	    if (ret != 0)
-		break;
-	    /*
-	    * Break on the first set of enumerations. Any additional
-	    *  enumerations which might be existent on the ancestors
-	    *  of the current type are restricted by this set; thus
-	    *  *must* *not* be taken into account.
-	    */
-	    if (found)
-		break;
-	    tmpType = tmpType->baseType;
-	} while ((tmpType != NULL) &&
-	    (tmpType->type != XML_SCHEMA_TYPE_BASIC));
-	if (found && (ret == 0)) {
-	    ret = XML_SCHEMAV_CVC_ENUMERATION_VALID;
-	    if (fireErrors) {
-		xmlSchemaFacetErr(actxt, ret, node,
-		    value, 0, type, NULL, NULL, NULL, NULL);
-	    } else
-		return (ret);
-	    if (error == 0)
-		error = ret;
-	}
-    }
-
-    if (error >= 0) {
-	int found;
-	/*
-	* Process patters. Pattern facets are ORed at type level
-	* and ANDed if derived. Walk the base type axis.
-	*/
-	tmpType = type;
-	facet = NULL;
-	do {
-	    found = 0;
-	    for (facetLink = tmpType->facetSet; facetLink != NULL;
-		facetLink = facetLink->next) {
-		if (facetLink->facet->type != XML_SCHEMA_FACET_PATTERN)
-		    continue;
-		found = 1;
-		/*
-		* NOTE that for patterns, @value needs to be the
-		* normalized value.
-		*/
-		ret = xmlRegexpExec(facetLink->facet->regexp, value);
-		if (ret == 1)
-		    break;
-		else if (ret < 0) {
-		    AERROR_INT("xmlSchemaValidateFacets",
-			"validating against a pattern facet");
-		    return (-1);
-		} else {
-		    /*
-		    * Save the last non-validating facet.
-		    */
-		    facet = facetLink->facet;
-		}
-	    }
-	    if (found && (ret != 1)) {
-		ret = XML_SCHEMAV_CVC_PATTERN_VALID;
-		if (fireErrors) {
-		    xmlSchemaFacetErr(actxt, ret, node,
-			value, 0, type, facet, NULL, NULL, NULL);
-		} else
-		    return (ret);
-		if (error == 0)
-		    error = ret;
-		break;
-	    }
-	    tmpType = tmpType->baseType;
-	} while ((tmpType != NULL) && (tmpType->type != XML_SCHEMA_TYPE_BASIC));
-    }
+    found = 0;
+    /*
+    * Process enumerations. Facet values are in the value space
+    * of the defining type's base type. This seems to be a bug in the
+    * XML Schema 1.0 spec. Use the whitespace type of the base type.
+    * Only the first set of enumerations in the ancestor-or-self axis
+    * is used for validation.
+    */
+    ret = 0;
+    tmpType = type;
+    do {
+        for (facet = tmpType->facets; facet != NULL; facet = facet->next) {
+            if (facet->type != XML_SCHEMA_FACET_ENUMERATION)
+                continue;
+            found = 1;
+            ret = xmlSchemaAreValuesEqual(facet->val, val);
+            if (ret == 1)
+                break;
+            else if (ret < 0) {
+                AERROR_INT("xmlSchemaValidateFacets",
+                    "validating against an enumeration facet");
+                return (-1);
+            }
+        }
+        if (ret != 0)
+            break;
+        /*
+        * Break on the first set of enumerations. Any additional
+        *  enumerations which might be existent on the ancestors
+        *  of the current type are restricted by this set; thus
+        *  *must* *not* be taken into account.
+        */
+        if (found)
+            break;
+        tmpType = tmpType->baseType;
+    } while ((tmpType != NULL) &&
+        (tmpType->type != XML_SCHEMA_TYPE_BASIC));
+    if (found && (ret == 0)) {
+        ret = XML_SCHEMAV_CVC_ENUMERATION_VALID;
+        if (fireErrors) {
+            xmlSchemaFacetErr(actxt, ret, node,
+                value, 0, type, NULL, NULL, NULL, NULL);
+        } else
+            return (ret);
+        if (error == 0)
+            error = ret;
+    }
+
+    /*
+    * Process patters. Pattern facets are ORed at type level
+    * and ANDed if derived. Walk the base type axis.
+    */
+    tmpType = type;
+    facet = NULL;
+    do {
+        found = 0;
+        for (facetLink = tmpType->facetSet; facetLink != NULL;
+            facetLink = facetLink->next) {
+            if (facetLink->facet->type != XML_SCHEMA_FACET_PATTERN)
+                continue;
+            found = 1;
+            /*
+            * NOTE that for patterns, @value needs to be the
+            * normalized value.
+            */
+            ret = xmlRegexpExec(facetLink->facet->regexp, value);
+            if (ret == 1)
+                break;
+            else if (ret < 0) {
+                AERROR_INT("xmlSchemaValidateFacets",
+                    "validating against a pattern facet");
+                return (-1);
+            } else {
+                /*
+                * Save the last non-validating facet.
+                */
+                facet = facetLink->facet;
+            }
+        }
+        if (found && (ret != 1)) {
+            ret = XML_SCHEMAV_CVC_PATTERN_VALID;
+            if (fireErrors) {
+                xmlSchemaFacetErr(actxt, ret, node,
+                    value, 0, type, facet, NULL, NULL, NULL);
+            } else
+                return (ret);
+            if (error == 0)
+                error = ret;
+            break;
+        }
+        tmpType = tmpType->baseType;
+    } while ((tmpType != NULL) && (tmpType->type != XML_SCHEMA_TYPE_BASIC));
 
     return (error);
 }
@@ -27802,7 +27960,7 @@ xmlSchemaIsValid(xmlSchemaValidCtxtPtr ctxt)
  * @warn: the warning function
  * @ctx: the functions context
  *
- * Set the error and warning callback informations
+ * Set the error and warning callback information
  */
 void
 xmlSchemaSetValidErrors(xmlSchemaValidCtxtPtr ctxt,
@@ -27847,7 +28005,7 @@ xmlSchemaSetValidStructuredErrors(xmlSchemaValidCtxtPtr ctxt,
  * @warn: the warning function result
  * @ctx: the functions context result
  *
- * Get the error and warning callback informations
+ * Get the error and warning callback information
  *
  * Returns -1 in case of error and 0 otherwise
  */
@@ -27938,6 +28096,10 @@ xmlSchemaVDocWalk(xmlSchemaValidCtxtPtr vctxt)
 	VERROR(1, NULL, "The document has no document element");
 	return (1);
     }
+    for (node = valRoot->next; node != NULL; node = node->next) {
+        if (node->type == XML_ELEMENT_NODE)
+            VERROR(1, NULL, "The document has more than one top element");
+    }
     vctxt->depth = -1;
     vctxt->validationRoot = valRoot;
     node = valRoot;
@@ -28095,7 +28257,6 @@ xmlSchemaPreRun(xmlSchemaValidCtxtPtr vctxt) {
     vctxt->nberrors = 0;
     vctxt->depth = -1;
     vctxt->skipDepth = -1;
-    vctxt->xsiAssemble = 0;
     vctxt->hasKeyrefs = 0;
 #ifdef ENABLE_IDC_NODE_TABLES_TEST
     vctxt->createIDCNodeTables = 1;
@@ -28273,13 +28434,13 @@ struct _xmlSchemaSplitSAXData {
 struct _xmlSchemaSAXPlug {
     unsigned int magic;
 
-    /* the original callbacks informations */
+    /* the original callbacks information */
     xmlSAXHandlerPtr     *user_sax_ptr;
     xmlSAXHandlerPtr      user_sax;
     void                **user_data_ptr;
     void                 *user_data;
 
-    /* the block plugged back and validation informations */
+    /* the block plugged back and validation information */
     xmlSAXHandler         schemas_sax;
     xmlSchemaValidCtxtPtr ctxt;
 };
diff --git a/xmlschemastypes.c b/xmlschemastypes.c
index e7764d90..07b5fd76 100644
--- a/xmlschemastypes.c
+++ b/xmlschemastypes.c
@@ -199,7 +199,7 @@ static xmlSchemaTypePtr xmlSchemaTypeNmtokensDef = NULL;
  ************************************************************************/
 /**
  * xmlSchemaTypeErrMemory:
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle an out of memory condition
  */
@@ -1160,9 +1160,12 @@ static const unsigned int daysInMonthLeap[12] =
 #define VALID_DATETIME(dt)					\
 	(VALID_DATE(dt) && VALID_TIME(dt))
 
-#define SECS_PER_MIN            (60)
-#define SECS_PER_HOUR           (60 * SECS_PER_MIN)
-#define SECS_PER_DAY            (24 * SECS_PER_HOUR)
+#define SECS_PER_MIN            60
+#define MINS_PER_HOUR           60
+#define HOURS_PER_DAY           24
+#define SECS_PER_HOUR           (MINS_PER_HOUR * SECS_PER_MIN)
+#define SECS_PER_DAY            (HOURS_PER_DAY * SECS_PER_HOUR)
+#define MINS_PER_DAY            (HOURS_PER_DAY * MINS_PER_HOUR)
 
 static const long dayInYearByMonth[12] =
 	{ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 };
@@ -1222,7 +1225,14 @@ _xmlSchemaParseGYear (xmlSchemaValDatePtr dt, const xmlChar **str) {
     firstChar = cur;
 
     while ((*cur >= '0') && (*cur <= '9')) {
-	dt->year = dt->year * 10 + (*cur - '0');
+        int digit = *cur - '0';
+
+        if (dt->year > LONG_MAX / 10)
+            return 2;
+	dt->year *= 10;
+        if (dt->year > LONG_MAX - digit)
+            return 2;
+        dt->year += digit;
 	cur++;
 	digcnt++;
     }
@@ -1791,10 +1801,8 @@ xmlSchemaValidateDuration (xmlSchemaTypePtr type ATTRIBUTE_UNUSED,
     xmlSchemaValPtr dur;
     int isneg = 0;
     unsigned int seq = 0;
-    double         num;
-    int            num_type = 0;  /* -1 = invalid, 0 = int, 1 = floating */
-    const xmlChar  desig[]  = {'Y', 'M', 'D', 'H', 'M', 'S'};
-    const double   multi[]  = { 0.0, 0.0, 86400.0, 3600.0, 60.0, 1.0, 0.0};
+    long days, secs = 0;
+    double sec_frac = 0.0;
 
     if (duration == NULL)
 	return -1;
@@ -1819,6 +1827,10 @@ xmlSchemaValidateDuration (xmlSchemaTypePtr type ATTRIBUTE_UNUSED,
 	return -1;
 
     while (*cur != 0) {
+        long           num = 0;
+        size_t         has_digits = 0;
+        int            has_frac = 0;
+        const xmlChar  desig[] = {'Y', 'M', 'D', 'H', 'M', 'S'};
 
         /* input string should be empty or invalid date/time item */
         if (seq >= sizeof(desig))
@@ -1826,53 +1838,104 @@ xmlSchemaValidateDuration (xmlSchemaTypePtr type ATTRIBUTE_UNUSED,
 
         /* T designator must be present for time items */
         if (*cur == 'T') {
-            if (seq <= 3) {
-                seq = 3;
-                cur++;
-            } else
-                return 1;
+            if (seq > 3)
+                goto error;
+            cur++;
+            seq = 3;
         } else if (seq == 3)
             goto error;
 
-        /* parse the number portion of the item */
-        PARSE_NUM(num, cur, num_type);
+        /* Parse integral part. */
+        while (*cur >= '0' && *cur <= '9') {
+            long digit = *cur - '0';
 
-        if ((num_type == -1) || (*cur == 0))
-            goto error;
-
-        /* update duration based on item type */
-        while (seq < sizeof(desig)) {
-            if (*cur == desig[seq]) {
-
-                /* verify numeric type; only seconds can be float */
-                if ((num_type != 0) && (seq < (sizeof(desig)-1)))
-                    goto error;
+            if (num > LONG_MAX / 10)
+                goto error;
+            num *= 10;
+            if (num > LONG_MAX - digit)
+                goto error;
+            num += digit;
 
-                switch (seq) {
-                    case 0:
-                        dur->value.dur.mon = (long)num * 12;
-                        break;
-                    case 1:
-                        dur->value.dur.mon += (long)num;
-                        break;
-                    default:
-                        /* convert to seconds using multiplier */
-                        dur->value.dur.sec += num * multi[seq];
-                        seq++;
-                        break;
-                }
+            has_digits = 1;
+            cur++;
+        }
 
-                break;          /* exit loop */
+        if (*cur == '.') {
+            /* Parse fractional part. */
+            double mult = 1.0;
+            cur++;
+            has_frac = 1;
+            while (*cur >= '0' && *cur <= '9') {
+                mult /= 10.0;
+                sec_frac += (*cur - '0') * mult;
+                has_digits = 1;
+                cur++;
             }
-            /* no date designators found? */
-            if ((++seq == 3) || (seq == 6))
+        }
+
+        while (*cur != desig[seq]) {
+            seq++;
+            /* No T designator or invalid char. */
+            if (seq == 3 || seq == sizeof(desig))
                 goto error;
         }
 	cur++;
-	if (collapse)
-	    while IS_WSP_BLANK_CH(*cur) cur++;
+
+        if (!has_digits || (has_frac && (seq != 5)))
+            goto error;
+
+        switch (seq) {
+            case 0:
+                /* Year */
+                if (num > LONG_MAX / 12)
+                    goto error;
+                dur->value.dur.mon = num * 12;
+                break;
+            case 1:
+                /* Month */
+                if (dur->value.dur.mon > LONG_MAX - num)
+                    goto error;
+                dur->value.dur.mon += num;
+                break;
+            case 2:
+                /* Day */
+                dur->value.dur.day = num;
+                break;
+            case 3:
+                /* Hour */
+                days = num / HOURS_PER_DAY;
+                if (dur->value.dur.day > LONG_MAX - days)
+                    goto error;
+                dur->value.dur.day += days;
+                secs = (num % HOURS_PER_DAY) * SECS_PER_HOUR;
+                break;
+            case 4:
+                /* Minute */
+                days = num / MINS_PER_DAY;
+                if (dur->value.dur.day > LONG_MAX - days)
+                    goto error;
+                dur->value.dur.day += days;
+                secs += (num % MINS_PER_DAY) * SECS_PER_MIN;
+                break;
+            case 5:
+                /* Second */
+                days = num / SECS_PER_DAY;
+                if (dur->value.dur.day > LONG_MAX - days)
+                    goto error;
+                dur->value.dur.day += days;
+                secs += num % SECS_PER_DAY;
+                break;
+        }
+
+        seq++;
     }
 
+    days = secs / SECS_PER_DAY;
+    if (dur->value.dur.day > LONG_MAX - days)
+        goto error;
+    dur->value.dur.day += days;
+    dur->value.dur.sec = (secs % SECS_PER_DAY) + sec_frac;
+
     if (isneg) {
         dur->value.dur.mon = -dur->value.dur.mon;
         dur->value.dur.day = -dur->value.dur.day;
@@ -2636,7 +2699,7 @@ xmlSchemaValAtomicType(xmlSchemaTypePtr type, const xmlChar * value,
                 goto return0;
             }
         case XML_SCHEMAS_LANGUAGE:
-	    if (normOnTheFly) {
+	    if ((norm == NULL) && (normOnTheFly)) {
 		norm = xmlSchemaCollapseString(value);
 		if (norm != NULL)
 		    value = norm;
@@ -3628,6 +3691,8 @@ xmlSchemaCompareDurations(xmlSchemaValPtr x, xmlSchemaValPtr y)
 	minday = 0;
 	maxday = 0;
     } else {
+        if (myear > LONG_MAX / 366)
+            return -2;
         /* FIXME: This doesn't take leap year exceptions every 100/400 years
            into account. */
 	maxday = 365 * myear + (myear + 3) / 4;
@@ -4016,6 +4081,14 @@ xmlSchemaCompareDates (xmlSchemaValPtr x, xmlSchemaValPtr y)
     if ((x == NULL) || (y == NULL))
         return -2;
 
+    if ((x->value.date.year > LONG_MAX / 366) ||
+        (x->value.date.year < LONG_MIN / 366) ||
+        (y->value.date.year > LONG_MAX / 366) ||
+        (y->value.date.year < LONG_MIN / 366)) {
+        /* Possible overflow when converting to days. */
+        return -2;
+    }
+
     if (x->value.date.tz_flag) {
 
         if (!y->value.date.tz_flag) {
@@ -5069,7 +5142,7 @@ xmlSchemaGetFacetValueAsULong(xmlSchemaFacetPtr facet)
     /*
     * TODO: Check if this is a decimal.
     */
-    if (facet == NULL)
+    if (facet == NULL || facet->val == NULL)
         return 0;
     return ((unsigned long) facet->val->value.decimal.lo);
 }
@@ -6003,13 +6076,13 @@ xmlSchemaGetCanonValue(xmlSchemaValPtr val, const xmlChar **retValue)
 		    * recoverable timezone and not "Z".
 		    */
 		    snprintf(buf, 30,
-			"%04ld:%02u:%02uZ",
+			"%04ld-%02u-%02uZ",
 			norm->value.date.year, norm->value.date.mon,
 			norm->value.date.day);
 		    xmlSchemaFreeValue(norm);
 		} else {
 		    snprintf(buf, 30,
-			"%04ld:%02u:%02u",
+			"%04ld-%02u-%02u",
 			val->value.date.year, val->value.date.mon,
 			val->value.date.day);
 		}
@@ -6030,14 +6103,14 @@ xmlSchemaGetCanonValue(xmlSchemaValPtr val, const xmlChar **retValue)
 		    * TODO: Check if "%.14g" is portable.
 		    */
 		    snprintf(buf, 50,
-			"%04ld:%02u:%02uT%02u:%02u:%02.14gZ",
+			"%04ld-%02u-%02uT%02u:%02u:%02.14gZ",
 			norm->value.date.year, norm->value.date.mon,
 			norm->value.date.day, norm->value.date.hour,
 			norm->value.date.min, norm->value.date.sec);
 		    xmlSchemaFreeValue(norm);
 		} else {
 		    snprintf(buf, 50,
-			"%04ld:%02u:%02uT%02u:%02u:%02.14g",
+			"%04ld-%02u-%02uT%02u:%02u:%02.14g",
 			val->value.date.year, val->value.date.mon,
 			val->value.date.day, val->value.date.hour,
 			val->value.date.min, val->value.date.sec);
diff --git a/xmlstring.c b/xmlstring.c
index 8d2e06f6..e8a1e45d 100644
--- a/xmlstring.c
+++ b/xmlstring.c
@@ -130,16 +130,18 @@ xmlCharStrdup(const char *cur) {
 
 int
 xmlStrcmp(const xmlChar *str1, const xmlChar *str2) {
-    register int tmp;
-
     if (str1 == str2) return(0);
     if (str1 == NULL) return(-1);
     if (str2 == NULL) return(1);
+#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
+    return(strcmp((const char *)str1, (const char *)str2));
+#else
     do {
-        tmp = *str1++ - *str2;
+        int tmp = *str1++ - *str2;
         if (tmp != 0) return(tmp);
     } while (*str2++ != 0);
     return 0;
+#endif
 }
 
 /**
@@ -158,10 +160,14 @@ xmlStrEqual(const xmlChar *str1, const xmlChar *str2) {
     if (str1 == str2) return(1);
     if (str1 == NULL) return(0);
     if (str2 == NULL) return(0);
+#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
+    return(strcmp((const char *)str1, (const char *)str2) == 0);
+#else
     do {
         if (*str1++ != *str2) return(0);
     } while (*str2++);
     return(1);
+#endif
 }
 
 /**
@@ -204,18 +210,15 @@ xmlStrQEqual(const xmlChar *pref, const xmlChar *name, const xmlChar *str) {
 
 int
 xmlStrncmp(const xmlChar *str1, const xmlChar *str2, int len) {
-    register int tmp;
-
     if (len <= 0) return(0);
     if (str1 == str2) return(0);
     if (str1 == NULL) return(-1);
     if (str2 == NULL) return(1);
-#ifdef __GNUC__
-    tmp = strncmp((const char *)str1, (const char *)str2, len);
-    return tmp;
+#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
+    return(strncmp((const char *)str1, (const char *)str2, len));
 #else
     do {
-        tmp = *str1++ - *str2;
+        int tmp = *str1++ - *str2;
         if (tmp != 0 || --len == 0) return(tmp);
     } while (*str2++ != 0);
     return 0;
diff --git a/xpath.c b/xpath.c
index 9f64ab9a..6ee7e57e 100644
--- a/xpath.c
+++ b/xpath.c
@@ -135,6 +135,17 @@
  */
 #define XPATH_MAX_NODESET_LENGTH 10000000
 
+/*
+ * XPATH_MAX_RECRUSION_DEPTH:
+ * Maximum amount of nested functions calls when parsing or evaluating
+ * expressions
+ */
+#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
+#define XPATH_MAX_RECURSION_DEPTH 500
+#else
+#define XPATH_MAX_RECURSION_DEPTH 5000
+#endif
+
 /*
  * TODO:
  * There are a few spots where some tests are done which depend upon ascii
@@ -619,7 +630,7 @@ static const char *xmlXPathErrorMessages[] = {
 /**
  * xmlXPathErrMemory:
  * @ctxt:  an XPath context
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle a redefinition of attribute error
  */
@@ -662,7 +673,7 @@ xmlXPathErrMemory(xmlXPathContextPtr ctxt, const char *extra)
 /**
  * xmlXPathPErrMemory:
  * @ctxt:  an XPath parser context
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle a redefinition of attribute error
  */
@@ -1746,7 +1757,6 @@ static int xmlXPathDebugObjMaxUsers = 0;
 static int xmlXPathDebugObjMaxXSLTTree = 0;
 static int xmlXPathDebugObjMaxAll = 0;
 
-/* REVISIT TODO: Make this static when committing */
 static void
 xmlXPathDebugObjUsageReset(xmlXPathContextPtr ctxt)
 {
@@ -2061,7 +2071,6 @@ xmlXPathDebugObjUsageReleased(xmlXPathContextPtr ctxt,
     xmlXPathDebugObjCounterAll--;
 }
 
-/* REVISIT TODO: Make this static when committing */
 static void
 xmlXPathDebugObjUsageDisplay(xmlXPathContextPtr ctxt)
 {
@@ -6120,9 +6129,6 @@ xmlXPathNewContext(xmlDocPtr doc) {
     ret->contextSize = -1;
     ret->proximityPosition = -1;
 
-    ret->maxDepth = INT_MAX;
-    ret->maxParserDepth = INT_MAX;
-
 #ifdef XP_DEFAULT_CACHE_ON
     if (xmlXPathContextSetCache(ret, 1, -1, 0) == -1) {
 	xmlXPathFreeContext(ret);
@@ -10088,6 +10094,7 @@ xmlXPathCompNumber(xmlXPathParserContextPtr ctxt)
     int ok = 0;
     int exponent = 0;
     int is_exponent_negative = 0;
+    xmlXPathObjectPtr num;
 #ifdef __GNUC__
     unsigned long tmp = 0;
     double temp;
@@ -10160,8 +10167,13 @@ xmlXPathCompNumber(xmlXPathParserContextPtr ctxt)
             exponent = -exponent;
         ret *= pow(10.0, (double) exponent);
     }
-    PUSH_LONG_EXPR(XPATH_OP_VALUE, XPATH_NUMBER, 0, 0,
-                   xmlXPathCacheNewFloat(ctxt->context, ret), NULL);
+    num = xmlXPathCacheNewFloat(ctxt->context, ret);
+    if (num == NULL) {
+	ctxt->error = XPATH_MEMORY_ERROR;
+    } else if (PUSH_LONG_EXPR(XPATH_OP_VALUE, XPATH_NUMBER, 0, 0, num,
+                              NULL) == -1) {
+        xmlXPathReleaseObject(ctxt->context, num);
+    }
 }
 
 /**
@@ -10223,6 +10235,7 @@ static void
 xmlXPathCompLiteral(xmlXPathParserContextPtr ctxt) {
     const xmlChar *q;
     xmlChar *ret = NULL;
+    xmlXPathObjectPtr lit;
 
     if (CUR == '"') {
         NEXT;
@@ -10250,8 +10263,13 @@ xmlXPathCompLiteral(xmlXPathParserContextPtr ctxt) {
 	XP_ERROR(XPATH_START_LITERAL_ERROR);
     }
     if (ret == NULL) return;
-    PUSH_LONG_EXPR(XPATH_OP_VALUE, XPATH_STRING, 0, 0,
-	           xmlXPathCacheNewString(ctxt->context, ret), NULL);
+    lit = xmlXPathCacheNewString(ctxt->context, ret);
+    if (lit == NULL) {
+	ctxt->error = XPATH_MEMORY_ERROR;
+    } else if (PUSH_LONG_EXPR(XPATH_OP_VALUE, XPATH_STRING, 0, 0, lit,
+                              NULL) == -1) {
+        xmlXPathReleaseObject(ctxt->context, lit);
+    }
     xmlFree(ret);
 }
 
@@ -10288,8 +10306,10 @@ xmlXPathCompVariableReference(xmlXPathParserContextPtr ctxt) {
 	XP_ERROR(XPATH_VARIABLE_REF_ERROR);
     }
     ctxt->comp->last = -1;
-    PUSH_LONG_EXPR(XPATH_OP_VARIABLE, 0, 0, 0,
-	           name, prefix);
+    if (PUSH_LONG_EXPR(XPATH_OP_VARIABLE, 0, 0, 0, name, prefix) == -1) {
+        xmlFree(prefix);
+        xmlFree(name);
+    }
     SKIP_BLANKS;
     if ((ctxt->context != NULL) && (ctxt->context->flags & XML_XPATH_NOVAR)) {
 	XP_ERROR(XPATH_FORBID_VARIABLE_ERROR);
@@ -10396,8 +10416,10 @@ xmlXPathCompFunctionCall(xmlXPathParserContextPtr ctxt) {
 	    SKIP_BLANKS;
 	}
     }
-    PUSH_LONG_EXPR(XPATH_OP_FUNCTION, nbargs, 0, 0,
-	           name, prefix);
+    if (PUSH_LONG_EXPR(XPATH_OP_FUNCTION, nbargs, 0, 0, name, prefix) == -1) {
+        xmlFree(prefix);
+        xmlFree(name);
+    }
     NEXT;
     SKIP_BLANKS;
 }
@@ -10934,9 +10956,13 @@ xmlXPathCompileExpr(xmlXPathParserContextPtr ctxt, int sort) {
     xmlXPathContextPtr xpctxt = ctxt->context;
 
     if (xpctxt != NULL) {
-        if (xpctxt->depth >= xpctxt->maxParserDepth)
+        if (xpctxt->depth >= XPATH_MAX_RECURSION_DEPTH)
             XP_ERROR(XPATH_RECURSION_LIMIT_EXCEEDED);
-        xpctxt->depth += 1;
+        /*
+         * Parsing a single '(' pushes about 10 functions on the call stack
+         * before recursing!
+         */
+        xpctxt->depth += 10;
     }
 
     xmlXPathCompAndExpr(ctxt);
@@ -11038,7 +11064,7 @@ xmlXPathCompPredicate(xmlXPathParserContextPtr ctxt, int filter) {
  */
 static xmlChar *
 xmlXPathCompNodeTest(xmlXPathParserContextPtr ctxt, xmlXPathTestVal *test,
-	             xmlXPathTypeVal *type, const xmlChar **prefix,
+	             xmlXPathTypeVal *type, xmlChar **prefix,
 		     xmlChar *name) {
     int blanks;
 
@@ -11269,7 +11295,7 @@ xmlXPathCompStep(xmlXPathParserContextPtr ctxt) {
 	SKIP_BLANKS;
     } else {
 	xmlChar *name = NULL;
-	const xmlChar *prefix = NULL;
+	xmlChar *prefix = NULL;
 	xmlXPathTestVal test = (xmlXPathTestVal) 0;
 	xmlXPathAxisVal axis = (xmlXPathAxisVal) 0;
 	xmlXPathTypeVal type = (xmlXPathTypeVal) 0;
@@ -11379,9 +11405,11 @@ eval_predicates:
 	    PUSH_BINARY_EXPR(XPATH_OP_RANGETO, op2, op1, 0, 0);
 	} else
 #endif
-	    PUSH_FULL_EXPR(XPATH_OP_COLLECT, op1, ctxt->comp->last, axis,
-			   test, type, (void *)prefix, (void *)name);
-
+        if (PUSH_FULL_EXPR(XPATH_OP_COLLECT, op1, ctxt->comp->last, axis,
+                           test, type, (void *)prefix, (void *)name) == -1) {
+            xmlFree(prefix);
+            xmlFree(name);
+        }
     }
 #ifdef DEBUG_STEP
     xmlGenericError(xmlGenericErrorContext, "Step : ");
@@ -11649,11 +11677,11 @@ xmlXPathNodeSetFilter(xmlXPathParserContextPtr ctxt,
         res = xmlXPathCompOpEvalToBoolean(ctxt, filterOp, 1);
 
         if (ctxt->error != XPATH_EXPRESSION_OK)
-            goto exit;
+            break;
         if (res < 0) {
             /* Shouldn't happen */
             xmlXPathErr(ctxt, XPATH_EXPR_ERROR);
-            goto exit;
+            break;
         }
 
         if ((res != 0) && ((pos >= minPos) && (pos <= maxPos))) {
@@ -11672,15 +11700,7 @@ xmlXPathNodeSetFilter(xmlXPathParserContextPtr ctxt,
 
         if (res != 0) {
             if (pos == maxPos) {
-                /* Clear remaining nodes and exit loop. */
-                if (hasNsNodes) {
-                    for (i++; i < set->nodeNr; i++) {
-                        node = set->nodeTab[i];
-                        if ((node != NULL) &&
-                            (node->type == XML_NAMESPACE_DECL))
-                            xmlXPathNodeSetFreeNs((xmlNsPtr) node);
-                    }
-                }
+                i += 1;
                 break;
             }
 
@@ -11688,6 +11708,15 @@ xmlXPathNodeSetFilter(xmlXPathParserContextPtr ctxt,
         }
     }
 
+    /* Free remaining nodes. */
+    if (hasNsNodes) {
+        for (; i < set->nodeNr; i++) {
+            xmlNodePtr node = set->nodeTab[i];
+            if ((node != NULL) && (node->type == XML_NAMESPACE_DECL))
+                xmlXPathNodeSetFreeNs((xmlNsPtr) node);
+        }
+    }
+
     set->nodeNr = j;
 
     /* If too many elements were removed, shrink table to preserve memory. */
@@ -11708,7 +11737,6 @@ xmlXPathNodeSetFilter(xmlXPathParserContextPtr ctxt,
         }
     }
 
-exit:
     xpctxt->node = oldnode;
     xpctxt->doc = olddoc;
     xpctxt->contextSize = oldcs;
@@ -11773,11 +11801,11 @@ xmlXPathLocationSetFilter(xmlXPathParserContextPtr ctxt,
         res = xmlXPathCompOpEvalToBoolean(ctxt, filterOp, 1);
 
         if (ctxt->error != XPATH_EXPRESSION_OK)
-            goto exit;
+            break;
         if (res < 0) {
             /* Shouldn't happen */
             xmlXPathErr(ctxt, XPATH_EXPR_ERROR);
-            goto exit;
+            break;
         }
 
         if ((res != 0) && ((pos >= minPos) && (pos <= maxPos))) {
@@ -11795,10 +11823,7 @@ xmlXPathLocationSetFilter(xmlXPathParserContextPtr ctxt,
 
         if (res != 0) {
             if (pos == maxPos) {
-                /* Clear remaining nodes and exit loop. */
-                for (i++; i < locset->locNr; i++) {
-                    xmlXPathFreeObject(locset->locTab[i]);
-                }
+                i += 1;
                 break;
             }
 
@@ -11806,6 +11831,10 @@ xmlXPathLocationSetFilter(xmlXPathParserContextPtr ctxt,
         }
     }
 
+    /* Free remaining nodes. */
+    for (; i < locset->locNr; i++)
+        xmlXPathFreeObject(locset->locTab[i]);
+
     locset->locNr = j;
 
     /* If too many elements were removed, shrink table to preserve memory. */
@@ -11826,7 +11855,6 @@ xmlXPathLocationSetFilter(xmlXPathParserContextPtr ctxt,
         }
     }
 
-exit:
     xpctxt->node = oldnode;
     xpctxt->doc = olddoc;
     xpctxt->contextSize = oldcs;
@@ -11864,7 +11892,7 @@ xmlXPathCompOpEvalPredicate(xmlXPathParserContextPtr ctxt,
                 "xmlXPathCompOpEvalPredicate: Expected a predicate\n");
             XP_ERROR(XPATH_INVALID_OPERAND);
 	}
-        if (ctxt->context->depth >= ctxt->context->maxDepth)
+        if (ctxt->context->depth >= XPATH_MAX_RECURSION_DEPTH)
             XP_ERROR(XPATH_RECURSION_LIMIT_EXCEEDED);
         ctxt->context->depth += 1;
 	xmlXPathCompOpEvalPredicate(ctxt, &comp->steps[op->ch1], set,
@@ -12580,7 +12608,7 @@ xmlXPathCompOpEvalFirst(xmlXPathParserContextPtr ctxt,
     CHECK_ERROR0;
     if (OP_LIMIT_EXCEEDED(ctxt, 1))
         return(0);
-    if (ctxt->context->depth >= ctxt->context->maxDepth)
+    if (ctxt->context->depth >= XPATH_MAX_RECURSION_DEPTH)
         XP_ERROR0(XPATH_RECURSION_LIMIT_EXCEEDED);
     ctxt->context->depth += 1;
     comp = ctxt->comp;
@@ -12721,7 +12749,7 @@ xmlXPathCompOpEvalLast(xmlXPathParserContextPtr ctxt, xmlXPathStepOpPtr op,
     CHECK_ERROR0;
     if (OP_LIMIT_EXCEEDED(ctxt, 1))
         return(0);
-    if (ctxt->context->depth >= ctxt->context->maxDepth)
+    if (ctxt->context->depth >= XPATH_MAX_RECURSION_DEPTH)
         XP_ERROR0(XPATH_RECURSION_LIMIT_EXCEEDED);
     ctxt->context->depth += 1;
     comp = ctxt->comp;
@@ -12939,7 +12967,7 @@ xmlXPathCompOpEval(xmlXPathParserContextPtr ctxt, xmlXPathStepOpPtr op)
     CHECK_ERROR0;
     if (OP_LIMIT_EXCEEDED(ctxt, 1))
         return(0);
-    if (ctxt->context->depth >= ctxt->context->maxDepth)
+    if (ctxt->context->depth >= XPATH_MAX_RECURSION_DEPTH)
         XP_ERROR0(XPATH_RECURSION_LIMIT_EXCEEDED);
     ctxt->context->depth += 1;
     comp = ctxt->comp;
@@ -13815,7 +13843,8 @@ scan_children:
 	do {
 	    cur = cur->parent;
 	    depth--;
-	    if ((cur == NULL) || (cur == limit))
+	    if ((cur == NULL) || (cur == limit) ||
+                (cur->type == XML_DOCUMENT_NODE))
 	        goto done;
 	    if (cur->type == XML_ELEMENT_NODE) {
 		ret = xmlStreamPop(patstream);
@@ -14086,8 +14115,7 @@ xmlXPathTryStreamCompile(xmlXPathContextPtr ctxt, const xmlChar *str) {
 	    }
 	}
 
-	stream = xmlPatterncompile(str, dict, XML_PATTERN_XPATH,
-			&namespaces[0]);
+	stream = xmlPatterncompile(str, dict, XML_PATTERN_XPATH, namespaces);
 	if (namespaces != NULL) {
 	    xmlFree((xmlChar **)namespaces);
 	}
@@ -14173,7 +14201,7 @@ xmlXPathOptimizeExpression(xmlXPathParserContextPtr pctxt,
     /* Recurse */
     ctxt = pctxt->context;
     if (ctxt != NULL) {
-        if (ctxt->depth >= ctxt->maxDepth)
+        if (ctxt->depth >= XPATH_MAX_RECURSION_DEPTH)
             return;
         ctxt->depth += 1;
     }
@@ -14206,7 +14234,7 @@ xmlXPathCtxtCompile(xmlXPathContextPtr ctxt, const xmlChar *str) {
         return(comp);
 #endif
 
-    xmlXPathInit();
+    xmlInitParser();
 
     pctxt = xmlXPathNewParserContext(str, ctxt);
     if (pctxt == NULL)
@@ -14295,7 +14323,7 @@ xmlXPathCompiledEvalInternal(xmlXPathCompExprPtr comp,
 
     if (comp == NULL)
 	return(-1);
-    xmlXPathInit();
+    xmlInitParser();
 
 #ifndef LIBXML_THREAD_ENABLED
     reentance++;
@@ -14440,7 +14468,7 @@ xmlXPathEval(const xmlChar *str, xmlXPathContextPtr ctx) {
 
     CHECK_CTXT(ctx)
 
-    xmlXPathInit();
+    xmlInitParser();
 
     ctxt = xmlXPathNewParserContext(str, ctx);
     if (ctxt == NULL)
diff --git a/xpointer.c b/xpointer.c
index c1732a58..3e3c8b88 100644
--- a/xpointer.c
+++ b/xpointer.c
@@ -70,7 +70,7 @@
 
 /**
  * xmlXPtrErrMemory:
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle a redefinition of attribute error
  */
@@ -86,7 +86,7 @@ xmlXPtrErrMemory(const char *extra)
 /**
  * xmlXPtrErr:
  * @ctxt:  an XPTR evaluation context
- * @extra:  extra informations
+ * @extra:  extra information
  *
  * Handle a redefinition of attribute error
  */
@@ -1005,7 +1005,7 @@ xmlXPtrEvalXPtrPart(xmlXPathParserContextPtr ctxt, xmlChar *name) {
 	/*
 	 * To evaluate an xpointer scheme element (4.3) we need:
 	 *   context initialized to the root
-	 *   context position initalized to 1
+	 *   context position initialized to 1
 	 *   context size initialized to 1
 	 */
 	ctxt->context->node = (xmlNodePtr)ctxt->context->doc;
@@ -1352,7 +1352,7 @@ xmlXPtrEval(const xmlChar *str, xmlXPathContextPtr ctx) {
     xmlXPathObjectPtr init = NULL;
     int stack = 0;
 
-    xmlXPathInit();
+    xmlInitParser();
 
     if ((ctx == NULL) || (str == NULL))
 	return(NULL);
@@ -1536,7 +1536,7 @@ xmlXPtrBuildRangeNodeList(xmlXPathObjectPtr range) {
 		case XML_ELEMENT_DECL:
 		case XML_ATTRIBUTE_DECL:
 		case XML_ENTITY_NODE:
-		    /* Do not copy DTD informations */
+		    /* Do not copy DTD information */
 		    break;
 		case XML_ENTITY_DECL:
 		    TODO /* handle crossing entities -> stack needed */
@@ -2200,7 +2200,6 @@ xmlXPtrRangeInsideFunction(xmlXPathParserContextPtr ctxt, int nargs) {
 	     XP_ERROR(XPATH_MEMORY_ERROR)
 	set = tmp;
     }
-    oldset = (xmlLocationSetPtr) set->user;
 
     /*
      * The loop is to compute the covering range for each item and add it
@@ -2210,9 +2209,12 @@ xmlXPtrRangeInsideFunction(xmlXPathParserContextPtr ctxt, int nargs) {
 	xmlXPathFreeObject(set);
         XP_ERROR(XPATH_MEMORY_ERROR);
     }
-    for (i = 0;i < oldset->locNr;i++) {
-	xmlXPtrLocationSetAdd(newset,
-		xmlXPtrInsideRange(ctxt, oldset->locTab[i]));
+    oldset = (xmlLocationSetPtr) set->user;
+    if (oldset != NULL) {
+        for (i = 0;i < oldset->locNr;i++) {
+            xmlXPtrLocationSetAdd(newset,
+                    xmlXPtrInsideRange(ctxt, oldset->locTab[i]));
+        }
     }
 
     /*
@@ -2706,10 +2708,10 @@ static void
 xmlXPtrStringRangeFunction(xmlXPathParserContextPtr ctxt, int nargs) {
     int i, startindex, endindex = 0, fendindex;
     xmlNodePtr start, end = 0, fend;
-    xmlXPathObjectPtr set;
+    xmlXPathObjectPtr set = NULL;
     xmlLocationSetPtr oldset;
-    xmlLocationSetPtr newset;
-    xmlXPathObjectPtr string;
+    xmlLocationSetPtr newset = NULL;
+    xmlXPathObjectPtr string = NULL;
     xmlXPathObjectPtr position = NULL;
     xmlXPathObjectPtr number = NULL;
     int found, pos = 0, num = 0;
@@ -2721,29 +2723,39 @@ xmlXPtrStringRangeFunction(xmlXPathParserContextPtr ctxt, int nargs) {
 	XP_ERROR(XPATH_INVALID_ARITY);
 
     if (nargs >= 4) {
-	CHECK_TYPE(XPATH_NUMBER);
+        if ((ctxt->value == NULL) || (ctxt->value->type != XPATH_NUMBER)) {
+            xmlXPathErr(ctxt, XPATH_INVALID_TYPE);
+            goto error;
+        }
 	number = valuePop(ctxt);
 	if (number != NULL)
 	    num = (int) number->floatval;
     }
     if (nargs >= 3) {
-	CHECK_TYPE(XPATH_NUMBER);
+        if ((ctxt->value == NULL) || (ctxt->value->type != XPATH_NUMBER)) {
+            xmlXPathErr(ctxt, XPATH_INVALID_TYPE);
+            goto error;
+        }
 	position = valuePop(ctxt);
 	if (position != NULL)
 	    pos = (int) position->floatval;
     }
-    CHECK_TYPE(XPATH_STRING);
+    if ((ctxt->value == NULL) || (ctxt->value->type != XPATH_STRING)) {
+        xmlXPathErr(ctxt, XPATH_INVALID_TYPE);
+        goto error;
+    }
     string = valuePop(ctxt);
     if ((ctxt->value == NULL) ||
 	((ctxt->value->type != XPATH_LOCATIONSET) &&
-	 (ctxt->value->type != XPATH_NODESET)))
-        XP_ERROR(XPATH_INVALID_TYPE)
-
+	 (ctxt->value->type != XPATH_NODESET))) {
+        xmlXPathErr(ctxt, XPATH_INVALID_TYPE);
+        goto error;
+    }
     set = valuePop(ctxt);
     newset = xmlXPtrLocationSetCreate(NULL);
     if (newset == NULL) {
-	xmlXPathFreeObject(set);
-        XP_ERROR(XPATH_MEMORY_ERROR);
+        xmlXPathErr(ctxt, XPATH_MEMORY_ERROR);
+        goto error;
     }
     if (set->nodesetval == NULL) {
         goto error;
@@ -2756,8 +2768,10 @@ xmlXPtrStringRangeFunction(xmlXPathParserContextPtr ctxt, int nargs) {
 	 */
 	tmp = xmlXPtrNewLocationSetNodeSet(set->nodesetval);
 	xmlXPathFreeObject(set);
-	if (tmp == NULL)
-	     XP_ERROR(XPATH_MEMORY_ERROR)
+	if (tmp == NULL) {
+            xmlXPathErr(ctxt, XPATH_MEMORY_ERROR);
+            goto error;
+        }
 	set = tmp;
     }
     oldset = (xmlLocationSetPtr) set->user;
@@ -2830,7 +2844,8 @@ xmlXPtrStringRangeFunction(xmlXPathParserContextPtr ctxt, int nargs) {
      * Save the new value and cleanup
      */
 error:
-    valuePush(ctxt, xmlXPtrWrapLocationSet(newset));
+    if (newset != NULL)
+        valuePush(ctxt, xmlXPtrWrapLocationSet(newset));
     xmlXPathFreeObject(set);
     xmlXPathFreeObject(string);
     if (position) xmlXPathFreeObject(position);
diff --git a/xstc/Makefile.am b/xstc/Makefile.am
index 5ef18192..1c977248 100644
--- a/xstc/Makefile.am
+++ b/xstc/Makefile.am
@@ -26,7 +26,7 @@ EXTRA_DIST=xstc.py xstc-to-python.xsl
 all:
 
 #
-# Rule to load the test description and extract the informations
+# Rule to load the test description and extract the information
 #
 $(TESTDIRS) Tests/Metadata/$(NISTTESTDEF_2) Tests/Metadata/$(MSTTESTDEF) Tests/Metadata/$(SUNTESTDEF):
 	-@(if [ ! -d Tests ] ; then \
diff --git a/xstc/xstc.py b/xstc/xstc.py
index ca011bb8..21c1f419 100755
--- a/xstc/xstc.py
+++ b/xstc/xstc.py
@@ -213,7 +213,7 @@ class XSTCTestCase:
 			tokens = self.groupName.split("-")
 			self.combineName = "%s-%s" % (tokens[0], tokens[1])
 		else:
-			self.combineName = "unkown"
+			self.combineName = "unknown"
 			raise Exception("Could not compute the combine name of a test.")
 		if (not options.silent) and (self.group.descr is not None):
 			self.log.append("'%s'   group-descr: %s\n" % (self.name, self.group.descr))
